http://cs106b.stanford.edu/about_assessments
We know that you are working hard on completing your assignments and that this work forms the primary mechanism for learning and mastering concepts in CS106B. If, after completing an assignment, you have a solid and confident understanding of how and why your code works, you are on the right track toward a deep understanding of CS106B's core concepts! Since assignments focus on specific topics throughout the course progression, it can be valuable to have additional summative opportunities to assess your learning and receive feedback on your progress. To adapt to the online learning format being used, we want you to have the opportunity for assessment but with lower stakes and less stress than a traditional exam format would have. Therefore, we are going to experiment with a different format for assessments: a low-stakes mid-quarter diagnostic with a self-reflection component and a creative end-quarter personal project you develop and present your own final exam or section problem. These assessments will feature opportunities for feedback, check-ins, and self reflection, as well as interactive discussion with your section leader. This interactive discussion allows two-way communication where you can demonstrate what you've learned and respond to questions from your section leader. We will have more information about these assessments as the quarter progresses. Our primary focus is to take advantage of the virtual learning environment to create assessments that will allow you to demonstrate what you've learned in the class rather than testing you under strict time constraints as in a traditional exam. If you have any concerns about the assessment structure, please feel free to reach out to the course staff.
http://cs106b.stanford.edu/about_assignments
We have a great set of assignments planned to give you practice with the material presented in lecture and section. Programming is a skill best learned by doing and these assignments form an integral part of your experience in this course. These projects will be fun, challenging, illuminating, and rewarding. Your sincere efforts on the assignments will help you develop powerful skills and a deeper understanding of computational problem-solving. Common questions about assignments What programming environment and tools are used? Programs are written in the C++ language and we use the Qt Creator IDE for editing, compiling, and debugging. Please visit the Qt Installation Guide for install instructions. What is the assignment schedule? We have 7 assignments planned, about one each week, with a little breather during mid-quarter and end-quarter. See the course schedule for our tentative plans. What is the expected assignment workload? Depending on the week's topics, the accompanying assignment may consist of written problems, hands-on exercises with the tools, targeted coding tasks, and/or a larger complete program. Students self-report spending between 10 and 20 hours on each assignment. What is the policy on late assignments? Assignments will be due at 11:59pm Pacific Time. Assignments submitted by the due date earn a small on-time bonus. There may be a penalty-free grace period for late submission. Read our course late policy for the details. What is the assignment collaboration policy? The assignments are to be done individually and should represent independent, original work. We adhere to the Stanford and CS department Honor Code policies. Please review our Honor Code policy for specific examples of its application to our course. How are assignments evaluated? Programs will be graded on "functionality" (is the program's behavior correct?) and "style" (is the code well written and elegant?). We use a bucket grading scale to focus attention on the qualitative rather than quantitative feedback: + Exceeds our expectations, is effectively "perfect". WOW! To receive this grade, a program often reflects additional work beyond the requirements or gets the job done in a particularly elegant way. Satisfies all the requirements for the assignment, showing solid functionality as well as good style. Nice job! Meets the requirements for the assignment, with a few small problems or areas of improvement. Solid work. Has problems serious enough to fall short of the requirements for the assignment. Needs improvement. - Has extremely serious deficiencies, does not demonstrate significant effort and understanding. Danger 0 Not submitted. How do we receive feedback from our grader? A great feature of the CS106 courses is that your programs are graded interactively in a one-on-one session with your section leader so you get targeted feedback for individual improvement. Your section leader will explain in section how to schedule these sessions and go over the grading process in more detail.
http://cs106b.stanford.edu/about_lectures
Our lectures are scheduled for MWF 10-11am Pacific. In our scheduled time, we will deliver a live lecture via Zoom Webinar. We plan a 50-minute lecture and will use the remaining time for follow-up questions and discussion. Zoom links can be found on the course Canvas page calendar, in addition to the Zoom Information page of the course website. Lecture recordings will be posted to the Panopto Course Videos tab of the course Canvas page for later asynchronous viewing. Common questions about lectures What tools will I need? To stream the live video and audio feed, you will need good bandwidth and Zoom (either installing the app or use the web portal). If your bandwidth is limited, you can call into Zoom from a phone to get audio only, and have the lecture slides and code up in your browser at the same time to follow along. You can also watch the lectures asynchronously by accessing the posted video on Canvas, which will be posted later in the day after lecture occurs. How can I ask questions during lecture? You can submit a question via the Zoom Q&A panel. We will save the written Q&A transcript and post with lecture. You can also use the Zoom Participants panel to virtually raise your hand. We will call on you to unmute yourself and verbally ask your question. Is attendance required at the live lecture? No. We encourage you to attend live when it is possible for you to do so, but the recorded videos will also be posted to Canvas for later asynchronous viewing.
http://cs106b.stanford.edu/about_section
Each week, you'll meet for an hour in a small group discussion section. The discussion section will be led by your assigned section leader, who is also your mentor and grader in the course. During section, you and your peers will review the material that has been introduced in lecture, work together on the section practice problems, and ask and answer questions. The section materials for each week consist of a set of problems for further practice with the recent lecture topics. You're not expected to complete these problems before attending section nor are they submitted to be graded. Attendance and participation in section will be mandatory for all students. Your section leader will be grading your participation in section on a weekly basis, and these grades will make up 10% of your final grade. Participation in section can take many forms, including asking questions, contributing answers, and participating in discussions with fellow students. Common questions about sections How do I sign up for section? Section signups are conducted on the CS198 section portal (do not sign-up for sections on Axess). The section portal will open signups at Thursday, September 17 5:00 pm PDT and close at Sunday, September 20 5:00 pm PDT. Unlike Hamilton tickets, section sign-ups are not first-come first-serve, so don't worry about rushing to be first. You may submit your preferences at any time while signups are open, just be sure to submit before the window closes. Once closed, the process matches students to sections based on preference and availability and your section assignment will be emailed to you. Sections begin the second week of classes. Is section attendance mandatory? Yes, attendance and participation in section will be graded and will make up 10% of your final grade in the class. We expect students to regularly attend section and participate with a high level of engagement. If you have concerns about your ability to attend or participate in section, due to challenging circumstances (time zone, technological barriers, etc.), please email the head TA to discuss possible accommodations. How is section participation graded? Section participation will be graded on this scale: 2 : Showed up to section on time, followed section norms, participated in an engaged manner 1 : Showed up to section late, minimal participation 0 : Did not show up to section, or did not follow established section norms and policies Where can I find the section problems? The section problems will be posted on the course website under the "Sections" tab at the beginning of every week. At the end of the week, the section handout will be updated with the solutions. What tools will I need for section? Similar to lectures, section will be conducted virtually over Zoom. You can find your assigned section time and Zoom meeting information on Paperless. The program coordinators provided this helpful Guide to Section for Students sure to check that out for section tips and FAQs! Where can I find my section Zoom information? You can find the Zoom information for your assigned section on Paperless. What should I do if I must miss a section meeting? You are welcome to attend an alternate section as a guest for a makeup. Visit the cs198 section portal for the full list of all section times and zoom links. Tell the section leader whose section you attend that you're attending as a guest so they can pass the participation grade back to your section leader. You can also work the section problems on your own as self-review, but participation credit is specifically earned by attending and participating in a section.
http://cs106b.stanford.edu/about_staff
Chris Julie Chase Nick Section leaders Alex Ali Amir Andrew Andy Cathy Colin Emily Frankie Hannah Isaac Jerry Jonathan Jr Kaitlin Kathleen Keegan Kiara Lauren Manav Mark Matthew Max Neel Peter Robbie Ryan Sam Sanjaye Shane Sidhika Tommy Tori Trisha Varun Will Zheng Common questions about section leading How do I become a section leader someday? You can apply during/after completing 106B. Come join us! Information about applying can be found on the CS 198 Website.
http://cs106b.stanford.edu/announcements.html
Free Online CTL Tutoring 3 days ago by Nick Hi everyone, I just wanted to pass along an announcement from the Center for Teaching and Learning regarding help resources that are available to you this quarter: Want to meet with an experienced peer to discuss course concepts, think through a problem set, or prepare for an upcoming exam? CTL offers appointment tutoring for CS 106B, in addition to tutoring for a number of other courses. For more information and to schedule an appointment, visit our tutoring appointments and drop-in schedule page. We also have a variety of remote learning resources and academic coaching available to assist with all of your learning needs! In addition, make sure to check out Julie's Ed post about Black LaIR! Assignment 1 released 1 week ago by Julie Assignment 1 is out! This assignment reinforces C++ fundamentals, control flow, functions decomposition, strings, as well as good testing and debugging practices. Please consider joining Trip at the YEAH (Your Early Assignment Help) session Sunday night 6-7pm Pacific to jump start on your work. (See Zoom info page for link) QT Installation Help Session 1 week and 2 days ago by Chase and Nick The Qt Installation Help Session will be happening tonight from 6-8pm PDT. The point of this help session is to help those of you that have encountered issues in the installation process. To save time, please make sure you have attempted to work through the installation process before coming to the help session. For those of you that want to attend the session, we will be using Queuestatus to manage requests. You can get in line to get help by signing up for the queue after it opens at 6pm. When signing up, please make sure to include a link to a Zoom meeting where we can join you. Week 1 Announcements 1 week and 5 days ago by Chase and Nick We've just posted our first weekly announcements/logistics summary on Ed. If you did not receive an email notification about the announcement, please make sure to sign up for the Ed Discussion Forum, as all important class announcements will be made via Ed for the rest of the quarter! Welcome to CS106B! 1 week and 6 days ago by Chase and Nick Earlier today, we sent out an email announcement to everyone in the class, welcoming them to CS106B. If you did not receive this email but were expecting to, please confirm your enrollment status on Axess. We have replicated a summary of some of the action items of the email announcement here. Read the course syllabus. Check out the CS106B Ed Discussion Forum. You will be able to use this forum to ask questions and have discussions with course staff and your fellow students. Our first class will be on Monday, September 14 from 10-11am Pacific Time (UTC -7). Go to the course Canvas calendar or the Zoom Info page to get a link to the Zoom Webinar being used to host lecture. Keep an eye on the course website (where you are at right now), our central hub for lectures, assignments, and other resources. For some of you this will be the first Computer Science class that you have taken at Stanford. If you are unsure whether this course is the correct one for you to be enrolled in, we have a helpful course placement guide on the website which should help clarify the differences between the introductory CS classes (106A, 106B and 107). During these unprecedented times, we want to make sure that everyone will be able to get the most out of this course while prioritizing your mental health. As a course staff, we hope to support you as much as possible. Please also remember to make use of campus resources such as the Vaden Health Center, which will be providing one-on-one Well Being Coaching sessions to help support students in achieving well-being in these challenging times. Computer science is a tool that allows us to make constructive and powerful contributions to the world, and we hope to help unlock those opportunities for you through this course. Please don't hesitate to reach out to us if you have any questions. We're looking forward to meeting you all in lecture on Monday! Apply to CS100B (ACE/Pathfinders) 2 weeks and 4 days ago by Nick CS100B, also known as CS106B ACE, is a 1-unit supplementary section designed to build a stronger foundation in computer science. Students participating in ACE will attend an additional weekly section and participate in exam review sessions and individual tutoring. Section will take place on Tuesday from 6-8pm PDT on Zoom, with options for asynchronous participation for those outside the United States. ACE is one of the School of Engineering's Equity and Inclusion Initiatives. We especially want to provide an opportunity for students who come from educationally disadvantaged backgrounds or for anyone who feels they might need additional support in order to succeed. We limit enrollment to enable small classes that allow students to have one-on-one interactions with the TA. If you are interested in joining the ACE section, please apply online. The application is due on 9/18. All student who apply by 9/14 will be welcome to attend section the first week and will receive a Zoom link for section via email during Week 1. If you have any questions about ACE, feel free to reach out to Garrick Fernandez (CS106B ACE TA) at gfaerr@stanford.edu. Fall Quarter 2020 4 weeks and 1 day ago by Julie This is the course website for CS106B Fall Quarter 2020. This website is under construction in preparation for our start on Sept 14th; please pardon our dust as we work. In the meantime, if you are a prospective student looking to learn more about CS106B, check out the course syllabus and our answers to frequently asked questions from prospective students. Previous quarter's website 1 month and 2 days ago by Julie Here is the archived website for summer quarter.
http://cs106b.stanford.edu/citation
At the end of the quarter, we run analytic software over all CS106B submissions to find sections of student-submitted code that have been copied from elsewhere rather than independently written by the student. A staffer then reviews the situation to determine appropriate followup. With a correct understanding of the authorship, we can ensure that credit is being awarded properly. Accurate attribution of code authorship is an important tenet of the programming community and of academic integrity in general. The purpose of this notice is to provide students with the opportunity to retroactively add any citations missing from the original submission, to set the record straight before our analytic software is run. Permissible re-use The course policy on collaboration and the Honor Code allows students to exchange ideas with others, but not to share or copy code. If you are in office hours or discussing the assignment with other students and a few lines of code are jointly sketched, it is fine to learn from those lines and incorporate them into your assignment. Your assignment might also take inspiration from a code example in lecture, section, or the textbook. Both of these situations are within the spirit of exchanging ideas, learning from others, but writing the code yourself. This help is entirely permissible, but please be sure to cite any direct influence. The code you submit is still distinctly your own and you retain full authorship; the citation simply acknowledges the work of others that influenced your code. Unpermissible re-use In contrast, an honor code violation looks more like having access to solution code (such as found on the Internet or written by another current or past student) and basing your submission off of it, whether reusing an exact copy or borrowing code sections from it and remixing. Submitting this code without citation is a misrepresentation of authorship and is a breach of academic integrity written by another is being passed off your own. This is unacceptable, and the CS department has become adept at identifying instances of misrepresented authorship using sophisticated tools. Unpermitted collaboration/partnership There is yet a third category where two current students work together and both submit the same/similar code based on the joint work. Submitting such work as your own without acknowledging the contributions of another is also a misrepresentation of authorship. Past quarters have allowed partnership, but this quarter does not. If you have mistakenly engaged in a disallowed partnership, we offer you the option to provide a retroactive citation of that collaboration. This citation opens the path to a resolution where we work with you to establish a fair attribution of authorship, and adjust allocated credit accordingly. Making a retroactive citation If you are concerned that some of your work is missing a necessary citation, please consider reaching out to set things right: Email one of the instructors as soon as possible to make a retroactive citation. Please identify the affected code, the collaboration that occurred, and your interpretation of how this collaboration fell onto the spectrum of permissible -> not permissible. There are a number of possible outcomes in response: If the retroactive citation cites permissible help, your citation acknowledges that contribution and corrects the previous oversight. There is no further action to take. If the retroactive citation cites use of work of another as your own, we would not be able to award you credit for that work. We would discount/zero the score to reflect your diminished contribution. If the retroactive citation cites work done in collaboration with another student, we will follow up to understand the extent of the collaboration and adjust grading credit to reflect an appropriate division of work and authorship. In all of the above, if the retroactive citation corrects the previous misrepresentation of authorship, there is no longer an Honor Code violation and there is no followup with the judicial office. If you are not sure of how to proceed, please reach out to us. We very much appreciate those of you who want to do the right thing, and we will meet for a constructive, non-judgmental review of what has happened and what is the best way forward. Why not partners? In the past, there has been the option to work with a partner on assignments. This was never intended to be a division of labor where each student contributed half of the code. Instead, we guided students to use a pair programming approach: two students code as one entity, working together on a shared computer throughout the project. Studies have shown that pair programming does not reduce the time spent by each student, but it can result in better outcomes for student learning and many students value the feeling of camaraderie and support that comes from partnership. However, pair programming is challenging to do at a distance, and the disparate situations our students are currently experiencing make partnership not a viable option for all. Given the constraints of a remote quarter and recognizing the significant external stresses, we committed to these decisions for CS106B this quarter: lower-stakes form of assessments upweight contribution of assignments to course grade all students complete the assignments as individuals The assignments are known to be the best way for students to learn the material, and the above changes give primacy to that work. Furthermore, doing this work independently certifies the individual student's completion of the course learning objectives.
http://cs106b.stanford.edu/resources/commonissues.html
This page contains a list of common issues students may encounter when trying to build, run, or debug their code. If you're stuck on an issue, try searching this page using Ctrl+F (Command+F on Mac) to jump quickly to the text matching the error message or description of the issue you are having. You can also check out the Qt troubleshooting guide if you're having issues with Qt Creator. If you're emailing or posting your issue on Ed First of all, please make sure you've searched through this guide as well as the existing posts on Ed. Often you'll see that a similar problem has already been raised and resolved, and this will reduce your time spent waiting on a response. Also, don't forget that error messages can often be found online, so try using your favorite search engine to look up your error message to see what the Wisdom of the Internets has to say. If you are unable to find your issue either below, on Ed, or on the Internet, then here's what you should include in your Ed post/email: What steps you've taken to find the bug: This might be walking through the debugger or using cout statements or constructing targeted test cases to narrow in on it. A specific question: We generally will not simply debug your code for you, so please be specific on the issue you're having. What tests cases are triggering the bug? What line or lines specifically seem to be causing a failure? What have you tried to do to diagnose the bug so far? The error message: Please include the specific error message from the Application Output or Compiler Output tab, if there is one. A code snippet: If posting your code on Ed, make sure the post is private. Do not paste images or screenshots of your code/error messages, instead copy and paste the text into your post. Neatly format your code, using the runnable or non-runnable code formatter on Ed. Please don't include your entire file, isolate to the portion of the code that is relevant to the error. Build warnings and errors Build warnings: I get tons of yellow warning flags all over my code, including for code in the library that I did not write myself. Recent versions of Qt Creator have added a feature called a "code model" that performs style checking on your code as you write it. This is sometimes useful, but we think the checker is too picky and gives warnings about code that is not dangerous. You can safely ignore these unnecessary warnings. If you'd like to make the warnings go away, change the Analyzer to our Qt Creator Recommended Settings. Build error: Build progress meter is solid red, QFileSystemEngine::currentPath: getcwd() failed On macOS, this error indicates that Qt Creator was prevented from accessing the project files because the application lacks the needed privileges. In order to build a project, Qt Creator needs to be able to read and write files. You can grant Qt Creator access by agreeing when you get an alert such as this one: You can also go to "System Preferences" -> "Security & Privacy" -> "Privacy" tab -> "Files and Folders" to review and change what access has been granted to individual applications. Build error: use of undeclared identifier This means you're either using a variable or calling a function that has not yet been defined. Double-check that there's not a typo, and also make sure that you've added function declarations at the top of your file before you call them (or that they're declared in your header file). Build error: symbol(s) not found for architecture x86_64 or linker command failed with exit code 1 This means that your code calls a function that was never defined. This could indicate there is a typo in the function name or mismatch in the number or type of parameters. You may also have two identical function definitions, or you modified the definition of a provided function (look through the assignment handout and make sure you're not redefining functions you're not supposed to!). To get more information, click on the Compile Output tab near the bottom of the screen, and look through the output to find the name of the function(s) that is undefined so you know where to look to find the error. Build error: Duplicate symbol for architecture x86_64 This indicates you have two or more definitions of the same function. Each function should have only one definition. To get more information about the error, click on the Compile Output tab near the bottom of the screen and look through the output to find the name of the duplicate function(s). This could mean you mistakenly copy/pasted the definition twice or you added the same file to the project more than once. If the problem is the latter, your best bet is to re-initialize the project to reset all files. Build error: xcopy command invalid number of parameters There are certain applications that conflict with Qt Creator. A few applications we know are problematic are: Cygwin Git / GitHub Rtools Strawberry Perl Windows Services for Unix The applications install files (most notably a program called sh.exe) that confuse Qt Creator. If you have any of the above programs installed, your best bet is to uninstall them or to use a machine that does not have that software installed. Sometimes you can modify the application so that it will not conflict with Qt Creator, by removing or renaming the offending files. For example, if you have git installed, you can use your file explorer to go to Git's usr/bin subdirectory (default is C:\Program Files\Git\usr\bin) and rename the file sh.exe to sh2.exe. Build error: Terse, cryptic message in Issues tab, e.g. Error What is reported in the Issues tab may be terse and/or unhelpful. Instead click the bottom Compile Output tab to view more detailed information about the build activity. Use these additional details to further diagnose the problem. Build error: Generic build error, e.g. Error 1 or Error 2 or copyResources Error 4 Be sure to check in the Compile Output tab for additional details that might further diagnose the problem. One common cause of generic build errors is having stored your project in a directory whose name includes certain disallowed punctuation (like parentheses) or international characters (e.g. Chinese, Korean, etc.) Try moving your project into a simple folder name containing only English characters, and then re-initialize your project Build error: function declared in block scope cannot have 'static' storage class or function definition is not allowed here This means you have a mismatched set of curly braces (i.e. { and }), so your compiler thinks your functions following this mismatch are being defined inside another function. It may be easier to see where this mismatch is if you auto-indent your code (by selecting all with Ctrl-A/Command-A and indenting with Ctrl-I/Command-I). Build error: no matching member function for call to '[function name].' or candidate function not viable: no known conversion... or no matching function for call to... '[function name]' This means you're calling a function with different parameters from what it's designed to handle. If this is a function you've written, make sure you're calling it with the parameters that you've defined it to take. If this is a library function, you might want to double check the documentation for C++ Standard library functions or Stanford library functions. Build error: type of parameter of declaration does not match definition... This means the type of parameters in the function definition differs from the types in the earlier function declaration. Make sure you're using the same parameters and parameter types that you've defined (especially pay attention to whether or not parameters are passed by reference!). Build warning: control may reach end of non-void function This indicates that you may not be returning in all possible cases in a function. If you're returning inside if statements, make sure you're returning something in every else case. Build warning: loop will run at most once This usually shows up when you're returning inside of a for or while loop without condition checking. Remember that as soon as you hit a return statement, you'll exit the function, so if you have a loop with an unconditional return statement inside, the loop will only run the first iteration before hitting the return and exiting the function. Build error: invalid operands to binary expression in EXPECT_EQUAL The longer form of this error message gives additional information: testing/TestDriver.h:145:16: error: invalid operands to binary expression ('const Vector<int>' and 'const int') return lhs == rhs; ~~~ ^ ~~~ In instantiation of function template specialization '_areEqual<Vector<int>, int>' requested here EXPECT_EQUAL(vec, num); This error indicates that your code is mis-using EXPECT_EQUAL. The arguments to EXPECT_EQUAL must be two values that can be compared using ==. The above use of EXPECT_EQUAL attempts to compare a Vector<int> to a single number; this is illegal. Build warning: comparison of integers of different signs: int and unsigned long In C++, values that represent sizes use the special type size_t, which is an unsigned data type. The regular int type, in contrast, is signed. Although the two types can largely be treated the same, the compiler flags comparison with warning. Setting aside the mysteries of signed and unsigned representation to be revealed in CS107, it's enough to know that it is okay to ignore this particular warning. If the warning irks you, you can configure Qt Creator to hush up about it. Edit the Code Model preferences to suppress sign comparison warnings following these steps: Go to Qt Creator->Preferences. Choose {} C++. Select the tab labeled Code Model. Click Manage. Click Copy. Add -Wno-sign-compare to the text box. Click OK. Select Checks for questionable constructs (Copy) to the right of Manage. Click OK. Runtime errors Runtime error: My program abruptly halts during execution. Error: Runtime Error or Application has unexpectedly quit or Runtime terminated in an unusual way or The program has unexpectedly finished or The process was ended forcefully This means the program has "crashed" or exited due to an error during execution. This generally means the program has a bug that attempts an illegal operation or causes an exception to be thrown. Clicking the Application Output tab might provide some additional information and a more specific error for why your program crashed - make sure to read the error message occurring after An ErrorException occurred during program execution. The best way to proceed on diagnosing an execution error is to use the debugger. Instead of clicking the plain green triangle "Play" to run your program, click the green triangle with a bug on it. This runs your program under the debugger. When your program encounters the error which caused the problem, your program will stop in the debugger and show you where in your code the crash occurred. The Assignment 0 debugger tutorial introduces various strategies about how to use of the debugger - we highly recommend working through the tutorial if you have not already! One possible reason for a program crashing is due to a stack overflow, which is what happens if a recursive function calls itself too many times (you can tell this if you open the debugger and see the same function name repeatedly in your stack frames): Runtime error: basic_string::erase: __pos > this->size() This means you're trying to erase at an index that is not valid for the string. Try running under the debugger or using cout statements to understand why your code is attempting to erase at an index out of bounds of the size of the string (remember that strings are zero-indexed!). Runtime error: Vector::operator []: index of [some number] is outside of valid range This indicates that you're indexing at some value in a Vector that's not a valid index for the size of the Vector. Try running under the debugger or using cout statements to understand why your code is indexing at a value that is out of bounds (perhaps check if you're going out of bounds in a loop). Don't forget that Vectors are zero-indexed! Runtime error: A segmentation fault (SIGSEGV) occurred during program execution. This indicates that you're dereferencing a pointer that is null or invalid. If you're not working with pointers, it's probably that you have some code that is creating a problem so that the underlying function you are calling fails. If you run the code in the debugger, the debugger should stop where the code crashes. It will possibly be in a function you didn't write (but that doesn't mean you didn't cause the issue). If that is the case, you can look down in the "Debugger" window at the bottom, and click on function names, going down the list until you find your own code. If you're working with recursion, this can also sometimes happen when you have a stack overflow, which is what happens if a recursive function calls itself too many times. (This can sometimes also cause the debugger to not be able to catch the crash.) Double check that your recursive functions will always eventually reach their base cases. Runtime warning: Qt internal warning: Populating font family aliases took ms. Replace uses of missing font with one that exists to avoid this cost This is a harmless warning about font substitutions. You can safely ignore it. Help! It still doesn't work! If you had read through the list of known fixes and were not able to resolve your issue, we will try our best to help you figure it out. Drop into LaIR and show us the problem over Zoom. Or you can contact us via forum/email to get help, making sure to follow the directions above. Thanks, and good luck! You can do it!
http://cs106b.stanford.edu/course_placement
The CS department offers many programming courses and it can be difficult to know exactly where to begin. This handout provides a general overview of these classes and some advice about selecting the class that's right for you. If you have any questions, please feel free to come talk to the course staff! We'd be happy to offer one-on-one advice. CS106A: Start here! CS106A is our first-quarter programming course. It teaches the widely-used Python programming language along with good software engineering principles. If you're interested in learning how to program a computer, this is the place to start. CS106A has no prerequisites - it's open to everyone! The course is explicitly designed to appeal to humanists and social scientists as well as hard-core techies. In fact, most CS 106A graduates end up majoring outside of the School of Engineering. The course requires no previous background in programming, but does require considerable dedication and hard work. We've found that some high school CS classes are more rigorous than others. If you do have high school CS experience, we recommend reviewing the syllabus for CS106A to get a sense of what it covers. If you feel that you've seen all these topics before, you may want to start off in CS106B. We recommend that you take CS106A if You are interested in learning to program computers. You have little to no prior programming experience. We recommend that you not take CS106A if You have prior programming experience at a level comparable to an introductory college course (for example, if you scored a 4 or 5 on the AP CS exam). You have prior programming experience and want to learn how to program in Python. In the 2020-2021 academic year, CS106A is offered every quarter. Visit the CS106A website. CS106B: Next step CS106B is our second course in computer programming. It focuses on techniques for solving more complex problems than those covered in CS106A and for analyzing program efficiency. Specifically, it explores fundamental data types and data structures, recursive problem solving, graph algorithms, and basic algorithmic analysis. CS106B assumes you have programming experience at the level of CS106A, though you don't necessarily have to have taken our CS106A course in order to take CS106B. If you're experienced with basic control structures (conditions, loops), variables, arrays/lists, maps, and program decomposition, then you should be ready to take CS106B. CS106B is taught using the C++ programming language, but uses C++ more as a vehicle for ideas than as an object of study. If you're interested in studying C++ in depth, consider looking into CS106L. We recommend that you take CS106B if You have prior programming experience at the level of CS106A. You are interested in learning more about problem-solving with computers. You've programmed before but have not seen recursion, data structures, or algorithmic analysis. We recommend that you not take CS106B if You already have completed equivalent coursework elsewhere. You have little to no prior programming experience. You have prior programming experience and want to specifically learn C++ programming. In the 2020-2021 academic year, CS106B is offered every quarter. Visit the CS106B website. Optional add-ons to CS106B We offer several courses that are designed to complement CS106B with additional material. None of these courses are required, and they do not count toward the CS major or CS minor requirements. However, if you're interested in going deeper for your own enrichment, you may find them worth checking out! C++ Language: CS106L CS106L is an optional 1-unit companion course to CS106B that focuses purely on the C++ programming language. Unlike CS106A and CS106B, which focus more on general programming skills and fundamental programming concepts, CS106L is specifically designed to focus on language features particular to C++ and how to use the C++ programming language to solve problems. Although CS106L is designed as a companion course to CS106B, it's open to anyone with a comparable background. We recommend that you take CS106L if You have prior programming experience at the level of CS106B (or are currently enrolled.) You are interested in learning more about the C++ programming language and the standard libraries. You are willing to put in more work than is necessary for CS106B. We recommend that you not take CS106L if You want a deeper understanding of topics like recursion, data structures, or big-O notation. You want to learn programming at the level of CS106B, but don't have the time to take those courses. In the 2020-2021 academic year, CS106L is offered in Autumn, Winter, and Spring quarters. Visit the CS106L website. More adventures: CS106M CS106M is an optional 1 unit add-on course to CS106B that explores supplemental material in a small discussion setting. For example, this year's offering will likely cover topics like data compression, error-correcting codes, and digital signatures. The topics covered in CS106M will not be required by later CS courses, even if you are planning to major in CS. We recommend that you take CS106M in addition to CS106B if: You are currently enrolled in CS106B. You are interested in exploring additional topics and deepening your study of the course material in a small discussion setting. You are willing to put in more work than is necessary for CS106B. We recommend that you not take CS106M if You are concerned that you "need" to take CS106M to avoid falling behind everyone else. In the 2020-2021 academic year, CS106M is offered only in Fall quarter. Social Good: CS106S CS106S is an optional 1 unit add-on course to CS106B that gives you a chance to work on programs for social good. The class brings in student groups, nonprofits, and local tech companies and is a mix of a speaker series and small project course. The course also teaches basic web development, but is not meant to be a stand-alone web development course. We recommend that you take CS106S in addition to CS106B if You are interested in exploring social good applications of computer science. You are willing to put in more work than is necessary for CS106B. In the 2020-2021 academic year, CS106S is offered in Autumn, Winter, and Spring quarters. Visit the CS106S website. Can I skip the intro courses altogether? Many students entering Stanford today have had considerable programming experience in high school or from their own independent work with computers. If you are in that position, the idea of starting with a beginning programming course-even an intensive one like CS 106B-seems like a waste of time. Your perception may in fact be correct. In our experience, there are somewhere between 10 and 15 students in each entering class who should start at a more advanced point in the sequence. Below we talk about some of these more advanced classes (CS107 and CS107E). For most of you, however, the right place to start is with the CS 106 series. Most high-school computing courses are somewhat weak and provide little background in modern software engineering techniques. By taking CS 106, you will learn how the CS department at Stanford approaches programming and get a solid foundation for more advanced work. If you're unsure where you should start the programming sequence, please talk with us. CS107: How it all works After completing the intro programming sequence, CS107 takes you under the hood to learn the ins and outs of computer systems. It explores how high-level programming constructs are represented internally inside the computer and how those internal representations affect program behavior and performance. Along the way, it provides programming maturity and exposure to developing software in a Unix environment. CS107 has CS106B as a prerequisite and assumes an understanding of fundamental programming techniques and good programming style. As a result, it's rare for incoming students to jump directly into CS107 and to skip the CS106 series entirely. Typically, we'd only recommend this to students with a background comparable to CS106A/B and who already have good programming style. Most students, even those who go on to be CS majors, usually begin in the CS106 sequence. We recommend that you take CS107 if You have completed CS106B or have the equivalent programming background, including familiarity with recursion and fundamental data structures (binary trees, dynamic arrays, linked lists, graphs, etc.) You have experience writing readable code - writing comments, decomposing problems into smaller pieces, etc. We recommend that you not take CS107 if You have never before taken a class in computer programming. You have prior programming experience but have not met the postconditions of CS106B. Visit the CS107 website. CS107E: How it works, embedded CS107E is version of CS107 that covers similar topics but which focuses on programming a small computer that can easily fit into the palm of your hand. The class is smaller and more project-oriented than CS107 and lets you play around with small embedded devices to see how low-level systems concepts directly let you control physical devices. The CS107E FAQ offers perspective on advice on choosing between 107 and 107E. We recommend that you take CS107E if You meet all the requirements for CS107. You enjoy working on open-ended projects. We recommend that you not take CS107E if You're nervous about taking CS107 and want to satisfy that requirement in a different way. Visit the CS107E website.
http://cs106b.stanford.edu/qt/debugging-helper.html
When debugging a program that uses variables of Stanford collection type (Vector, Map, Queue, ...), it is very helpful to be able to examine the contents of the collection in the debugger. To enable you to view inside a collection, we use a custom debugging helper written by one of our awesome section leaders Jeremy Barenholtz. Thanks, Jeremy! Automatic install within the CS106 package The custom debugging helper is included in our package of CS106 specific components that you previously installed. When installing the CS106 package, it copies the debugging helper into the appropriate place so that Qt Creator will automatically use it. In most cases, this effort is successful, but if it didn't take, we have instructions below on how you can manually configure it. Check if debugger helper is configured To determine if your Qt Creator is configured for the custom debugging helper, run any program under the debugger that uses a variable of a Stanford collection type and look at how the collection is displayed in the debugger variable pane. If the helper is configured, the collection contents will display in a readable, labeled layout. Without the helper, the collection innards are displayed in their raw form. For example, if your program declares myQueue as: Queue<int> myQueue = {10, 15, 7, 3}; Viewing myQueue without the helper configured gives this goopy result: With the helper, you get the prettified display: If you see the pretty layout, your Qt Creator is already configured to use the debugging helper and you do not need to take further action. If you get the raw display, follow the instructions below to manually configure the helper. To manually configure the debugging helper Download this file: stanfordtypes.py and store it somewhere on your computer where you will be able to easily find it later. Open Qt Creator. If you have any projects already open in Qt Creator, close them now. From the top menu, select Qt Creator > Preferences if you're on Mac, or Tools > Options if you're on Windows / Linux. Select Debugger from the list of options on left side and Locals and Expressions from the top tab bar. Find the section labeled Extra Debugging Helpers. In the screenshot below, we use a red rectangle to frame the section you're looking for. Click the Choose button to bring up a file browser. In the file browser, find and select the stanfordtypes.py file that you downloaded in Step 1. Click the Ok button in the bottom-right corner to apply these changes. You should be good to go! If you re-run the check from above (to view a Stanford collection in debugger), you should now see the pretty display. If it didn't seem to take, re-do steps 4 and 5 and be sure you have selected the correct file. If you still can't get it to work, post on Ed or come to Lair so we can help you out.
http://cs106b.stanford.edu/faq
Are you a prospective student looking for information about how the course will be structured in the Fall 2020 virtual quarter? You're in the right place! How will lectures be delivered? Is attendance required? Will they be recorded? Lectures will be delivered live MWF 10am on Zoom. We encourage you to join us live if possible, but recordings will also be posted to Canvas for later asynchronous viewing. Read more about lectures. How will sections work? Is attendance required? Sections will meet weekly on Zoom and your attendance and participation in section is required and contributes 10% of your course grade. Note the section times listed in Axess are not accurate. Section times will be arranged in the first week of the quarter. Read more about section. Will there be exams? We will not have traditional in-class timed exams this quarter and instead will experiment with alternative assessment formats that give students the opportunity to reflect on their understanding of the course material. There will be a mid-quarter diagnostic and a end-quarter personal project. Read more about assessments. I am currently unable to enroll on Axess. How can I shop the course in the meantime? Canvas has recently enabled course shopping and we configured our Canvas site to be "open for shopping"; this allows you to access videos without enrolling. Note that you must be formally enrolled on Axess to submit work for grading. Do you allow auditors? Auditors are welcome to attend lecture, access website materials, and work section and assignments on their own without submitting. We will not be able to grade work from auditors, nor be able to accommodate them in the lab sections, helper hours, or the online forum. How do I choose which of the intro courses is right for me? Most incoming students find the right place by starting in either CS106A or CS106B, or, more rarely, in CS107. Read more about course placement. What is CS100B? This companion course provides extra support to students from under-resourced backgrounds. It is part of the Pathfinders/ACE program jointly sponsored by the CS department and the School of Engineering. Enrollment is by application, read more at https://engineering.stanford.edu/students-academics/equity-and-inclusion-initiatives/undergraduate-programs/additional-calculus. What is CS106L? Although we write programs in C++, CS106B is not a course in the C++ language. The CS106L course is the companion course to add if you want deeper study of the C++ language features and standard libraries. Read more about course placement. Still have unanswered questions? Hop on over to the Ed discussion forum and ask! We're happy to help.
http://cs106b.stanford.edu/getting_help
We provide a variety of support resources in CS106B to help you as much as possible with assignment, material, or other questions throughout the quarter. The main resource for conceptual and debugging help with your assignments will be the LaIR, which is the help center staffed by section leaders. The lecturers and Head TA will hold regular office hours over Zoom. You can ask questions and receive help asynchronously using the Ed discussion forum. To help you make the most of these resources, we've compiled a list of the kinds of common issues or questions that may come up throughout the quarter, and the best way to get help for each. have a conceptual question: We love conceptual questions about any and all of the course material. Conceptual questions are the height of all course queries. It often takes more work to figure out what concept you are confused about, but if you do that extra work, you will learn much more in return. You can bring conceptual questions to any of our course staff in any of our channels: Go to the LaIR, come to office hours, email your Section Leader or post on Ed At the LaIR there is a special sign up for conceptual help called the CLaIR, or "Conceptual LaIR." This is a higher priority queue and you will get a faster response. When getting CLaIR help, section leaders won't look at your code but instead teach you the concepts you need for your homework. Understand concepts before you code! It will make life much more pleasant. have a bug or question about my code: We all get stuck when programming. There are times when the best thing to do is to work through the bug yourself - learning by doing is powerful. However, there are also times when an experienced programmer can help get you on the right track. Course staff will help you learn how to narrow down what may be going wrong in your code and how to approach fixing it. Go to the LaIR or come to office hours Attempting to debug code asynchronously can be frustrating to both you and us, so we discourage use of forum for these issues. However, if it not possible for you to come to LaIR or office hours due to timezone, you may ask for debugging help on Ed. Note that any assignment code posted on Ed must be in a private post. have an administrative question: Post on Ed if it's a question of general nature, or email Chris/Julie/Chase for private matters. Most administrative matters (arrangements for OAE accommodations, extension requests, and the like) should be directed to the Head TA. want to chat about life and programming / I need to restrategize: Anyone on the course staff would appreciate a good conversation about where this crazy world is headed. If you need help to restrategize your learning, advice on research/internships/next steps or just want to talk about life at Stanford. Come to office hours or email Chris/Julie/Chase to arrange a private appointment. We have no expectations for students who come to office hours - it's totally fine to just come with a general sense of confusion or the desire to work and ask us questions whenever you need to.
http://cs106b.stanford.edu/index.html
CS106B Programming Abstractions Fall Quarter 2020 Live lectures on Zoom MWF 10am PT Teaching team Chris Gregg Lecturer T 10am-12pm W 11:30am-1:30pm Julie Zelenski Lecturer M 11am-1pm F 11am-1pm Chase Davis Head TA T 12pm-2pm Th 9:30am-11:30am Nick Bowman Course Coordinator Announcements Free Online CTL Tutoring 3 days ago by Nick Hi everyone, I just wanted to pass along an announcement from the Center for Teaching and Learning regarding help resources that are available to you this quarter: Want to meet with an experienced peer to discuss course concepts, think through a problem set, or prepare for an upcoming exam? CTL offers appointment tutoring for CS 106B, in addition to tutoring for a number of other courses. For more information and to schedule an appointment, visit our tutoring appointments and drop-in schedule page. We also have a variety of remote learning resources and academic coaching available to assist with all of your learning needs! In addition, make sure to check out Julie's Ed post about Black LaIR! Assignment 1 released 1 week ago by Julie Assignment 1 is out! This assignment reinforces C++ fundamentals, control flow, functions decomposition, strings, as well as good testing and debugging practices. Please consider joining Trip at the YEAH (Your Early Assignment Help) session Sunday night 6-7pm Pacific to jump start on your work. (See Zoom info page for link) QT Installation Help Session 1 week and 2 days ago by Chase and Nick The Qt Installation Help Session will be happening tonight from 6-8pm PDT. The point of this help session is to help those of you that have encountered issues in the installation process. To save time, please make sure you have attempted to work through the installation process before coming to the help session. For those of you that want to attend the session, we will be using Queuestatus to manage requests. You can get in line to get help by signing up for the queue after it opens at 6pm. When signing up, please make sure to include a link to a Zoom meeting where we can join you. Week 1 Announcements 1 week and 5 days ago by Chase and Nick We've just posted our first weekly announcements/logistics summary on Ed. If you did not receive an email notification about the announcement, please make sure to sign up for the Ed Discussion Forum, as all important class announcements will be made via Ed for the rest of the quarter! Welcome to CS106B! 1 week and 6 days ago by Chase and Nick Earlier today, we sent out an email announcement to everyone in the class, welcoming them to CS106B. If you did not receive this email but were expecting to, please confirm your enrollment status on Axess. We have replicated a summary of some of the action items of the email announcement here. Read the course syllabus. Check out the CS106B Ed Discussion Forum. You will be able to use this forum to ask questions and have discussions with course staff and your fellow students. Our first class will be on Monday, September 14 from 10-11am Pacific Time (UTC -7). Go to the course Canvas calendar or the Zoom Info page to get a link to the Zoom Webinar being used to host lecture. Keep an eye on the course website (where you are at right now), our central hub for lectures, assignments, and other resources. For some of you this will be the first Computer Science class that you have taken at Stanford. If you are unsure whether this course is the correct one for you to be enrolled in, we have a helpful course placement guide on the website which should help clarify the differences between the introductory CS classes (106A, 106B and 107). During these unprecedented times, we want to make sure that everyone will be able to get the most out of this course while prioritizing your mental health. As a course staff, we hope to support you as much as possible. Please also remember to make use of campus resources such as the Vaden Health Center, which will be providing one-on-one Well Being Coaching sessions to help support students in achieving well-being in these challenging times. Computer science is a tool that allows us to make constructive and powerful contributions to the world, and we hope to help unlock those opportunities for you through this course. Please don't hesitate to reach out to us if you have any questions. We're looking forward to meeting you all in lecture on Monday! See older announcements. Quick Links Getting Help Office Hours LaIR Signup Paperless system Zoom Info ed Discussion Forum Qt Qt Creator Common Build/Run Issues C++ Reference Stanford Library Documentation Guide to Style Guide to Testing Submit Checklist Collaborative Playlist
http://cs106b.stanford.edu/honor_code
Since 1921, academic conduct for students at Stanford has been governed by the Honor Code, which reads as follows: THE STANFORD UNIVERSITY HONOR CODE The Honor Code is an undertaking of the students, individually and collectively: that they will not give or receive aid in examinations; that they will not give or receive unpermitted aid in class work, in the preparation of reports, or in any other work that is to be used by the instructor as the basis of grading; that they will do their share and take an active part in seeing to it that others as well as themselves uphold the spirit and letter of the Honor Code. The faculty on its part manifests its confidence in the honor of its students by refraining from proctoring examinations and from taking unusual and unreasonable precautions to prevent the forms of dishonesty mentioned above. The faculty will also avoid, as far as practicable, academic procedures that create temptations to violate the Honor Code. While the faculty alone has the right and obligation to set academic requirements, the students and faculty will work together to establish optimal conditions for honorable academic work. The purpose of this handout is to make our expectations as clear as possible regarding the Honor Code. The basic principle under which we operate is that each of you is expected to submit your own work in this course. In particular, attempting to take credit for someone else's work by turning it in as your own constitutes plagiarism, which is a serious violation of basic academic standards. Under the Honor Code you are obligated to follow all of the following rules in this course: Rule 1: You must not look at assignment solutions that are not your own. It is an act of plagiarism to take work that is copied or derived from the work of others and submit it as your own. For example, using a solution from the Internet, a solution from another student (past or present), a solution taken from an answer set released in past quarters, or some other source, in part or in whole, that is not your own work is a violation of the Honor Code. Many Honor Code infractions we see make use of past solution sets. The best way to steer clear of this possibility is simply to not search for solutions to the assignments. Moreover, looking at someone else's solution in order to determine how to solve the problem yourself is also an infraction of the Honor Code. In essence, you should not be looking at someone else's answers in order to solve the problems in this class. This is not an appropriate way to "check your work," "get a hint," or "see alternative approaches." Additionally, you must not solicit solutions from anyone. For example, it is a violation of the Stanford Honor Code to ask another student to share their answers with you, to ask a tutor to share other students' solutions with you, or to ask for solutions on sites like Stack Overflow or Chegg. Rule 2: You must not share your solutions with other students. In particular, you should not ask anyone to give you a copy of their answers or, conversely, give your answers to another student who asks you for it. Similarly, you should not discuss your solution strategies to such an extent that you and your collaborators end up turning in the same answers. Moreover, you are expected to take reasonable measures to maintain the privacy of your solutions. For example, you should not leave copies of your work on public computers nor post your solutions on a public website. Rule 3: You must properly cite any assistance you received. If you received aid while producing your solution, you must mention who you got help from (if that person is not a TA or the instructor) and what specifically he/she helped you with. A proper citation should specifically identify the source (e.g., person's name, book title, website URL, etc.) and a clear indication of how this assistance influenced your work. For example, you might write "Student X mentioned the idea of having the base case be Y and the recursive step work in way Z." If you make use of such assistance without giving proper credit - or, if you provide a misleading or inaccurate statement describing the help you received - you may be guilty of plagiarism. It is also important to make sure that the assistance you receive consists of general advice that does not cross the boundary into having someone else write the actual solutions or show you their solutions. It is fine to discuss ideas and strategies, but you should be careful to write your solutions on your own, as indicated in Rules 1 and 2. Rule 4: You may only reuse past work in certain, limited situations. We tend to reuse assignments from quarter to quarter. Following the general principle that the names affixed to a submission should accurately represent its authorship, you may only resubmit work from prior quarters provided that the exact same set of people who initially turned in the assignment resubmit. This means, in particular, that if you completed an assignment individually in a previous quarter, you may only resubmit that assignment if you do so individually; and if you completed an assignment with a partner in a previous quarter, you may only resubmit that assignment if you submit with that exact same partner. To elaborate on that last point, if you worked with a partner in a previous quarter, you are retaking the course or resolving an incomplete, and your partner is not also retaking the class or resolving an incomplete, you may not resubmit the past work you did on that assignment in any circumstance. The policies above apply equally to reading, copying, or adapting solutions you submitted in previous quarters. For example, if you submitted an assignment individually in a previous quarter, you should not refer to your submission on that assignment if you are planning on redoing the assignment in a pair. Similarly, if in a previous quarter you worked with a partner who is not retaking the class, you must not reread or copy anything from that previous submission in the course of redoing the assignment. Note: all submissions are subject to automated plagiarism detection. Stanford employs powerful automated plagiarism detection tools that compare assignment submissions with other submissions from current and previous quarters. The tools also compare submissions against a wide variety of online solutions. These tools are effective at detecting unusual resemblances in programs, which are then further examined by the course staff. The staff then make the determination as to whether submissions are deemed to be potential infractions of the Honor Code and referred to Stanford's Community Standards office.
http://cs106b.stanford.edu/lectures/04-vector-grid/
Use this space for a brief description of lecture Readings Text 5.1, Vector, Grid Links Slides Lecture Q&A Video on canvas Code ToonShade.zip VectorsGrids.zip
http://cs106b.stanford.edu/section/section1/
This week's section exercises explore the very fundamentals of programming in C++. We'll be exploring the material from Week 1 (functions, parameters, return, decomposition, strings and basic data structures). Have fun! Each week, we will also be releasing a Qt Creator project containing starter code and testing infrastructure for that week's section problems. When a problem name is followed by the name of a .cpp file, that means you can practice writing the code for that problem in the named file of the Qt Creator project. Here is the zip of the section starter code: Starter code 1) Returning and Printing Topics: Function call and return, return types Below is a series of four printLyrics_v# functions, each of which has a blank where the return type should be. For each function, determine what the return type of the function should be, what value, if any, is returned, and what output, if any, will be produced if that function is called. Is it appropriate for each of these functions to be named printLyrics? Why or why not? _____ printLyrics_v1() { cout << "Havana ooh na na" << endl; } _____ printLyrics_v2() { return "Havana ooh na na"; } _____ printLyrics_v3() { return "H"; } _____ printLyrics_v4() { return 'H'; } Solution void printLyrics_v1() { cout << "Havana ooh na na" << endl; } string printLyrics_v2() { return "Havana ooh na na"; } string printLyrics_v3() { return "H"; } char printLyrics_v4() { return 'H'; } Of these four functions, only printLyrics_v1 will print anything. Specifically, it prints out the string "Havana ooh na na.". The name "printLyrics" is inappropriate for the other functions, as those functions don't actually print anything. The function printLyrics_v1 doesn't return anything - it just sends information to the console. As a result, its return type should be void. The functions printLyrics_v2 and printLyrics_v3 each return strings, since C++ treats anything in double-quotes as a string. Finally, printLyrics_v4 returns a char, since C++ treats anything in single-quotes as a character. 2) References Available Upon Request Topic: Reference parameters, range-based for loops Reference parameters are an important part of C++ programming, but can take some getting used to if you're not familiar with them. Trace through the following code. What does it print? void printVector(const Vector<int>& values) { for (int elem: values) { cout << elem << " "; } cout << endl; } void maui(Vector<int> values) { for (int i = 0; i < values.size(); i++) { values[i] = 1258 * values[i] * (values[2] - values[0]); } } void moana(Vector<int>& values) { for (int elem: values) { elem *= 137; } } void heihei(Vector<int>& values) { for (int& elem: values) { elem++; } } Vector<int> teFiti(const Vector<int>& values) { Vector<int> result; for (int elem: values) { result += (elem * 137); } return result; } int main() { Vector<int> values = { 1, 3, 7 }; maui(values); printVector(values); moana(values); printVector(values); heihei(values); printVector(values); teFiti(values); printVector(values); return 0; } Solution Here's the output from the program: 1 3 7 1 3 7 2 4 8 2 4 8 Here's a breakdown of where this comes from: The maui function takes its argument by value, so it's making changes to a copy of the original vector, not the vector itself. That means that the values are unchanged back in main. The moana function uses a range-based for loop to access the elements of the vector. This makes a copy of each element of the vector, so the changes made in the loop only change the temporary copy and not the elements of the vector. That makes that the values are unchanged back in main. heihei, on the other hand, uses int& as its type for the range-based for loop, so in a sense it's really iterating over the elements of the underlying vector. Therefore, its changes stick. The teFiti function creates and returns a new vector with a bunch of updated values, but the return value isn't captured back in main. 3) SumNumbers (sum.cpp) Topics: Vectors, strings, file reading The function sumNumbers reads a text file and sums the numbers found within the text. Here are some library functions that will be useful for this task: readEntireFile, to read all lines from a file stream into a Vector stringSplit, to divide a string into tokens isdigit, to determine whether char is a digit stringToInteger, to convert a string of digits to integer value In particular you will be asked to write the following function int sumNumbers(string filename) When given the following file, named numbers.txt, as input, your function should return 42. 42 is the Answer to the Ultimate Question of Life, the Universe, and Everything This is a negative number: -9 Welcome to CS106B! I want to own 9 cats. Solution bool isNumber(string s) { // strip negative sign off negative numbers if (s.length() > 0 && s[0] == '-'){ s = s.substr(1); } for (char ch : s) if (!isdigit(ch)) return false; return s.length() > 0; } int sumNumbers(string filepath) { ifstream in; Vector<string> lines; int sum = 0; if (!openFile(in, filepath)) return 0; readEntireFile(in, lines); for (string line : lines) { Vector<string> tokens = stringSplit(line, " "); for (string t : tokens) { if (isNumber(t)) { sum += stringToInteger(t); } } } return sum; } 4) Debugging Deduplicating (deduplicate.cpp) Topics: Vector, strings, debugging Consider the following incorrect C++ function, which accepts as input a Vector<string> and tries to modify it by removing adjacent duplicate elements: void deduplicate(Vector<string> vec) { for (int i = 0; i < vec.size(); i++) { if (vec[i] == vec[i + 1]) { vec.remove(i); } } } The intent behind this function is that we could do something like this: Vector<string> hiddenFigures = { "Katherine Johnson", "Katherine Johnson", "Katherine Johnson", "Mary Jackson", "Dorothy Vaughan", "Dorothy Vaughan" }; deduplicate(hiddenFigures); // hiddenFigures = ["Katherine Johnson", "Mary Jackson", "Dorothy Vaughan"] The problem is that the above implementation of deduplicate does not work correctly. In particular, it contains three bugs. Find those bugs, explain what the problems are, then fix those errors. Solution There are three errors here: Calling .remove() on the Vector while iterating over it doesn't work particularly nicely. Specifically, if you remove the element at index i and then increment i in the for loop, you'll skip over the element that shifted into the position you were previously in. There's an off-by-one error here: when i = vec.size() - 1, the indexing vec[i + 1] reads off the end of the Vector. The Vector is passed in by value, not by reference, so none of the changes made to it will persist to the caller. Here's a corrected version of the code: void deduplicate(Vector<string>& vec) { for (int i = 0; i < vec.size() - 1; ) { if (vec[i] == vec[i + 1]) { vec.remove(i); } else { i++; } } } [Credit to Andrew Tierno for the alternate solution] Alternatively, you can also re-write the function to use a loop that traverses the vector from right-to-left, which is a common pattern when working with deleting items from linear collections. A solution that does so could look like this: void deduplicate(Vector<string>& vec) { for (int i = vec.size() - 1; i > 0; i--) { if (vec[i] == vec[i - 1]) { vec.remove(i); } } } 5) Pig-Latin (pigLatin.cpp) Topics: Strings, reference parameters, return types Write two functions, pigLatinReturn and pigLatinReference, that accept a string and convert said string into its pig-Latin form. To convert a string into pig-Latin, you must follow these steps: Split the input string into 2 strings: a string of characters BEFORE the first vowel, and a string of characters AFTER (and including) the first vowel. Append the first string (letters before the first vowel) to the second string. Append the string "ay" to the resulting string. Here are a few examples... nick -> icknay chase -> asechay chris -> ischray You will need to write this routine in two ways: once as a function that returns the pig-Latin string to the caller, and once as a function that modifies the supplied parameter string and uses it to store the resulting pig-Latin string. These will be done in pigLatinReturn and pigLatinReference, respectively. You may assume that your input is always a one-word, all lowercase string with at least one vowel. Here's a code example of how these functions differ... string name = "julie"; string str1 = pigLatinReturn(name); cout << str1 << endl; // prints "uliejay" pigLatinReference(name); cout << name << endl; // prints "uliejay" Once you've written these functions, discuss with your section the benefits and drawbacks of these two approaches. Which do you feel is easier to write? Which do you think is more convenient for the caller? Do you think one is better style than the other? Solution // Use const because VOWELS won't change -- no need to declare repeatedly // in isVowel. const string VOWELS = "aeiouy"; // Helper function, which I'd highly recommend writing! bool isVowel(char ch){ // A little kludgy, but the handout guarantees that // ch will ALWAYS be lower case :) // NOTE: For an assignment, you probably want a more robust isVowel. return VOWELS.find(ch) != string::npos; } string pigLatinReturn(string input){ int strOneIndex = 0; for (int i = 0; i < input.length(); i++){ if (isVowel(input[i])){ strOneIndex = i; break; } } string strOne = input.substr(0, strOneIndex); string strTwo = input.substr(strOneIndex); return strTwo + strOne + "ay"; } void pigLatinReference(string &input){ int strOneIndex = 0; for (int i = 0; i < input.length(); i++){ if (isVowel(input[i])){ strOneIndex = i; break; } } string strOne = input.substr(0, strOneIndex); string strTwo = input.substr(strOneIndex); input = strTwo + strOne + "ay"; } Notice how similar these two approaches are - the only difference is how the result is handled at the very end. To address the discussion questions, although the pigLatinReference function is marginally more efficient because it doesn't need to make a copy of the input string, pigLatinReturn is probably more intuitive for both the caller and the writer: if the function's job is to somehow output some product, returning is the most explicit way to do so. In that way, a function that returns is also better style - it's makes the purpose of the function clearer to the reader. If you wanted to combine the efficiency of pigLatinReference with the clarity of pigLatinReturn, I would recommend writing a function that takes in the input string by const reference, basically string pigLatin(const string &input); Although the const isn't explicitly necessary, it's nice to have because you never need to modify input. Moreover, you still get the efficiency gains from pass-by-reference while also writing very-understandable code. 6) Mirror (mirror.cpp) Topic: Grids Write a function that accepts a reference to a of integers as a parameter and flips the grid along its diagonal. You may assume the grid is square; in other words, that it has the same number of rows as columns. For example, the grid below that comes first would be altered to give it the new grid state shown afterwards: Original state: { { 6, 1, 9, 4}, {-2, 5, 8, 12}, {14, 39, -6, 18}, {21, 55, 73, -3} } Mirrored state: { {6, -2, 14, 21}, {1, 5, 39, 55}, {9, 8, -6, 73}, {4, 12, 18, -3} } Bonus: How would you solve this problem if the grid were not square? Solution // solution void mirror(Grid<int>& grid) { for (int r = 0;r < grid.numRows(); r++) { // start at r+1 rather than 0 to avoid double-swapping for (int c = r + 1; c < grid.numCols(); c++) { int temp = grid[r][c]; grid[r][c] = grid[c][r]; grid[c][r] = temp; } } } // bonus void mirror(Grid<int>& grid) { Grid<int> result(grid.numCols(), grid.numRows()); for (int r = 0; r < grid.numRows(); r++) { for (int c = 0; c < grid.numCols(); c++) { result[r][c] = grid[c][r]; } } grid = result; } 7) Check Balance (balance.cpp) Topic: Stacks Write a function named checkBalance that accepts a string of source code and uses a Stack to check whether the braces/parentheses are balanced. Every ( or { must be closed by a } or ) in the opposite order. Return the index at which an imbalance occurs, or -1 if the string is balanced. If any ( or { are never closed, return the string's length. Here are some example calls: // index 0123456789012345678901234567 checkBalance("if (a(4) > 9) { foo(a(2)); }") // returns -1 (balanced) // index 01234567890123456789012345678901 checkBalance("for (i=0;i<a;(3};i++) { foo{); )") // returns 15 because } is out of order // index 0123456789012345678901234 checkBalance("while (true) foo(); }{ ()") // returns 20 because } doesn't match any { // index 01234567 checkBalance("if (x) {") // returns 8 because { is never closed Solution int checkBalance(string code) { Stack<char> parens; for (int i = 0; i < (int) code.length(); i++) { char c = code[i]; if (c == '(' || c == '{') { parens.push(c); } else if (c == ')' || c == '}') { if (parens.isEmpty()) { return i; } char top = parens.pop(); if ((top == '(' && c != ')') || (top == '{' && c != '}')) { return i; } } } if (parens.isEmpty()) { return -1; // balanced } else { return code.length(); } } 8) Collection Mystery Topics: Stacks and Queues void collectionMystery(Stack<int>& s) { Queue<int> q; Stack<int> s2; while (!s.isEmpty()) { if (s.peek() % 2 == 0) { q.enqueue(s.pop()); } else { s2.push(s.pop()); } } while (!q.isEmpty()) { s.push(q.dequeue()); } while(!s2.isEmpty()) { s.push(s2.pop()); } cout<< s << endl; } Write the output produced by the above function when passed each of the following stacks. Note that stacks and queues are written in to back order, with the oldest element on the left side of the queue/stack. Stacks: {1, 2, 3, 4, 5, 6} ________________________________________ {42, 3, 12, 15, 9, 71, 88} ________________________________________ {65, 30, 10, 20, 45, 55, 6, 1} ________________________________________ Solution {6, 4, 2, 1, 3, 5} {88, 12, 42, 3, 15, 9, 7} {6, 20, 10, 30, 65, 45, 55, 1} 9) Friend List (friendlist.cpp) Topic: Maps Write a function named friendList that takes in a file name and reads friend relationships from a file and writes them to a Map. friendList should return the populated Map. Friendships are bi-directional, so if Abby is friends with Barney, Barney is friends with Abby. The file contains one friend relationship per line, with names separated by a single space. You do not have to worry about malformed entries. If an input file named buddies.txt looked like this: Barney Abby Abby Clyde Then the call of friendList("buddies.txt") should return a resulting map that looks like this: {"Abby":{"Barney", "Clyde"}, "Barney":{"Abby"}, "Clyde":{"Abby"}} Here is the function prototype you should implement: Map<string, Vector<string> > friendList(String filename) Solution Map<string, Vector<string> > friendList(string filename) { ifstream in; Vector<string> lines; if (openFile(in, filepath)) { readEntireFile(in, lines); } Map<string, Vector<string> > friends; for (string line: lines) { Vector<string> people = stringSplit(line, " "); string s1 = people[0]; string s2 = people[1]; friends[s1] += s2; friends[s2] += s1; } return friends; } 10) Twice (twice.cpp) Topic: Sets Write a function named twice that takes a vector of integers and returns a set containing all the numbers in the vector that appear exactly twice. Example: passing {1, 3, 1, 4, 3, 7, -2, 0, 7, -2, -2, 1} returns {3, 7}. Bonus: do the same thing, but you are not allowed to declare any kind of data structure other than sets. Solution // solution Set<int> twice(Vector<int>& v) { Map<int, int> counts; for (int i : v) { counts[i]++; } Set<int> twice; for (int i : counts) { if (counts[i] == 2) { twice += i; } } return twice; } // bonus Set<int> twice(Vector<int>& v) { Set<int> once; Set<int> twice; Set<int> more; for (int i : v) { if (once.contains(i)) { once.remove(i); twice.add(i); } else if (twice.contains(i)) { twice.remove(i); more.add(i); } else if (!more.contains(i)) { once.add(i); } } return twice; }
http://cs106b.stanford.edu/lectures/05-stack-queue/
Use this space for a brief description of lecture Readings Text 5.2, 5.3, Stack, Queue Links Slides Lecture Q&A Video on canvas Code stacks-and-queues.zip
http://cs106b.stanford.edu/assignments/2-adt/
Due Friday, October 2 at 11:59 pm Pacific Submissions received by due date receive a small on-time bonus. All students are granted a pre-approved extension or "grace period" of 48 hours after the due date. Late submissions are accepted during the grace period with no penalty. The grace period expires Sun, Oct 4 at 11:59 pm Pacific, after which we cannot accept further late submissions. In this course, we express all date/times in Pacific time GMT -7. Our Paperless submission system also displays/records due dates and submission times in Pacific time. This week's lectures have introduced you to the many different Abstract Data Types (ADTs) that exist in the world, and now it's time to put those handy collections to use! With the low-level details of how these data structures work abstracted away, your attention is free to solve more interesting problems. This assignment asks you to write client code that leverages many different ADTs to implement some nifty algorithms and systems. The tasks may sound a little daunting at first, but given the powerful tools in your arsenal, each requires a very manageable amount of code. Let's hear it for abstraction! This assignment is to be completed individually. Working in pairs/groups is not permitted. Learning goals To more fully experience the joy of using pre-written classes. Most of the heavy-lifting is handled by the collection ADTs. To stress the notion of abstraction as a mechanism for managing data and providing functionality without revealing the representational details. To learn how to model and solve problems using classic data structures such as vectors, grids, stacks, queues, sets, and maps. Assignment parts This assignment consists of a short warmup/debugging exercise and two coding tasks, each featuring use of different ADTs. We strongly encourage that you complete the warmup first and only then go on to the coding tasks. Warmup Practice with testing and debugging on different abstract data types. Maze A Grid of walls and corridors is used to represent a maze, and the Stack, Queue, and Set ADTs are used in the implementation of a famous algorithm that can efficiently find a solution path to escape the maze. Search Engine A Map is used to associate words with a Set of documents containing that word. Using the map, you can find matching entries that contain terms from simple or compound queries, which emulates the behavior of a search engine. The two coding tasks are roughly comparable to each other in size and scope, so pace yourself to complete each in about three days. Note: The code you will write for Assignment 2 is considerably more complex than Assignment 1, so be sure to get an early start! Getting started We provide a ZIP of the starter project. Download the zip, extract the files, and open the .pro file in Qt Creator. Starter code The two source files you will edit are maze.cpp and search.cpp. Additionally, you will answer the questions in short_answer.txt. Resources The CS106B Guide to Testing The CS106B Style Guide Resolving Common Build/Run Errors, compiled by section leader Jillian Tang. Stanford library documentation for Vector, Grid, Stack, Map, Set Lectures: Vector and Grid (Mon), Stack and Queue (Wed), Friday Set and Map (Fri) Section: [ADTs][section2] Getting Help As always, feel free to reach out to us for support. You can contact us on Ed, email your section leader, or stop by the virtual LaIR, or come to office hours. As a reminder, try to visit the LaIR for coding debugging questions if you cannot make it to the LaIR due to timezone issues, you can post on Ed to get help. However, you must use a private post if you are including code so that you are not posting your solutions for the whole class to see. Submit Before you call it done, run through our submit checklist to be sure all your t's are crossed and i's dotted. Then upload your completed files to Paperless for grading. Please submit only the files you edited; for this assignment, these files will be: maze.cpp search.cpp short_answer.txt You don't need to submit any of the other files in the project folder. Submit to Paperless Note: On Paperless, all due dates and submission times are expressed in Pacific time.
http://cs106b.stanford.edu/assignments/1-cpp/
Due Friday, September 25 at 11:59 pm Pacific Submissions received by due date receive a small on-time bonus. All students are granted a pre-approved extension or "grace period" of 48 hours after the due date. Late submissions are accepted during the grace period with no penalty. The grace period expires Sun, Sep 27 at 11:59 pm Pacific, after which we cannot accept further late submissions. In this course, we express all date/times in Pacific time GMT -7. Our Paperless submission system also displays/records due dates and submission times in Pacific time. Here it is - the first programming assignment of the quarter! Completing this assignment will get you up and running with the C++ language and the tools used in CS106B. The work involves a mix of coding, testing, and debugging tasks. By the end of this assignment, you'll have fully gotten your C++ legs under you! (our apologies for the bad pun...) The code you will write involves expressions, control structures, functions, and string processing. You have prior experience with these concepts, but the tricky part is figuring how to map what you already know to the strange new world of C++. The transition is what this assignment is all about. In addition to giving you practice with C++ syntax and libraries, the assignment will guide you through the tools and approaches you can use to test and debug your code. By the time you've completed it, you'll be a lot more comfortable working in C++ and will be ready to start building larger projects! This assignment is to be completed individually. Working in pairs/groups is not permitted. Assignment parts This assignment consists of two parts. Perfect Numbers is a fun warmup exercise involving number theory, algorithms, and optimization. It gives you a guided transition into C++, as well as the testing and debugging tools that we will be using in CS106B this quarter. You can start on this task right away we recommend doing so! Completing this warmup in the first few days reserves the better part of the week for the bigger second part. Soundex Search is a complete program that demonstrates a nifty algorithm for matching and grouping names based on their pronunciation. This program uses C++ strings, console I/O, and the Vector class. Make sure that you have watched the lectures on strings and Vectors before starting on this part. There is a substantial chunk of code for you to write, so get an early start to give yourself sufficient time to work through issues and reach out for help (using the Ed forum, LaIR, and instructor office hours) if you hit any snags. Getting started We provide a ZIP of the starter project. Download the zip, extract the files, and open the project in Qt creator. Starter code The two source files you will edit are: perfect.cpp soundex.cpp Additionally, you will write short answers to some questions in short_answer.txt. Resources The Assignment 1 Your Early Assignment Help (YEAH) Session will be held on Sunday, September 20 at 6pm PDT. Zoom information can be found on the Zoom Information page. This session is a great opportunity to get an overview of the assignment before getting started working on it! Trip's Assignment 1 YEAH slides The CS106B Style Guide reviews the coding standards in the rubric applied to grading the style of your submission. The CS106B guide to testing your code explains the use of SimpleTest. This guide to transitioning from Python to C++ points out syntactical and functional differences between the two languages. Thank you to section leaders Jillian Tang and Ethan Chi for this wonderful resource! Getting Help As always, feel free to reach out to us if you have questions. You can contact us on Ed, email your section leader, or stop by the virtual LaIR, or come to office hours. As a reminder, try to visit the LaIR for coding debugging questions if you cannot make it to the LaIR due to timezone issues, you can post on Ed to get help. However, you must use a private post if you are including code so that you are not posting your solutions for the whole class to see. Submit Before you call it done, run through our submit checklist to be sure all your t's are crossed and i's dotted. Then upload your completed files to Paperless for grading. Please submit only the files you edited; for this assignment, these files will be: perfect.cpp soundex.cpp short_answer.txt You don't need to submit any of the other files in the project folder. Submit to Paperless Note: On Paperless, all due dates and submission times are expressed in Pacific time. That's it; you're done! Congratulations on finishing your first CS106B assignment!
http://cs106b.stanford.edu/lectures/02-cpp/
A brief introduction to C++ Readings Text Ch. 1, 2.1-2.4 Links Slides Lecture Q&A Video on canvas Code intro-cpp-lecture.zip
http://cs106b.stanford.edu/lectures/03-strings/
Use this space for a brief description of lecture Readings Text Ch. 3, strlib.h Links Slides Lecture Q&A Video on canvas Code strings.zip
http://cs106b.stanford.edu/assignments/2-adt/easter_egg/
Here is a hidden file on the course website, buried deep among the many other pages containing important course information. For your entertainment, it also contains an easter egg, which can only be found by using the "Search" feature in the top left corner of the website... Your quote for today: Have a GREAT day! Presenting... Bad Trombone Guy Your browser does not support the audio element. Latest release from indie band College Avenue Lockdown (mixed by sons Rein & Kalev, husband Matt on trombone, Rein on drum kit, vocals by Julie) A classic XKCD comic that we can all relate to:
http://cs106b.stanford.edu/lectures/01-welcome/
Introduction to CS106B Readings Readings: Syllabus Links Slides Lecture Q&A Video on canvas Code WelcomeCode.zip
http://cs106b.stanford.edu/lectures/06-set-map/
Use this space for a brief description of lecture Readings Text 5.4, 5.5, 5.6, Set, Map Links Slides [Lecture Q&A] [Video on canvas] Code CountUniqueWords.zip SetsAndMaps.zip TallyWords.zip
http://cs106b.stanford.edu/assignments/0-namehash/
Due Friday, September 18 at 11:59 pm Pacific There is no grace period for this assignment. The deadline is firm and no late submissions can be accepted. In this course, we express all date/times in Pacific time GMT -7. Our Paperless submission system also displays/records due dates and submission times in Pacific time. Welcome to CS106B! This assignment is designed to help you get your development environment set up and running so that you can compile, run, and debug programs. There isn't any actual programming involved, and we hope that this doesn't take you too much time to complete. Remember, you don't need to understand what the code you're being asked to run is actually doing just yet. Over the course of the quarter, each of the different parts of this program will be illuminated! This assignment must be completed individually. Step 1) Install Qt Creator Your first task is to configure your computer for Qt Creator, the development environment that we'll be using in CS106B this quarter. Follow the instructions in the Qt Installation Guide for your operating system. If you run into trouble installing Qt Creator, don't panic! The course staff will be holding a Qt Creator help session virtually on Zoom from 6:00PM - 8:00PM PDT on Thursday, September 17. If you run into issues, you can also post on Ed and we can help you out there. Step 2) Download starter project We will configure a starter project with the files needed for each assignment and post it in the form of a ZIP archive. Download the archive and unzip. Starter code Step 3) Hash your name Open the project in Qt Creator and build and run the program. It will ask you to enter your (preferred) first and last names. When you do, it will give back a hash code, a special number associated with your name. You can think of your hash code as a "fingerprint" associated with your name that's unlikely to be the same as anyone else's fingerprint. Write this number down; you'll need it to complete the assignment! Step 4) Use the debugger Open the debugger tutorial. This wonderful guide written by Keith Schwarz walks you through using the debugger on the Name Hash program. Follow along with the step-by-step instructions. At some point, you'll be asked to remember a number. Write this number down; you'll need it to complete the assignment! Step 5) Read about the Honor Code You are required to read our handout CS106B and the Honor Code before submitting assignments. Do this now before proceeding to the final step. Step 6) Submit Once you've finished everything, fill out the form at the following URL: Submit Google form: https://forms.gle/dLG9CBYDEr1g4t1S6 This form will ask for the numbers from Steps 3 and 4, along with some questions about who you are, why you're awesome, and what your learning environment will look like this quarter. And that's it! You're done!
http://cs106b.stanford.edu/qt/
Students in the CS106B/courses use Qt Creator to write C++ programs. Qt Creator is an integrated development environment (IDE) with tools to edit, build, run, and debug programs. Installing Qt Creator Qt Creator is installed on the campus cluster computers. Students may also choose to install Qt Creator on their own computers. We have prepared installation guides for each operating system, choose the one for your computer. Please follow the instructions carefully and do not skip steps. Install Qt Creator on Windows Install Qt Creator on Mac OS X Install Qt Creator on Linux The final step of the installation is to build and run a sample project. If you have successfully done this, your installation is good to go! If you run into problems, check our troubleshooting guide. Re-installing: If you already have Qt Creator on your computer, ensure it is up-to-date. To confirm what version you have, look in the Qt Creator menu for "About Qt Creator". For Fall Quarter 2020 the version number must be at least Qt Creator 4.13.0 Based on Qt 5.15.0 The version number of your Qt Creator must be equal or newer (greater) than the above version. If the version you have installed is older, delete your existing Qt folder and make a fresh install by following the steps above. If the Qt you already have is sufficiently up-to-date, you only need to install the CS106 specific components. Creating a new Qt project Our sample project is a blank/empty project can be used as a template for creating a new project with the proper CS106 settings. Using Qt Creator Here are some guides on using the tools. Using Qt Creator Configuring the Qt debugging helper Recommended Qt Creator settings Troubleshooting common Qt Creator project problems Common build/run/debug issues Debugger tutorial from Assignment 0 The QT guides have been written and maintained by legions of wonderful CS106B staff members.
http://cs106b.stanford.edu/qt/install-cs106.html
Install CS106 specific components After installing Qt, you must install the CS106-specific components and do a complete build and run cycle to confirm all is working properly. Download CS106 project and extract Download this archive file: CS106.zip Un-zip the download contents (on a Windows computer, click "Extract all") to a location of your choice. You should have a folder named CS106 with several files and folders inside. Open and configure CS106 project A Qt Creator project includes a file named with a .pro extension. Double-clicking the .pro file opens the project in Qt Creator. Find the CS106.pro file and open it now. When opening a project for the first time, Qt Creator brings up a "Configure Project" panel for you to select the appropriate build kit (see screenshot below). The default kit should already be selected; it will match the component you selected when installing Qt Creator. Accept the default by clicking the "Configure Project" button. If no kits are shown as available, review the Qt install instructions. You can repeat the steps to re-install if you missed selecting the required components. Build the program C++ code must be compiled or built before it is run; this means converting the source code into executable binary code. Click the Build icon in the lower-left of the Qt Creator window. Watch the build progress meter in the lower-right. The first time you build a project, it can take a minute or more to compile the library code. When the bar turns green, it indicates the program successfully built. Run the program Now that the program is built, you are ready to run it. Click the Play/Run icon in lower-left of window. As shown in the screenshot below, the welcome program prints a message to the console window and draws the Stanford logo on graphics window. Congratulations, your installation is good to go! You may now discard the CS106 project, you will not need it again.
http://cs106b.stanford.edu/qt/install-linux.html
Below are basic instructions for installing on Linux that may work for your system, however, we are unable to provide further Linux support. If you are unable to get Qt Creator working on your Linux system, please consider using another computer or working on a campus cluster computer. 1) Install prerequisites If you're running Ubuntu, Debian, Mint, or any other Debian derivative, you can install the needed components using the apt package manager. Issue the following commands below in your shell. The first command ensures your package manager is up-to-date: sudo apt-get update && sudo apt-get upgrade This command installs the tools and libraries needed for Qt (be sure to copy/paste the entire line, it is long!) sudo apt-get -y install build-essential openssl libssl-dev libssl1.0 libgl1-mesa-dev libqt5x11extras5 If you're running some other variant of Linux, figure out a way to install the tools make, g++, and gdb. (For example, on Fedora / Red Hat systems, you may be able to use the yum package manager.) 2) Download installer The Qt Creator official download site is https://www.qt.io/download-qt-installer. When you go to this site, it should detect that your computer is running Linux and recommend the installer "Qt Online Installer for Linux". Click the green "Download" button to download the installer. 3) Run installer The downloaded installer is named something like qt-unified-linux-x64-version-online.run and is likely located in your ~/Downloads directory. Use chmod +x qt*.run to make the file executable, then run it by typing ./qt*.run. The graphical installer launches and walks you through a set of steps. For most steps, you can use the default settings and simply click "Next" or "Agree" to move on, with the following exceptions: At the Qt Account step, you will have to create your own Qt Account. At the Select Components step: Select the highest-numbered Qt version. For Fall Quarter 2020, the version number must be at least Qt 5.15.0.Do not select any version labeled "Preview" or "Alpha" or "Beta". IMPORTANT: You must also select the Desktop gcc kit component. Expand the "Qt" triangle, then expand the triangle with Qt version number, then click the checkbox labeled "Desktop gcc". See the screenshot below. (The screenshot has part of the version number scribbled out since the versions change so frequently; it is just shown as a general example of what the UI will look like.) 3) Install CS106 specific components After installing Qt, you must install the CS106-specific components and do a complete build and run cycle to confirm all is working properly. Download CS106 project and extract Download this archive file: CS106.zip Un-zip the download contents (on a Windows computer, click "Extract all") to a location of your choice. You should have a folder named CS106 with several files and folders inside. Open and configure CS106 project A Qt Creator project includes a file named with a .pro extension. Double-clicking the .pro file opens the project in Qt Creator. Find the CS106.pro file and open it now. When opening a project for the first time, Qt Creator brings up a "Configure Project" panel for you to select the appropriate build kit (see screenshot below). The default kit should already be selected; it will match the component you selected when installing Qt Creator. Accept the default by clicking the "Configure Project" button. If no kits are shown as available, review the Qt install instructions. You can repeat the steps to re-install if you missed selecting the required components. Build the program C++ code must be compiled or built before it is run; this means converting the source code into executable binary code. Click the Build icon in the lower-left of the Qt Creator window. Watch the build progress meter in the lower-right. The first time you build a project, it can take a minute or more to compile the library code. When the bar turns green, it indicates the program successfully built. Run the program Now that the program is built, you are ready to run it. Click the Play/Run icon in lower-left of window. As shown in the screenshot below, the welcome program prints a message to the console window and draws the Stanford logo on graphics window. Congratulations, your installation is good to go! You may now discard the CS106 project, you will not need it again. 5) Configure settings (optional) For a better experience, we suggest changing some of the default settings, see our recommended configuration settings.
http://cs106b.stanford.edu/qt/install-mac.html
1) Prerequisites Before installation, ensure your macOS operating system is current. Select menu -> "System Preferences" -> "Software Update" and check whether any OS updates are available. If so, install them first and only then proceed with the rest of this installation guide. In order to install QtCreator, you need to have a version of MacOS that is >= 10.13. If this is not possible for you, please reach out to the course staff ASAP. 2) Install Xcode tools Apple's developer tools are bundled as a part of Xcode. Installing Xcode provides the C++ compiler that is used by Qt Creator. To choose the correct Xcode installation, you need to know your macOS version. Select menu -> "About This Mac" and read the macOS version number. If your macoS version is Catalina >= 10.15, you can install the latest Xcode directly from the App Store by following these steps: Select menu - > "App Store..." and search for Xcode. Download and install the app. If your macOS version is 10.14 or older, you need to install an older Xcode. Older versions of Xcode are available at Apple Developer Downloads by following these steps Visit https://developer.apple.com/downloads/ and sign in with your Apple ID. Search for Xcode and select the version that is compatible with your macOS version: For macOS 10.14, use Xcode version 11.3 For macOS 10.13, use Xcode version 10.1 Do not chose any version labeled "beta" or "preview" If the Apple developer site disallows you from accessing downloads, create a new Apple ID and try again. (This can happen if your Apple ID was created when your age was too young for some features?) Download the appropriate version, open the archive, launch the Xcode installer, and follow through the installer steps. After the installer finishes, drag the XCode application into your Applications folder. Xcode is a very large app, so the download and installation will take some time, and can be anywhere from 1-4 hours depending on your network connection speed. If your computer does not have enough space for Xcode, or if the download will take prohibitively long (more than 24 hours) due to the quality of your internet connection, reach out to the Head TA for alternate installation instructions. 3) Run Xcode once After downloading Xcode, you have to launch the Xcode application one time to install its components. You can open Xcode using Spotlight (the magnifying glass at the top right of your screen) and typing in "Xcode". Click "Agree" to accept the License Agreement and enter your password if prompted. Watch the progress bar "Installing components...". When it finishes, quit Xcode. You will not need to launch Xcode again for this course. 4) Download the Qt Creator installer The Qt Creator official download site is https://www.qt.io/download-qt-installer. When you go to this site, it should detect that your computer is running MacOS and recommend the installer "Qt Online Installer for Mac OS". Click the green "Download" button to download the installer. 5) Run the Qt Creator installer The downloaded installer is named something like qt-unified-mac-version.dmg. Double-click to mount the disk image and launch the installer. The graphical installer launches and walks you through a set of steps. For most steps, you can use the default settings and simply click "Next" or "Agree" to move on, with the following exceptions: At the Qt Account step, you will have to create your own Qt Account. At the Select Components step: Select the highest-numbered Qt version. For Fall Quarter 2020, the version number must be at least Qt 5.15.0. Do not select any version labeled "Preview" or "Alpha" or "Beta". IMPORTANT: You must also select the macOS kit component. Expand the "Qt" triangle, then expand the triangle with Qt version number, then click the checkbox labeled "macOS". You can un-check every other checkbox except for "macOS", as shown in the screenshot below. 6) Install CS106 specific components After installing Qt, you must install the CS106-specific components and do a complete build and run cycle to confirm all is working properly. Download CS106 project and extract Download this archive file: CS106.zip Un-zip the download contents (on a Windows computer, click "Extract all") to a location of your choice. You should have a folder named CS106 with several files and folders inside. Open and configure CS106 project A Qt Creator project includes a file named with a .pro extension. Double-clicking the .pro file opens the project in Qt Creator. Find the CS106.pro file and open it now. When opening a project for the first time, Qt Creator brings up a "Configure Project" panel for you to select the appropriate build kit (see screenshot below). The default kit should already be selected; it will match the component you selected when installing Qt Creator. Accept the default by clicking the "Configure Project" button. If no kits are shown as available, review the Qt install instructions. You can repeat the steps to re-install if you missed selecting the required components. Build the program C++ code must be compiled or built before it is run; this means converting the source code into executable binary code. Click the Build icon in the lower-left of the Qt Creator window. Watch the build progress meter in the lower-right. The first time you build a project, it can take a minute or more to compile the library code. When the bar turns green, it indicates the program successfully built. Run the program Now that the program is built, you are ready to run it. Click the Play/Run icon in lower-left of window. As shown in the screenshot below, the welcome program prints a message to the console window and draws the Stanford logo on graphics window. Congratulations, your installation is good to go! You may now discard the CS106 project, you will not need it again. 7) Configure settings (optional) For a better experience, we suggest changing some of the default settings, see our recommended configuration settings.
http://cs106b.stanford.edu/qt/install-windows.html
1) Download installer The Qt Creator official download site is https://www.qt.io/download-qt-installer. When you go to this site, it should detect that your computer is running Windows and recommend the installer "Qt Online Installer for Windows". Click the green "Download" button to download the installer. 2) Run installer The downloaded installer is named something like qt-unified-windows-version.exe. Double-click to run it. The installer walks you through a set of steps. For most steps, you can use the default settings and simply click "Next" or "Agree" to move on, with the following exceptions: At the Qt Account step, you will have to create your own Qt Account. At the Select Components step: Select the highest-numbered Qt version. For Fall Quarter 2020, the version number must be at least Qt 5.15.0. Do not select any version labeled "Preview" or "Alpha" or "Beta". IMPORTANT: You must also select the MinGW 32-bit kit component. Expand the "Qt" triangle, then expand the triangle with Qt version number, then click the checkbox labeled "MinGW 8.x.x 32 bit". You can un-check every other checkbox except for "MinGW 32 bit", as shown in the screenshot below. This screenshot shows selecting the Mingw 32 component. Note that we scribbled out the version numbers to avoid confusion since the versions change frequently. 3) Install CS106 specific components After installing Qt, you must install the CS106-specific components and do a complete build and run cycle to confirm all is working properly. Download CS106 project and extract Download this archive file: CS106.zip Un-zip the download contents (on a Windows computer, click "Extract all") to a location of your choice. You should have a folder named CS106 with several files and folders inside. Open and configure CS106 project A Qt Creator project includes a file named with a .pro extension. Double-clicking the .pro file opens the project in Qt Creator. Find the CS106.pro file and open it now. If your File Explorer options are set to hide filename extensions, the file CS106.pro will display the name CS106. You can change whether extensions are displayed in File Explorer by choosing menu item File->Options, select the "View" tab and under "Advanced settings", uncheck "Hide extensions for known file types". Click "Apply" button. When opening a project for the first time, Qt Creator brings up a "Configure Project" panel for you to select the appropriate build kit (see screenshot below). The default kit should already be selected; it will match the component you selected when installing Qt Creator. Accept the default by clicking the "Configure Project" button. If no kits are shown as available, review the Qt install instructions. You can repeat the steps to re-install if you missed selecting the required components. Build the program C++ code must be compiled or built before it is run; this means converting the source code into executable binary code. Click the Build icon in the lower-left of the Qt Creator window. Watch the build progress meter in the lower-right. The first time you build a project, it can take a minute or more to compile the library code. When the bar turns green, it indicates the program successfully built. Run the program Now that the program is built, you are ready to run it. Click the Play/Run icon in lower-left of window. As shown in the screenshot below, the welcome program prints a message to the console window and draws the Stanford logo on graphics window. Congratulations, your installation is good to go! You may now discard the CS106 project, you will not need it again. 4) Configure settings (optional) For a better experience, we suggest changing some of the default settings, see our recommended configuration settings.
http://cs106b.stanford.edu/lair
What are LaIR helper hours? LaIR helper hours are an additional set of office hours staffed by our awesome fleet of section leaders. At the LaIR, students can get individual help with debugging and conceptual questions. Logistics The LaIR help queue is open Sundays-Wednesdays from 5pm to 9pm this quarter. To sign up help, add your request to the queue using the Paperless Remote Student Portal. When a section leader takes your request, they will set up a new Zoom meeting and invite you or will join the Zoom url that you gave when signing up for the queue. We ask that you please be aware of where you are in the queue and are attentive to Zoom when it is your turn to be helped. Our system will send you an email once you are close to the front of the queue. If a section leader is unable to reach you via Zoom, they will send an email to try to resolve and move to the next person in the queue. If you become active soon afterwards and the section leader is able to get in contact with you, they will come back and service your request after finishing their current one. Requests will be limited to 15 minutes in order to get to everyone in the queue. The most important thing we want to ask of you all to help this run smoothly is to get Zoom set up and working before signing up in the queue, and making sure to be attentive to meeting invites after you have signed up for help. With all of your help, we can get you the help you need! Weekly schedule Day Time Sunday 5-9pm Pacific Monday 5-9pm Pacific Tuesday 9-11am (only if you are unable to make evening LaIR), 5-9pm Pacific Wednesday 5-9pm Pacific Thursday 9-11am (only if you are unable to make evening LaIR), 5-9pm Pacific Common questions about Lair My Zoom isn't working. Can I still get help? Yes! Still signup as usual. If you know when you signup that your Zoom isn't working, leave a note in the request so that the section leader knows to email you once it's your turn to troubleshoot. If your Zoom stops working after you've signed up, you can respond to the email the section leader sends to let them know you need to get help using a different platform (like Google Meet). My microphone isn't working! What should I do? The Zoom invitation includes a phone number that you can call from a phone. You can use your phone as the microphone and audio source for your call rather than your computer's built-in microphone if necessary. What should I do if my internet is slow or lagging? Consider temporarily turning off your video stream and only maintaining the audio stream. Turning off the video should improve communication quality and consistency. If your connection is still not working well enough to share your screen, you can email your code to the section leader helping you. Emailing a zip file is sometimes blocked for security reasons, so better to email a specific code file. The section leader can then discuss the code you sent using Zoom audio or a phone call. I'm having issues with installing the software necessary for the class. What should I do? If you're having issues with installing or setting up the software required for the class, the section leader will try to help you figure it out. However, sometimes it is helpful for the SL to be able to debug the issue using your computer. Therefore, they may ask you to enable Zoom's remote control access tool. First, you should select "Share Screen" and pick the window you would like to share (note that the SL will be able to control whatever you decide to share, so we recommend sharing your entire desktop with them if you are comfortable with this). The SL will then request to control your screen (there should be a pop up asking for your permission). You may have to enable settings in your computer's preferences in order to activate this option. Once enabled, the section leader will be able to control your computer as though they are sitting at it. This is very useful for troubleshooting software issues; however, if you are uncomfortable with this, let the section leader know, and they can try to give you verbal instructions for how to troubleshoot your IDE issues. I tried to sign up for the LaIR helper queue, but the queue was closed, even though now is within the open hours for the LaIR. In times of peak demand, the helpers may need to close the queue to new requests before the end of the open hours. We do this to ensure that we have sufficient resources to assist all students in the queue before the end of the shift.
http://cs106b.stanford.edu/late
Hofstadter's Law: "It always takes longer than you think, even when you take Hofstadter's Law into account." The assignment deadline policy this quarter has been designed to provide all students with built-in flexibility, given that the circumstances of online learning may sometimes be unpredictable. Here will be the general policy: Assignments deadlines will fall at the end of the day in the Pacific time zone, i.e. 11:59pm GMT-7. Submitting by the deadline earns a small "on-time" bonus. The bonus points for timeliness will be added to the course grade at the end of the quarter. There is a penalty-free 48-hour "grace period" for late submission . The grace period allows you to submit the assignment after the deadline, with no impact on your grade. The grace period is intended to give you built-in accommodation for unexpected snags. If you plan your work to submit by the deadline, you have the grace period in reserve to give you cover if something unexpected derails your schedule. Late submissions are not accepted after the grace period expires, unless there have been arrangements made for an exceptional situation as described below. The grace period is effectively an automatic extension that has been approved in advance. Given that, additional extensions beyond the grace period are generally not granted. In exceptional circumstances (primarily extended medical problems, emergencies, or previously established OAE accommodations), the grace period may be extended for individual students on a case-by-case basis. An extension request must be received no later than 24 hours before the deadline. Only the lecturers or Head TA are able to approve extensions. In particular, do not ask your section leader.
http://cs106b.stanford.edu/qt/library_beta.html
The not-so-distant past How do we currently do this? All source/headers/resources for Stanford library are distributed as part of every project Each project is self-contained unit with no external dependencies Build performance Significant first build penalty (1-4 minutes). Affects all projects/platforms Reasonable subsequent builds on Mac/linux (< 10 seconds). Abysmal link time on Windows (20-60 seconds, every single build1). Compiler nerds, hit me up me to hear the sordid backstory of mingw linker. Launch debugger is sluggish (5-20 seconds, particularly awful on Windows) Space use Each project size is > 5MB Build folder size > 50 MB Total quarter of assign/section/lecture can run to 1-2 GB Versionitis Each project has own copy of library. Can patch bugs per-project, but leads to wild west of version control In sum So much redundancy, do we not always tell our students DRY? On Mac/linux, performance is perhaps tolerable, but Windows is painful and on low-end machine becomes completely unacceptable. It is time to take action! The bright shiny future Distribute CS106 project with source/headers/resources for Stanford library After install Qt, student downloads CS106 project and builds once which installs static lib and headers into standard location CS106 project incorporates sample project so can replace that step from our install instructions (no extra step required) Projects contain only student source code, no library Depends on headers/static lib installed in step 1 What you can look forward to One and only one copy of the Stanford library. Full library build takes 1-5 minutes, done once and never repeated. First and every build of student project on all platforms < 10 seconds Link on all platforms < 5 seconds Debugger launch < 10 seconds Project size < 100K, build folders ~4MB, total quarter 100 MB No versionitis can patch with per-project overrides if needed create new project is trivial Can piggyback course customizations onto the install step debugging helper views for Stanford collections (yay Jeremey Barenholtz!) To me, it is particularly motivating that the biggest beneficiaries of this work are students who own low-end machines. Let's hear it for super-charging the workflow of these long-suffering folks! How to test Before changing anything: download new-style projec . Open in Qt Creator. The new-style project should load fine, show files, etc, but will error on build because CS106 library is not installed. Try to build and confirm you get error message. Close that project. You can try it again after installing the CS106 library. You will need latest Qt installed (version 5.15.0). If your system has older Qt: first, try to install the CS106 library on your older Qt and confirm that it blocks you then install latest Qt to replace your older Qt, then install CS106 library To install CS106 library: Download the CS106 project zip. Unzip, open the top-level CS106.pro in Qt Creator. Build & Run. Build. Will take 1-4 minutes. This is the last time you'll wait that long for any build ever again. Run. The welcome program runs to confirm your install is all good. You can now discard the entire CS106 project, you're done with it. Download a new-style CS106 project and build/run to enjoy an improved experience. Here are example new-style projects for assign, section, and lecture. Empty Sample Assignment 0 Name Hash Section 1 Fractals lecture You can create a new-style project of your own. Make a new folder, copy the .pro file from any of the above example projects, add your source files to the folder and you're good to go. A new-style project does not contain any of the Stanford library code or resources. What to test Build: rework was focused on build process so that's primary need for testing : edit source, rebuild/run, make sure correct update, build clean, rebuild, etc. If you observe build step that takes > 15 seconds, report it to me try build in both debug and release configurations for client project (fyi library always installs in release mode) plant various compile/link errors to confirm reported correctly do project "reinitialize" (delete .pro.user and build folder) and re-open to confirm project resets correctly run under debugger, view variables, set breakpoints, read stack traces, confirm symbols from student code correctly identified. (Note that symbols/code within library will generally be opaque) try out debugging helpers, confirm internals of a Stack variable show labels for "top" and "bottom" element or [row, col] of Grid element. Library code: installed code is mostly same as previous, but good to test also: Confirm that runtime behavior of program built new-style is same as program built old-style One notable code change was to remove the harvesting of the stack trace on error (code was fragile and often misleading) and instead redirect student to use debugger, so you'll see slightly different behavior on error/exception/segfault. Try that and see what you think! Follow up with Julie Hit a snag or observe a glitch, even seemingly minor one? If you see something, say something. Send it on over to me to investigate further and add to our knowledge base. If goes smoothly, a thumbs-up in Slack to help us track would be appreciated. Thank you for your help! Shameful evidence of failure to listen My feeling of guilt about this is profound. Reparations are due to everyone who has soldiered through this pain on Windows. Every time you see me for the next 4 years, insist that I treat you to coffee/boba/jamba.
http://cs106b.stanford.edu/assignments/2-adt/maze.html
A maze is a twisty and convoluted arrangement of corridors that challenge the solver to find a path from the entry to the exit. This assignment is about using ADTs to represent, process, and solve mazes. An introduction to mazes Labyrinths and mazes have fascinated humans since ancient times (remember Theseus and the Minotaur?), but mazes can be more than just recreation. The mathematician Leonhard Euler was one of the first to analyze plane mazes mathematically, and in doing so, he founded the branch of mathematics known as topology. Many algorithms that operate on mazes are closely related to graph theory and have applications that include diverse tasks such as designing circuit boards, routing network traffic, motion planning, and social networking. In this part of the assignment, you'll be writing function to verify and generate maze solution paths. We will focus on a particular type of maze known as a perfect maze. A perfect, or simply-connected, maze has no loops and no inaccessible areas. Any two locations within a perfect maze are connected by exactly one path. The image below shows a perfect maze and the path from the entry at upper left to exit at lower right: This introduction section explains how we will represent mazes, the ADTs we will use, and the structure of the maze data files we have provided. Please carefully read this section before you jump into coding. A Grid represents a maze A maze can be modeled as a two-dimensional array where each element is either a wall or a corridor. The Grid class from the Stanford library is a good tool for representing a maze. A maze is represented as a Grid<bool>. We use a value of true to represent an open corridor and false for a wall. Accessing grid[row][col] will evaluate to true if there is a open corridor at location row,col and false if it is a wall. A maze is read from a text file. Each line of the file corresponds to one row of the maze. Within a row, the character @ is used for walls and - for corridors. Here is a sample 5x7 maze file: ------- -@@@@@- -----@- -@@@-@- -@---@- Our starter code provides the readMazeFile function that reads a text file in the above format into a Grid<bool>. In the project "Other files/res" folder are a number of provided maze files. If you wish to create your own maze file, you can right-click and duplicate an existing maze file inside Qt Creator. A GridLocation is a row/col pair While working with the maze grids, you will find it handy to use the GridLocation struct. A GridLocation has two fields, row and col, that are packaged together into one aggregate type. The sample code below demonstrates using a GridLocation variable and assigning and accessing its row and col fields. // Declare a new GridLocation GridLocation chosen; // default initialized to 0,0 chosen.row = 3; // assign row of chosen chosen.col = 4; // assign col of chosen // Initialize row,col of exit as part of its declaration GridLocation exit = { maze.numRows()-1, maze.numCols()-1 }; // last row, last col // You can use a GridLocation to index into a Grid (maze is a Grid) if (maze[chosen]) // chosen was set to {3, 4} so this accesses maze[3][4] ... // You can directly compare two GridLocations if (chosen == exit) ... // You can also access a GridLocation's row,col separately if (chosen.row == 0 && chosen.col == 0) ... A Stack of GridLocation is a path A sequence of connecting GridLocations represents a path through the maze. You will use a Stack<GridLocation> to store a path. To extend the path, you simply push an additional GridLocation onto the stack. Peeking at the top of the stack accesses the end of the path. A solution path for the maze starts at the maze entrance (bottom of stack), travels through connecting GridLocations, and ends at the maze exit (top of stack). Alongside the maze text files in the "Other files/res" folder, there are .soln text files that contain maze solutions. For example, this is the solution file corresponding to the 5x7 maze shown previously. (Note that the entries in a stack are displayed in order from bottom to top) {r0c0, r0c1, r0c2, r0c3, r0c4, r0c5, r0c6, r1c6, r2c6, r3c6, r4c6} Our starter code provides the readSolutionFile function that reads a text file in the format above into a Stack<GridLocation>. Not every maze will have a corresponding .soln file, and part of your job will be writing code to generate solutions! ADT resources Lectures: Grid/GridLocation, Stack/Queue Documentation for Stanford collections: Grid, Stack, Queue Section 6.1 of the textbook introduces struct types In the lower-left corner of your Qt Creator window, there is a magnifying glass by a search field. If you type the name of a header file such as grid.h or gridlocation.h , Qt will display the corresponding header file Notes on Stanford collection types The assignment operator works as expected for all our ADTs. Assigning from one Stack/Vector/Set/etc to another will create a copy of the ADT with a copy of the elements. Be on your toes about making sure that your template types are always properly specialized and that all types match. Using Vector without specifying the element type just won't fly, and a Vector<int> is not the same thing as a Vector<double>. The error messages you receive when you have mismatches can be cryptic and hard to interpret. Bring your template woes to the Ed forum, and we can help untangle them with you. Onto the code! Your work is structured in three tasks: two functions that verify the correctness of a solution path and a final de to generate a solution path. You will also be writing comprehensive test cases for your functions. All of the functions and tests for mazes are to be implemented in the file maze.cpp. 1) Write generateValidMoves() For your first task, you'll implement the following helper function: Set<GridLocation> generateValidMoves(Grid<bool>& maze, GridLocation cur) Given a maze represented as a Grid of bool and a current cell represented by the GridLocation cur, this function returns all valid moves from cur as a Set. Valid moves are defined as follows: Either directly north, south, east, or west (N, S, E, W) of cur Only one "step" away from cur in the grid Is open corridor, not a wall Not out-of-bounds of the provided maze There are a few provided tests for generateValidMoves, but these tests are not fully comprehensive. You should write at least 3-4 additional tests to make sure your helper function works. Remember to label your tests as STUDENT_TEST. 2) Implement checkSolution() to verify a path Next you'll write a function to confirm that a solution is valid for a particular maze: void checkSolution(Grid<bool>& maze, Stack<GridLocation> path) The path represents a valid solution through maze if it meets the following criteria: The path must start at the entry (upper left corner) of the maze The path must end at the exit (lower right corner) of the maze Each location in the path is a valid move away from the previous location call the helper function you already wrote to help confirm a move is valid, rather than re-implement its logic! The path contains no loops, i.e. a location appears at most once in the path If checkSolution detects any of the above problems, it should call the error function from error.h to report an error. This function is used to report a fatal error. When you call error, it halts the program right there and reports the message you passed as an argument: error("Here is my message about what has gone wrong"); If all of the criteria for a valid solution are met, then checkSolution completes normally. This function has a lot of things to check and will need rigorous tests to confirm all of its functionality. We've provided some initial tests to get you started, but you will need to write tests of your own. You should write at least 3-4 additional tests of the checkSolution function. After writing checkSolution you will not only be familiar with using the ADTs to represent mazes, but you will also have a function that makes testing the next milestone much easier. Having thoroughly testing your checkSolution on a variety of invalid paths means you can be confident that it is the oracle of truth when it comes to validating a solution. Your future self will thank you. Note the use of the special kinds of test cases EXPECT_ERROR and EXPECT_NO_ERROR in our provided tests. An EXPECT_ERROR test case evaluates an expression, expecting that the operation will raise an error. While the test is executing, SimpleTest framework will catch the error, record that it happened, and resume. Because the error was expected, the test case is considered to be passed. If an error was expected but didn't materialize, the test case fails. This is the opposite of an EXPECT_NO_ERROR test case, which does not expect errors and treats a raised error as a test failure. More information on the different test macros and how they all work can be found in the CS106B Testing Guide. Q6. So far in this class, we've passed our data structures by reference. Why do you think checkSolution passes path by value instead of by reference? Q7. After you have written your tests, describe your testing strategy to determine that your checkSolution works as intended. 3) Find solutions with solveMaze() Now you're reading to tackling finding an escape route from a maze. You are to implement the following function, which uses breadth-first search (BFS) to find a valid solution path through a given maze: Stack<GridLocation> solveMaze(Grid<bool>& maze) There are a wide variety of algorithms for solving a maze. Solving a maze can be seen as a specific instance of a shortest path problem, where the challenge is to find the shortest route from the entrance to the exit. Shortest path problems come up in a variety of situations such as packet routing, robot motion planning, analyzing gene mutations, spell correction, and more. In the case of the perfect maze, the shortest path is also the only path, but the general process is the same regardless. Breadth-first search (BFS) is a classic and elegant algorithm for finding a shortest path. A breadth-first search reaches outward from the entry location in a radial fashion until it finds the exit. The first paths examined take one hop from the entry. If any of these reach the exit location, you're done. If not, the search expands to those paths that are two hops long. At each subsequent step, the search expands radially, examining all paths of length three, then of length four, etc., stopping at the first path that reaches the exit. Breadth-first search is typically implemented using a queue. The queue stores partial paths that represent possibilities to explore. The paths are processed in order of increasing length. The first paths enqueued are all length one, followed by the length two paths, and so on. Given the FIFO handling of the queue, all shorter paths are dequeued before the longer paths make their way to the front of queue, ready for their turn to be processed. At each step, the algorithm considers the current path at the front of the queue. If the current path ends at the exit, it is a complete solution. If not, the algorithm takes the current path and extends it to reach locations that are one hop further away in the maze, and enqueue those extended paths to be examined later. Since a path is represented as a Stack of GridLocations, putting these paths into a queue for processing means you'll have a nested ADT, a Queue<Stack<GridLocation>>. A nested container type looks a little scary at first, but it is just the right tool for this job. Here are steps followed by a breadth-first search: Create a queue of paths. A path is a stack of grid locations. Create a length-one path containing just the entry location. Enqueue that path. In our mazes, the entry is always the upper-left corner and exit in the lower-right. While there are still more paths to explore: Dequeue path from queue. If this path ends at exit, this path is the solution! If path does not end at exit: For each viable neighbor from path end, make copy of path, extend by adding neighbor and enqueue it. A viable neighbor is a location that is a valid move and that has not yet been visited. A couple of notes to keep in mind as you're implementing BFS: You should avoid repeatedly revisiting the same location in the maze or creating a path with a cycle, lest the search get stuck in a infinite loop. For example, if the current path leads from location r0c0 to r1c0, you should not extend the path by moving back to location r0c0. You shouldn't use checkSolution within your solveMaze implementation, but you should use it to write tests that confirm the validity of paths found by solveMaze. A strategy that will help with both visualizing and debugging solveMaze it to add calls to our provided graphics functions, explained below. We have provided some existing tests that put your solveMaze functions to the test. You should take advantage of the extra maze files we've provided you and add 2-3 more tests that verify the correct functionality of the solveMaze function. Add graphics functions to draw the maze The Stanford C++ library has extensive functionality for drawing and interacting with the user, but we generally don't ask you to dig into those features. Instead, we will supply any needed graphics routines pre-written in a simple, easy-to-use form. For this program, the provided mazegraphics.cpp module has functions to display a maze and highlight a path through the maze. Read the mazegraphics.h header file in the starter project for details of these functions: MazeGraphics::drawGrid(Grid<bool>& grid) MazeGraphics::highlightPath(Stack<GridLocation> path, string color) Note that when calling these functions, you must call them using their full name (including the weird looking MazeGraphics:: prefix). We will talk more about what this notation means a little later in the quarter! You call MazeGraphics::drawGrid once to display the maze and repeatedly call MazeGraphics::highlightPath to mark the cells along the path currently being explored. By watching this display, the user can see how the path is updated and follow along with the algorithm as it searches for a solution. Now just sit back and watch the show as your clever algorithm finds the path to escape any maze you throw at it! Congratulations! References There are many interesting facets to mazes and much fascinating mathematics underlying them. Mazes will come up again several times this quarter. Chapter 9 of the textbook uses a recursive depth-first search as path-finding algorithm. At the end of the quarter when we talk about graphs, we'll explore the equivalence between mazes and graphs and note how many of the interesting results in mazes are actually based on work done in terms of graph theory. Walter Pullen, Maze Classification. http://www.astrolog.org/labyrnth/algrithm.htm Website with lots of great info on mazes and maze algorithms Jamis Buck. Maze Algorithms. https://www.jamisbuck.org/mazes/ Fun animations of maze algorithms. He also wrote the excellent book about Mazes for Programmers: Code Your Own Twisty Little Passages. Extensions Instead of reading pre-written mazes from a file, you could instead generate a new random maze on demand. There is an amazing (I could not resist...) variety of algorithms for maze construction, ranging from the simple to the sublime. Here are a few names to get you started: backtracking, depth-first, growing tree, sidewinder, along with algorithms named for their inventor: Aldous-Broder, Eller, Prim, Kruskal, Wilson, and many others. Try out other maze solving algorithms. How does BFS stack up against the options in terms of solving power or runtime efficiency? Take a look at random mouse, wall following, depth-first search (either manually using a Stack or using recursion once you get the hang of it), Bellman-Ford, or others. There are many other neat maze-based games out there that make fun extensions. You might gather ideas from Robert Abbott's http://www.logicmazes.com or design a maze game board after inspiration from Chris Smith on mazes.
http://cs106b.stanford.edu/office_hours
Overview Chris, Julie, and Chase will be holding weekly office hours throughout the quarter for you to discuss any questions you might have about assignments, course material or simply Computer Science and life in general. Like all class sessions, these office hours will be held remotely over Zoom. Links to the zoom meetings will be posted on the Zoom Information page. All office hours this quarter will be held in group setting and are open for all students to join, with no prior sign-up necessary. Students are welcome to bring their questions or pop in to listen to questions of others. We will provide high-level assignment help and conceptual guidance using a format of group discussion for benefit of all participants. To participate in these office hours, simply join the Zoom meeting during the scheduled window. The LaIR helper hours are an additional set of office hours staffed by our sturdy fleet of section leaders. At the LaIR, students can get individual help with debugging and conceptual questions. Calendar
http://cs106b.stanford.edu/assignments/1-cpp/perfect.html
This assignment warmup focuses on giving you practice with C++ expressions, control structures, and functions, as well as testing and debugging your code. As you work through the exercise, we pose thought questions (in the highlighted yellow boxes) for you to answer. The starter project includes the file short_answer.txt (located under "Other Files" in the Qt Project pane) where you will fill in your answers. When answering these questions, we are more interested in seeing your reasoning and thought process than we are the "correct" answer. In fact, some of the questions may not even have a "correct" answer! Perfect Numbers The first part of this exercise will be an exploration of a certain class of numbers called perfect numbers. So before we get started on the coding, we have a little bit of math and a little bit of history to go over! A perfect number is an integer that is equal to the sum of its proper divisors. A number's proper divisors are all positive numbers that evenly divide it, excluding itself. The first perfect number is 6 because its proper divisors are 1, 2, and 3, and 1 + 2 + 3 = 6. The next perfect number is 28, which equals the sum of its proper divisors: 1 + 2 + 4 + 7 + 14. Perfect numbers are an interesting case study at the intersection of mathematics, number theory, and history. This class of numbers has intrigued mathematicians going back thousands of years and demonstrates human fascination with the abstract beauty of learning. If you are interested in learning more about perfect numbers, you can check out this extensive history. The following exercises will walk you through different algorithms for calculating these beloved numbers! An Exhaustive Algorithm One way to find perfect numbers is by using an "exhaustive" algorithm. In this general class of algorithms, you try all possible options ("exhausting" all options) in order to find the desired solution or information that you're looking for. For the specific task of finding perfect numbers, this means checking every integer starting from 1 and counting upwards and checking to see if each one along the way is a perfect number. Testing to see whether or not a number is perfect involves looping over all possible divisors that the number might have, verifying when you've found a divisor, and keeping track of the sum of these valid divisors. If, at the end of the process, the sum and the original number are equal, then you've found a perfect number! These two components combined together define the exhaustive algorithm for finding perfect numbers. Here is some Python code that performs an exhaustive search for perfect numbers: def divisor_sum(n): total = 0 for divisor in range(1, n): if n % divisor == 0: total += divisor return total def is_perfect(n): return n != 0 and n == divisor_sum(n) def find_perfects(stop): for num in range(1, stop): if is_perfect(num): print("Found perfect number: ", num) if num % 10000 == 0: print('.', end='',flush=True) # progress bar print("Done searching up to ", stop) The same code is now expressed below in C++. If your CS106A was taught in Python, comparing and contrasting these two may be a helpful way to start adapting to the language differences. If instead your prior course/experience was with Java/Javascript, just sit back and enjoy how C++ already seems familiar to what you know! /* This function takes one argument `n` and calculates the sum * of all proper divisors of `n` excluding itself. To find divisors * a loop iterates over all numbers from 1 to n-1, testing for a * zero remainder from the division. * * Note: long is a C++ type is a variant of int that allows for a * larger range of values. For all intents and purposes, you can * treat it like you would an int. */ long divisorSum(long n) { long total = 0; for (long divisor = 1; divisor < n; divisor++) { if (n % divisor == 0) { total += divisor; } } return total; } /* This function takes one argument `n` and returns a boolean * (true/false) value indicating whether or not `n` is perfect. * A perfect number is a non-zero positive number whose sum * of its proper divisors is equal to itself. */ bool isPerfect(long n) { return (n != 0) && (n == divisorSum(n)); } /* This function does an exhaustive search for perfect numbers. * It takes one argument `stop` and searches the range 1 to `stop`, * checking each number to see whether it is perfect and if so, * printing it to the console. */ void findPerfects(long stop) { for (long num = 1; num < stop; num++) { if (isPerfect(num)) { cout << "Found perfect number: " << num << endl; } if (num % 10000 == 0) cout << "." << flush; // progress bar } cout << endl << "Done searching up to " << stop << endl; } Observing runtime The starter project contains the above C++ code already written for you. Your first task is run the given code and make some observations about how long the search takes to run. Important note: If at any point the program takes more than 5 minutes to run to completion, you can just stop the program and report the runtime as "> 5 mins." Open the project in Qt Creator, find the file main.cpp file under "Sources and double-click to view its contents. Ignore the cryptic if statement at the beginning of the main function for now - what you should see is a single uncommented call to findPerfects, which is what will get executed when you run the main function. Build and run the program unchanged. Observe the output of the program. Q1. How many numbers does the program search through? How many perfect numbers does it find? What are these perfect numbers? Now, let's take a deeper dive into one of the core components of CS106B, which is analyzing the behavior of algorithms. What we would like to do is run the search several times with different search sizes (20000, 40000, 80000, etc.) and observe how long the program takes to run for each search size. While you could do this by manually editing the argument to the findPerfects call in main.cpp and re-running the program, repeating this process for many different sizes becomes tedious. It would be more convenient if we could run several time trials in sequence and get the timing results of all in one go. In order to do this, we'll have to take a brief detour to talk about the SimpleTest library. Using SimpleTest In CS106B, you will use a unit-test framework called SimpleTest to test your code. Stop here and read our guide to testing to introduce yourself to using this framework. In particular, pay attention to the STUDENT_TEST, EXPECT, EXPECT_EQUAL, and TIME_OPERATION components. SimpleTest is somewhat akin to the "doctest" features you may have used in Python for CS106A. If you're not familiar with doctests, don't sweat testing guide above has everything you need to know about how testing your code will work in CS106B. It is mentioned in the testing guide but is worth repeating here: all tests that we have provided in the starter code are labeled using the PROVIDED_TEST identifier. When you add tests of your own, make sure to label them using the STUDENT_TEST identifier, so that your grader can easily identify which tests you've added. Running time trials Open the perfect.cpp file and scroll to the bottom. Review the provided test cases, with a special focus on the first one, which makes several calls to TIME_OPERATION. This is the secret sauce that will allow us to accomplish our goal from earlier: timing the operation of findPerfects on different input sizes. Follow these steps to run the provided test cases: Edit the main function in main.cpp to change the argument passed to runSimpleTests from NO_TESTS to SELECTED_TESTS. For the rest of this exercise, you will not need to modify any of the code in main.cpp. Re-build and run the program. When prompted to "Enter your selection," type only the number 3 (this choices selects the tests for the perfect.cpp file) and hit enter to run the perfect.cpp tests. A SimpleTest popup window opens in addition to the console window. The results of the tests will appear in both. The given code should pass all the tests, so this demonstrates what a successful sweep through all the tests looks like. In particular, pay attention to the output of the first test, both in the graphical popup window and in the console window. You should see the output of multiple runs of the findPerfects function, as well as the amount of time each function call took. Q2. Record the timing results for findPerfects into a table. To do so, you will need to experiment with uncommenting out some of the lines in the provided test in perfect.cpp. Experiment with larger and larger search sizes until the total runtime exceeds 5 minutes. At that point, feel free to just skip any larger remaining sizes and indicate that the runtime was too long to measure. Use the data to get a rough idea of the relationship between the argument search size and the amount of time required. It may help to plot these values on a graph, if you have the capability to do so. What you should notice among the time values in your table is that doubling the size of the search doesn't just cause the time required to also double; it goes up by a factor of 4. Rather than a linear relationship, we've got a quadratic relationship between the search size and the program execution time! Let's investigate why this might be. Q3. Does it take the same amount of effort to compute isPerfect on the number 10 as it does on the number 1000? Why or why not? Does it take the same amount of work for findPerfects to search the range of numbers from 1-1000 as it does to search the numbers from 1000-2000? Why or why not? One of the downsides of the exhaustive algorithm as written is that its performance starts to get really bad, really quickly! In particular, the first four perfect numbers are found pretty quickly (6, 28, 496, 8128), but that fifth one is quite a ways off - in the neighborhood of 33 million. Working up to that number by exhaustive search is going to take l-o-o-ng time. Q4. Extrapolate from the data you gathered and make a prediction: how long will it take findPerfects to reach the fifth perfect number? This is your first exposure to algorithmic analysis, a topic we will explore in much greater detail throughout the course, starting next week! As a fun aside, if you have access to a Python environment, you can attempt similarly-sized searches using the Python version of the program to see just how much slower an interpreted language (Python) is compared to a compiled language (C++). Check out the Python vs C++ Showdown we've posted to the Ed discussion forum. Digging deeper into testing Having completed these observations about performance, we move on to testing the code, which is one of the most important skills that we hope you will come out of this class with. Designing good tests and writing solid, well-tested code are skills that will serve you well for the rest of your computer science journey! Complete the following exercises, which will help you start to develop your testing chops by exploring and writing tests on some of the functions that we've provided for you: Since all perfect numbers must be positive, there should be no such thing as a negative perfect number; thus isPerfect should return false for any negative numbers. Will you need to make a special case for this or does the code already handle it? Let's investigate... Look at the code and make a prediction about what happens is isPerfect is given a negative input. Add a new STUDENT_TEST case that calls isPerfect on a few different negative inputs. The expected result of isPerfect for such inputs should be false. Run these test cases to confirm that the code behaves as expected. Now that you have added your own tests, selecting the perfect.cpp tests from the main menu is now numbered choice 4. Introduce a bug into divisorSum (e.g. erroneously initialize total to 1 instead of 0). Rebuild and run the tests again. This should let you see how test failures are reported. Q5. Do any of the tests still pass even with this broken function? Why or why not? Be sure to undo the bug and restore divisorSum to a correct state. Add another STUDENT_TEST of your own but deliberately make the test case expect something erroneous (e.g. isPerfect(5) returns true). Run this test case. What happens? Q6. Can the test framework detect that the test case is "bogus", in the sense that the premise of the test case itself is off-base? (Refer to our testing guide for a longer explanation of bogus tests) This example serves as a reminder to take care in constructing your test cases! The pass/fail result of a bogus test an be misleading or inverted. Be sure to remove that bogus test so it won't further confuse you. On this assignment, and all future ones, your goal is a clean green record for all tests. Streamlining and more testing As you observed earlier, it is chore for an exhaustive search to reach the fifth perfect number. However, there is a neat little optimization you can apply that can significantly streamline the job. The function divisorSum runs a loop from 1 to N to find divisors, but in fact, this is quite wasteful. We truly only need to examine divisors up to the square root of N. Along the way, we can work out what the corresponding pairwise factor for a given divisor is without having to explicitly loop all the way up to the other factor. In other words, we can take advantage of the fact that each divisor that is less than the square root is paired up with a divisor that is greater than the square root. Take a moment to carefully think about why this is true and how you would rearrange the code to capitalize on this observation. Now, implement the following function prototype that has been provided in the starter code. long smarterSum(long n) You may find it helpful to use the provided divisorSum implementation as a starting point (that is, you may choose to copy-paste the existing code and make tweaks to it). Be careful: there are some subtle edge cases that you may have to handle in the adapted version that were not an issue in the original. The C++ library function sqrt can be used to compute a square root. After adding new code to your program, your next step is to thoroughly test that code and confirm it is bug-free. Only then should you move on to the next task. Let's write some tests for the smarterSum function. Because you already have the vetted function divisorSum at your disposal, a neat testing strategy here is to use EXPECT_EQUAL to confirm that the result from divisorSum(n) is equal to the result from smarterSum(n). Rather than pick a random value for n, brainstorm about why certain values might be good candidates. As an example, try picking a number like n=25 (which has an square root that is an integer value) to ensure there is no off-by-one issue on the stopping condition of your new loop. You must add at least 3 new student tests of your own (again, remember to label them as STUDENT_TEST) for smarterSum. Q7. Describe the testing strategy your used for your test cases to confirm smarterSum is working correctly. Once you have confirmed that smarterSum operates equivalently to divisorSum, implement the following two functions, which should take advantage of your new smarterSum function: bool isPerfectSmarter(long n) void findPerfectsSmarter(long stop) The code for these two functions is very similar to the provided isPerfect and findPerfects functions, just using your new, streamlined divisor summation algorithm. Again, you may copy-paste the existing implementations, and make small tweaks as necessary. Now let's run time trials to see just how much better our new algorithm is! Important note: As before, if at any point your program takes more than 5 minutes to run to completion, you can just stop the program and report the runtime as "> 5 mins." Add a STUDENT_TEST that uses TIME_OPERATION to measure findPerfectsSmarter on a sequence of increasing sizes. Q8. Record your timing results for findPerfectsSmarter into a table. (You may have to use larger sizes than before to get results that are measurable, because this version is so much faster.) Q9. Make a prediction: how long will findPerfectsSmarter take to reach the fifth perfect number? Our previous algorithm grew at the rate N^2, while this new version is since we only have to inspect divisors for every number along the way. If you plot runtimes on the same graph as before, you will see that they grow much less steeply than the runtimes from our previous experiment. Mersenne Primes and Euclid Back to story time for a little bit: last year, there was a rare finding of a new Mersenne prime. A prime number is one whose only divisors are 1 and the number itself. A Mersenne prime is a prime number that is one less than a power of two. In other words, it takes the form 2^n - 1 for some integer n. For example, the prime number 31 can be expressed as 2^5 - 1, and thus is a Mersenne prime. Mersenne primes are quite elusive, the one just found is only the 51st known and has almost 25 million digits! Verifying that the found number was indeed prime required almost two weeks of non-stop computing. The quest to find further Mersenne primes is driven by the Great Internet Mersenne Prime Search (GIMPS), a cooperative, distributed effort that taps into the spare cycles of a vast community of volunteer machines. Besides being hard to find, Mersenne primes are of great interest because they are some of the largest known prime numbers and because they show up in interesting ways in games like the Tower of Hanoi and the wheat and chessboard problem. Back in 400 BCE, Euclid discovered an intriguing relationship between perfect numbers and the Mersenne primes. Specifically, if 2^k - 1 is prime, then 2^(k-1)*(2^k - 1) is a perfect number. Those of you enrolled in CS103 will appreciate this lovely proof of the Euclid-Euler theorem. This relationship will allow us to calculate perfect numbers using a much more efficient approach. The final task of the warmup is to implement this blazingly-fast algorithm and bask in the glory of having beaten the pants off exhaustive search. Turbo-charging with Euclid Now that your computer is good and tired, it's time to take a more elegant approach to this problem. Over two thousand years ago, that clever guy Euclid discovered an intriguing pattern in the perfect numbers and was able to prove that if 2^k - 1 is prime then 2^(k-1) multiplied by (2^k - 1) is a perfect number. Implement the function prototype: long findNthPerfectEuclid(long n) This function uses Euclid's method (described below) to find the nth perfect number: Start by setting k = 1. Calculate m = 2^k - 1 (use the C++ library function pow to compute exponential) Determine whether m is prime or composite. (a simple isPrime helper that uses an exhaustive loop is just fine) If m is prime, then calculate 2^(k-1) * (2^k - 1). This is the associated perfect number. Increment k and repeat until you have found the nth perfect number. The call findNthPerfectEuclid(n) should return the nth perfect number. What will be your testing strategy to verify that this function returns the correct result? You may find this table of perfect numbers to be helpful. One possibility is a test case that confirms each number is perfect according to your earlier function, e.g. EXPECT(isPerfect(findNthPerfectEuclid(n))). Note: Your function can assume that all inputs (values of n) will be positive (that is, greater than 0). In particular, this means that you don't have to worry about negative values of n or the case where n is zero. Add at least 4 new student test cases of your own to verify that your findNthPerfectEuclid is correct. Q10. Explain how you chose your specific test cases and why they lead you to be confident findNthPerfectEuclid is working correctly. A call to findNthPerfectEuclid(5) will near instantaneously find the fifth perfect number. Woah! Quite an improvement over the exhaustive algorithm, eh? This version is so lightning fast that it will quickly reach values that are too large to fit in a long. How many perfect numbers can you find before you overflow (an overflow is characterized by the large number you're incrementing suddenly becoming unexpectedly negative...)? This value may vary from system to system, so just keep an eye out for when things start to go south. As a point of comparison, back in 400 BC, Euler worked out the first eight perfect numbers himself - not too shabby for a guy with no electronics! Concluding Thoughts Hooray for algorithms! One of the themes for CS106B is to explore the tradeoffs between algorithm choices, especially as it relates to program efficiency. The differences between the exhaustive search and Euclid's approach is striking. Although there are tweaks (such as the square root trick) that will improve each algorithm relative to itself, the biggest bang for the buck comes from starting with a better overall approach. This result foreshadows many of the interesting things to come this quarter. As a finishing touch on this portion of the assignment, add to the comments in perfect.cpp to share with your section leader a little something about yourself and to offer an interesting tidbit you learned in doing this exercise (be it something about C++, algorithms, number theory, how spunky your computer is, or something else exciting!). Before moving on to the second part of the assignment, confirm that you have completed all tasks from the warmup. You should have answers to questions 1 to 10 in short_answer.txt. You should have implemented the following functions in perfect.cpp smarterSum isPerfectSmarter findPerfectsSmarter findNthPerfectEuclid as well as added the requisite number of tests for each of these functions.
http://cs106b.stanford.edu/lectures/05-stack-queue/qa.html
Q: Hey! On homework, when it says add at least __ more test cases, does this mean that many more types of test cases (e. g. checking for squares, checking small numbers) or simply checking that many unique values through your function? A1: While we strongly encourage you to consider multiple classes of types of test input, the minimum test requirements stated in the assignment handouts refer to one input/output check for one function. That being said, a truly comprehensive testing plan to validate the full correct functionality of your code will often have to involve much more than the minumum specified number of tests. Q: is peek like a get function aka acessors for objects? A1: Yes Q: Do stacks have an initialized size or can they change in size as you push more and more values? A1: Will grow as needed Q: what does ADT stand for A1: Abstract Data Type Q: does stacks use RAM? A1: Yes, all program data (variables, etc) is stored in memory (RAM) during execution Q: Does pop return the value removed? A1: Yes Q: Why would you ever use a stack over a list, where you can access all the elements? A1: live answered Q: Is peek() essentially a way to access the top element? A1: Yes, without removing it A2: For context, pop will provide access and remove the top element Q: Someone else asked it, but I missed the answer: Why use stacks over arrays? A1: Simplicity. Although you could eat dinner using a full-featured tool like a Swiss army knife, it's going to be simpler and less error prone to just use a simple fork Q: is const in c++ equivalent to final in java? A1: Pretty much, yes A2: When used on variables yes. Q: Is there a particular reason we used all caps for SPACE over camel case? A1: live answered A2: We use all caps for constants Q: why do we need to reset the word to be empty in step 3? A1: live answered Q: Could constexpr also be used here? A1: Yes, it is a compile-time constant. Q: why do you have to write const before string? can u just declare it as a regular variable and then not change it A1: live answered A2: It's protection against accidental changes later on + good style to indicate to othe rprogrammers reading your code that this value should never be changed. Q: what did you #include? A1: #include "stack.h" Q: Can't we just use .isspace command? A1: yes, there are multiple ways to do it Q: If possible, should we always use a for each loop rather than a for loop? A1: up to you. It is a stylistic choice! A2: A for-each is often more convenient, less error prone Q: wouldn't this fail if the sentence has spaces like this? A1: no A2: It would end up pushing some empty strings, but when you printed them, they are emtpy, so basically it wouldn't be visible Q: This code doesn't account for puncuation correct? A1: Yeah punctuation is just considered to be part of words. Q: do we need to use word again? or could we just do cout A1: That way works as well Q: if word is a C++ string, why couldn't we just directly concatenate it with + with char? A1: live answered Q: how do we add a string and a char without cenverting types? A1: live answered A2: You can just use the + operator, it will take care of the type conversion for you Q: why do we reset the word? A1: We don't want to concatenate each word onto the previous words, we want that word as separate string Q: Is there a way to see stack size A1: stack.size() Q: The code will output an extra space at the end right? A1: live answered A2: Yep Q: Can you ever like see what the stack actually looks like A1: Yes, you can inspect the stack in the debugger! Q: Could you possibly zoom out so we can see the whole program? A1: The text size gets small for people if we do that Q: Is there a way to use a for-loop with a bound increased by 1 to kind of combine the last if (word != "") block into the loop? A1: live answered Q: cout + SPACE Is this ok? A1: Yes, that also works Q: can we do char+string or only string+char is allowed? what about char+char? A1: no you can only add strings to strings A2: adding a string to char (or reverse) is fine, but adding two chars will produce a char that is sum of the ascii values, not a string of length 2 Q: is stack.size() inefficient? Does it need to loop through every element to get the size A1: No, the stack ADT keeps track of its own size and is able to return that efficiently Q: I dont understand the purpose of the line where it says "if word doesnt equal empt char, push word onto wordStack" A1: live answered Q: Could you have just written cout in the body of the while loop A1: yes Q: Could you use string::find to find the spaces and create substrings instead of using chars A1: Sure, there are lots of ways to write this code Q: could you just append a space onto the sentence to make sure that the last word is pushed? A1: sure, that would work but we probably wan't to avoid modifying the intiial sentence Q: how did you know, logically, that you do should do the space condition first (as the if) and the word creation second (as the else statement)? / does it matter? A1: live answered A2: Same thing happens either way - only one of the if/else is entered based on the condition, there is no first/second ordering to the two options Q: So "a" is a C string, whereas when we declare string s = "a", then s is a C++ string? A1: yes A2: Yes, once a string literal gets stored in a string type varaible, it becomes a c++ string Q: Would you do this in a similar way with std::cin? A1: Simplest would be to use getLine() to read the line from input, then run the algorithm on the string Q: what does the "else word+=c;" do again? A1: Appends a character to the end of the string A2: Continues building up the current word by appending on the current character form the original sentence that we're considering Q: if a spce is the first char in the string, can the program push an empty value onto the stack? A1: live answered Q: When should we use vectors vs stacks vs queues? A1: vectors - when you want to access elements that aren't first or last queue - when you only want to access the element that was put in first stack - when you only want to access the last inserted element Q: I remember Netflix has a queue for your movies. Does that use a queue? A1: Very likely! A2: yep, first-in-first-out! Q: Is there also a runtime error if peek() is dont on an empty queue? A1: Yup Q: Is front() the same as peek()? A1: live answered A2: front() no longer exists, we're only going to use peek() Q: what is the difference between peek() and front() again A1: front() no longer exists, we're only going to use peek() Q: Are there any limitations to what types we can include in a queue or stack? A1: Nope, any type can be used Q: does back() still exist? A1: No Q: Does the Stanford Libraries have abstract data types for a double ended queue or a priority queue? A1: Yes, Deque and PriorityQueue respectively Q: oh right, about LaIR... how do we use it? A1: Search for "lair" on course web site to get info! Q: is there a reason why the Stanford library uses different names from the standard library for the same functions? A1: live answered Q: like where do we find it? Q: Ohh okay! Q: can people outside of Stanford use the Stanford library? A1: Yes, its freely available though likely used primarily in our course. A2: Yes, but it typically isn't done Q: will you tell us in assignments/assessments if we should use a queue as opposed to a vector or is it our choice A1: A lot of times you will have to make reasoned choices about which data structures to use. Q: say we stop at 106b and they ask us c++ stuff on a job interview, how should we explain that the functions we know about are different, and how do we learn which are the "standard" ones? Or can we use the stanford library at all times? A1: They are really effectively the same, it is just a naming convention that differs A2: Sometimes you can ask to use an external library (like stanford) Google is also a good resource if you want to find the official C++ documentation Q: is the order that prof. chris did his example in the order youre supposed to do things in the STANDARD library? A1: live answered Q: C++ data structures/objects are automatically instantiated? A1: live answered Q: what happens if queue.size() changes during the loop. does it just use the initial value? A1: It will use the current size. You usually don't want to change a data structure that you're looping through Q: Does the for-each loop exist for stacks and queues? A1: live answered A2: It does not, since you can't loop over ome of those structures without destroying them Q: What does toString() do? A1: live answered A2: Converts the data structure to a string representation that can be printed. Q: why does queue.dequeue(0) return 1? is it because 1 was in the 0 index? A1: dequeue does not take any parameters. queue.dequeue() Returns the element at the fornt of the queue, which was 1 in this case A2: Dequeue does not take an argument, it always removes and returns the element at front of queue Q: does the for loop reevaluate the queue.size() evertime the program iterates? A1: yes A2: Yes, all parts of the stopping condition get evaluated at each iteration of the for loop Q: so if we had a different function in place of queue.size, for loops could be inefficient because it computes the value every time? A1: Yes if you had an "expensive" function as part of the for loop condition then that could get inefficient wquick Q: so in a for loop, the i++ gets evaluated before the i < queue.size() check right? A1: Yes Q: how would you write it correctly so the numbers are all dequeued? A1: live answered Q: Difference between: cout vs. cout A1: they are the same A2: No difference. The former is a little less cumbersome A3: Same output, cout will automatically call .toString if you don't do it yourself Q: also there is no way to "index" in a loop, you only have access to the front? A1: Correct Q: does stack also have a .size() method? A1: yes Q: Does the standard library throw an error if you try to modify a data structure while doing a for each loop or just the Stanford libraries? A1: Our libraries have many more safeguards than the standard libraries, yes Q: Is that notation also called reverse Polish notation? A1: Yep! Q: what will break when we modify during a for each loop if we use the references (int and other related values will not change since it's copy by value)? I know sometimes the contract will break, but what will break in these ADTs? A1: Consider: If you were to insert/remove a value into the collection while iterating over it - does that new element get a turn in the iteration or no? Q: How do you handle more than a digit A0: How do you handle more than a digit A1: numbers and operators are separated by spaces so you have arbitrarily long numbers Q: Do we need to know postfix notation for assignments? A1: No its just for this example Q: is there any benefit to using const as opposed to #define? A1: Yes, const is better C++ style. #define is left over from C Q: could you also use a stack to calculate normal expressions (like 1+2*3 *(4+5) ) A1: live answered Q: looking ahead, i think the code on slide 17 is buggy? there are two main()s etc. A1: live answered Q: Not actually related to the lesson at hand, but I was thinking about it earlier. Because the original value of i is stored in post-increment for loops, is the pre-increment technically more efficient, especially for user-defined types? A1: live answered Q: Coming from a Java perspective, sometimes, we are not even allowed to modify the elements in an ADT, much less the size, which messes up things in a sorted ADT. Is there any parallel in C++? A1: live answered Q: in a for each loop Q: are the section times we received in PST? A1: live answered A2: PDT
http://cs106b.stanford.edu/lectures/04-vector-grid/qa.html
Q: When is next week's assignment being released? A1: Assignments will be released the day after the preceding one is due. Since Assignment 1 is due on Friday, A2 will be releaed on Saturday. Q: How long should the weekly assignment take us in terms of hours? A1: live answered Q: are YEAH sessions recorded? :) A1: Yes! A2: Yes, Trip should have posted the recording last night Q: how do we view our grades? A1: You will have a grading conference with your section leader Q: what are YEAH sessions?? A1: Assignment Help/tip sessions Q: How are you today? A1: Great, thanks! :) Q: do we get extra credit on assignment 1 if we find the 52nd perfect number A1: Absolutely! A2: I think you should probably just graduate from Stanford at that point! Q: Is the string comparison technically lexographical like in Java? A1: Yes, based on ascii character encoding, so uppercase precedes lowercase letters for example Q: When we submit homework files, should we uncomment all provided tests if we commented them out? A1: yes Q: So the comparison signs for strings look at order in alphabet, not the ASCII values for the characters in the strings? A1: It is comparing characters values by ascii encoding, but those are in alphabetical order, so it ends up looking like the same thing Q: Is there a document on the webstie detailing all of the relevant string/character methods? A1: yes! check the C++ reference Q: is append basically just += for strings? A1: Yes, they have the same behavior Q: Wouldn't this be s2? Not s3? A1: yeah, but the code still works the same Q: are strings passed by value in functions? A1: Yes, like all C++ parameters, the default is pass by value Q: Is it supposed to be "s3 is now" A1: yes Q: Is there a reason why you'd pick erase vs. concatenating the substrings like was done in assignment 1? A1: We have found that modifying string in place (with functions such as erase) end up being more confusing for students Q: if we're chanign s3, why do the comments say that s3 is changing? A1: typo. Imagine they all say s2 Q: Are we appending to s3 or s2 with the s3.append("Giraffe") A1: s3. Comments just say s2 A2: s3, the comments have a typo in them Q: how does "s.compare(str)" work? A1: http://www.cplusplus.com/reference/string/string/compare/ Q: what is string: :npos ? A1: Special constant that represents "no position" (i.e. not found) A2: It's a special constant that represents "doesnt exist in the string". If you're coming from Python, it's the euqivalent of -1 being returned from the find function Q: Is there a find that takes two inputs (str, n) and returns the nth occurrence of str? or would this have to be done manually with a loop? A1: live answered Q: Does rfind search for the reverse of str as well as going backwards or does it search for str going forwards but just starts searching from the end? A1: Searches from end, but match is forward Q: Why could tolower be called individually but functions like append() have to be called with a period? A1: live answered Q: When does compare return 0 or -1 or 1? A1: http://www.cplusplus.com/reference/string/string/compare/ A2: '-1 if a < b 0 if a == b 1 if a > b Q: why aren't there 2 a's when doing s3.erase(4,3)? A1: the second param means eras 3 chars Q: I noticed there was no compareTo method in that list. Is there no compareTo in C++, only Java? A1: The function is named compare in C++, not compareTo Q: what are member functions? A1: Functions that belong to an object/class, they are invoked using the syntax object.function as opposed to global functions where there is no object. in front Q: Apologies for asking something that has already been answered, but could you reiterate what the difference between the two tyeps of strings and their uses are? If I define a new string as "hello" it will be a C string unless I specifically convert it? A1: In general, we use C++ strings for everyhing, the only case where you will end up with a C string is when you have a string literal (in double-quotes) Q: Will we have to use C strings in this class or know how to convert them? A1: It would be good to know! Q: ohh so an example of a non-member function is toLower, right? A1: yes, exactly! Q: okay, thanks! Q: if "text" is a C string, then how do you define a C++ string? A1: by storing it in a variable of type string Q: Is there an API for all Stanford library functions A1: https://web.stanford.edu/dept/cs_edu/cppdoc/ A2: Liked under "Stanford Library Documentation" on the home page. Q: How do we know when we are working with a C string? A1: In general, we use C++ strings for everyhing, the only case where you will end up with a C string is when you have a string literal (in double-quotes), if you store that in a variable of type string, it will automaticaly convert for you Q: So string literals without string() wrapped around them are C strings, and vice versa? A1: yes Q: If you did string.erase (x, 0) would nothing happen? A1: correct A2: Yes Q: Isn't it potentially dangerous to call str[0] on an empty string? A1: yes, it is Q: What types have their data copied when passed to a function? A1: Anything passed by referrence A2: All types are passed by value by default in C++. You have to explicitly ask for a parameter to be passed by reference Q: why is there no ampersand before the a in string a A1: live answered Q: Would it be wrong to write b = "b.insert......"? I feel like that makes it clearer that it's been modified. A1: It would be redundant but not incorrect Q: When using insert or erase on a C++ string, do the characters to the right of the change point (whose indices get changed) get moved in memory? A1: Effectively, yes, the characters move index. How that works internally is opaque to us as a client of string Q: why is there a return 0 A1: By convention, main always needs to return a value Q: If you print a in the first function it will be edited right? A1: Correct Q: so can you chose when it will be reference by using &. In other words, could we have made A reference just by adding &? A1: Yes, exactly Q: What is the difference between member and non member functions again? A1: Quoting Julie from earlier, member functions are functions that belong to an object/class, they are invoked using the syntax object.function as opposed to global functions where there is no object. in front. Non-member functions are standalone (like tolower) Q: can we use the stoi function for string to integer? A1: Yes. Q: What is the difference between tolower() and toLowerCase()? A1: The argument to tlower is a single char and returns single char, toLowerCase converts/returns string of characters Q: So even complex data structures and instances of user-defined classes will be deep-copied every time they are passed by value? A1: yes, which can make code slow. Q: does trim remove whitespaces in the middle of words? or only before/after? A1: only at the beginning and end Q: when do we use C++ str and C str? Is there any benefit of using C str? A1: In general, we use C++ strings for everyhing, the only case where you will end up with a C string is when you have a string literal (in double-quotes) Q: what does Chris mean when he says C++ strings are more functional? A1: They're eaier to work with and have many more hepful funcitons defined on them Q: If I do something like cout is it printing a C string or a c++ one? A1: C string Q: what are sections like + how are they run A1: https://web.stanford.edu/class/cs106b/about_section A2: Think of it as a 50 minute long interactive problem solving time, led by your section leader Q: Does this mean that to initialise a C++ string, I need to put it in a variable? A1: Correct Q: can we attend multiple sections or is that not allowed? A1: It is allowed but def try to make your own Q: Can't we just return a collection if we want to return more than one thing from a function A1: Yes, if the multiple things are of same type (the collection elements have to be homogenous type) A2: Sometimes, but if you want to return multiple types it gets tricky Q: Is Vector like an array in C? A1: yes, but dynamic A2: Yes, but with additional convenient functions, managed memory, bounds-checking so much better than raw array Q: what happends if you don't have the bound check A1: program will crash or behave unpredictably A2: You might get an out of bounds error during runtime Q: if you access an element from index and you want it to be bounds checked do you have to use vector.get(index) or can you just use vector[index] A1: Both are bounds-checked Q: Can you make a vector of vectors? A1: Yes, you can Q: Can Vectors hold Objects? A1: yes A2: Yes Q: Is a library a class or can a class be part of a library? A1: A class can be in a library Q: When you print a vector can you do cout or will that not work? A1: Yup! Q: can you print out the entire vector A1: live answered A2: Yes, you can cout Q: For this class, can we (or will we) use arrays at any point? A1: yes, we will A2: Yes, we will learn all about arrays in the middle of the quarter Q: is there a simple-ish way to prepend to a vector? A1: you can do vec.insert(val, 0) to say to insert something at index 0 A2: insert, or add one vector to another Q: When you delete an element, does it leave behind a None or a null? A1: It is removed and elements shifted over to close gap Q: Can I use a for-each loop for Stanford library vectors A1: yes A2: yes, chris is talking about that right now Q: is it more efficient to create a variable size and then use the size variable in the for loop rather than putting the function inside the for loop if you plan to use the function at least once inside the for loop? A1: In some tiny way, yes. This is not a level of optimization we want you to pursue Q: if you're doing a foreach loop on a vector and inside the loop you add an element to the vector, i'm guessing the loop will not include the newly added element? A1: It is not legal to modify a collection while iterating over it Q: if vector got modified in a sun function, will it change the original value A1: if passed by referrence A2: If the Vector were passed by value, no; if passed by reference, yes A3: It dependson whether or not the vector is passed by reference or not Q: sub fucntion Q: Is Vector a stanford creation or available in normal C++? A1: Stanford specific A2: Vector with capital V is a Stanford-specific thing Q: Kind of a tangential question, but arrays don't have the nice property of shifting everything left when removing an element, right? How do we deal with that A1: We have to do it by hand! We'll see that when we learn about arrays later in the quarter A2: Copy everything over manually when deleting an element Q: so a combination of vectors would be better if you plan on changing the size of the "grid" right? A1: Sometimes! It depends on what you're implementing and what you care about A2: You can change the size of the grid, see resize function Q: What's the difference between grid abc(10,20) and int two_d[10][20];</i> A1: similar to the difference between an array and a vector class collection version is easier to work with and has functiones defined on it Q: Can you create a 3D array with a vector of grids? A1: Yes Q: What's the difference between a grid and a matrix? A1: a matrix is of type grid A2: Same idea, different term Q: Can you have empty squares in a grid? A1: All squares will have some value are initialized to the type default value to begin with Q: Can you fill values within a grid with Null to simulate a "ragged right" matrix? A1: yes Q: Is Grid only Stanford specific? A1: yes Q: in a grid, is the first index the row or the column? A1: row Q: do you have to capitalize "Vector" and "Grid" whenever you use them A1: yes, that is very important Q: matrix here is just a name? A1: yes Q: Are grids and vectors passed by value or reference? How does the & operator play into this? A1: All C++ parameters are passed by value by default (or any type), by adding & to the parameter type you are changing to pass by reference Q: Can you print out a grid just like that? I know in Java it is stored weirdly so you need a specific function in roder to do so... A1: yes you can print out a grid by saying cout Q: which is faster: grid or combination of vectors? A1: Performance is similar. Q: Do we have to do a #include for Grid? A1: #include "grid.h" Q: Does grid.resize() do the same thing as assigning a new empty grid to the same variable A1: Correct Q: Is there is a way to 'purge' a variable in C++ if it's no longer needed A1: yes, if it takes up memory, we will talk about this later in the quarter Q: Can you intialize a Grid like Grid matrix(2,2) = { {1,3}, {2, 4} }</i> A1: yup! Q: so we would never have to have our column variable, only go up to grid[r].numCols() because the rows and columns are always rectangular? A1: A Grid is rectangular, yes, every row has same number of columns Q: For this example, would it be 3 arrays of 2 elements each, or 2 arrays with 3 elements each A1: I've lost the context for this, but when creating a matrix, the arguments are in the order number of rows, number of columns A2: 3 rows and 2 columns Q: does it matter if the rows or columns are on the inside or outside loop? A1: it will change the order in which things are iterated over Q: Is it convention to have the row loop on the outside and the column loop on the inside? A1: yes, that is the way you will see most loops over girds written Q: syntactically, where does the & go? is it type& var, type & var, type &var, or does it not matter A1: Does not matter, but pick a style and be consistent! A2: Doesn't matter, just stylistic preference Q: Why is the & in the middle with spaces for passing with reference? When do we put it next to the variable name? A1: Either is fine, means same thing, but pick a style and be consistent A2: It doesn't matter functionally, its more of a style thing. Just pick something and stay consistent in your own code! Q: In "Grid", are all the values in the grid bool? like T/F?</i> A1: yes Q: can you make a grid of vectors and have like a 3D array? A1: Yes A2: yes Q: what's GCanvas? A1: It a class from our Stanford library that can draw a grid of pixels onto a graphics window Q: In which language was the Instagram originally programmed? A1: Good question! We should ask Mike! Q: Is GCanvas more similar to Qt's QPixmap or QImage? A1: QImage (but you really don't need to know that :-) Q: Are we supposed to but & right next to the type or adjacent to the variable name A1: It's a stylistic choice. Either as fine as long as you're consistent Q: why is palette passed in as a reference variable when it isn't being modified by the toonShade function A1: passing by referrence is more efficient for large data structures Q: is there a reason why palette is passed by reference in this function? A1: passing by referrence is more efficient for large data structures Q: Are we going to make something similar like ToonShade for class project? A1: live answered Q: Could you go over the passing by reference with a, b, and c again? I was a bit confused haha A1: live answered Q: If you pass an object by reference, and you make the variable refer to a new object within the function (not just modify the object), will the original variable refer to the new object? A1: yes Q: In slide 19, why do you use grid to hold bool values instead of int? In the loop, it puts integers in the grid. A1: What do you mean when you say in the loop it puts integers in the Grid? The chosen type f the grid is bool, which is what it stores Q: thank you Chris, Julie, Nick, and Chase! A1: No problem! Q: Can you concatenate a C string with a C++ string? A1: Yes Q: Is it okay to have the space between and &? (slide 19)</i> A1: yes! It's a style choice Q: Thanks! Q: Can you add and multiply booleans with ints? A1: live answered
http://cs106b.stanford.edu/lectures/01-welcome/qa.html
Q: Is there a way to download lecture slides? A1: Not sure what it looks like on Windows but on Mac you can right-click and selectt Print > Save as PDF from the printer option menu A2: Our plan is to publish all materials in HTML format (best for accessibility). Q: Is there a way to mute the chat so that the notifications don't pop up? A1: Unforutnately not today, the chat should die down a lot. Q: What would you guys like us to call you? A1: Please call me Julie! We're a first-name kind of team Q: For some reason, the link http://web.stanford.edu/class/cs106b/qt/sample-project.zip from the slides is still is not working for me to get the CS 106.zip file. Is this the correct link? A1: No, the link is named CS106.zip, let me fix that link Q: I still get a Object not found! error A1: Q: I'm still unable register in any of the section and they all seems full already A1: Section registration hasn't opened yet! more info will come soon Q: For the textbook reading, do we suppose to read them before the class to get a better learnig experiece or it is more for the review after the class A1: It's up to you! Whatever works best for you in terms of learning. There's no strict expectation that you'll do the readngs before class. A2: Textbook reading is reccommended but not necessary for the class. It's completely supplementary Q: Julie, did you get the chance to work with Craig Federighi when you were at NeXT/Apple? Huge fan of him! A1: Yes, great guy! He had joined NeXT right before the Apple acquisition Q: Approximately how big are the sections? A1: live answered Q: It's 7 assignments right? A1: live answered Q: What day of the week will most assignments be due? A1: The first four will be due on Fridays and the last 3 will be due on Wednesdays Q: where can we find the textbook? A1: Available in printed form from bookstore, PDF on website (search for textbook) Q: Midnight as in between Th-F or F-Sa? A1: live answered Q: do we have an assigment due this friday? A1: Yes, assign 0 A2: It's a short installation/running code exercise that shouldnt take more than an hour can find it posted under the Assignments tab on the course website. Q: is a check plus a B or A? A1: live answered Q: How does the check plus contribute to the 60% component? A1: live answered Q: Is the class graded on a curve? A1: Our grading system is standards-based Q: How does the on-time bonus affect the + - check grade? A1: The on-time bonus isnt reflected in the assigned bucket grade. It is tabulated separately at the end of the quarter. Q: What resources are students typically allowed to use if they are stuck on a problem? A1: Office hours/LaIR Q: Where can we find the list of sections and their times prior to registration so we can see what fits into our schedule? A1: You won't be able to see the list of section times until registration opens up on Thursday A2: This probably won't be available before registration, however there are typically a variety of times Q: do you have any updates for ACE section? A1: Email Garrick directly for ACE followup gfaerr@stanford.edu A2: Update in terms of applications and enrollment? Unfortunately, that falls outside of our control, but you can join the first ACE section this Tuesday night by emialing Garrick to get the Zoom link Q: When in discussion, can we talk about which techiques we use? A1: As long as you don't explain how you solved an assignment, yes Q: do we have to sign up to a section if we plan on doing ACE? A1: Yes A2: Everyone must sign up for a section, as your section leader will be the one responsible for grading your assignments. Q: Can we partner for assignments? A1: No Q: Apologies, may have missed this, where do we go to sign up for sections on Thursday? A1: live answered Q: Will the Q&A from each lecture be posted somewhere after class? A1: Yes, that's the plan! Q: Where can we signup for section later on? A1: See link to Section Portal on website under Sections tab Q: Is it possible to use VSCode for assignments? A1: live answered Q: Can we use another IDE or editor like VS Code or is it not recommended? A1: live answered Q: is qt creator paid for by stanford? A1: The student version is free to downlaod Q: Can I use Repl.it? A1: live answered Q: why is XCode listed as required software for macs? A1: Xcode tools supplies the needed compiler/linker that Qt uses, so you must install Xcode first to get those tools A2: It's necessary to download qt Q: Is there any knowledge of GUI required in the programming assignments? A1: No Q: Is that an internal vim mode? A1: live answered A2: live answered Q: Is there a preferred OS for this class? A1: live answered Q: For Mac, should we choose macOS for Qt 5.15.1 or Qt 5.15.0? A1: Either is fine Q: Does qt creator work with the mingw gcc compiler? A1: On Windows, yes Q: how do we get access to Qt? A1: There is a guide on the course website Q: Do we need to sign up for a Qt account or is there a way to download the student version on this site? https://www.qt.io/download A1: You do need to create a Qt account unfortunately but the download should still be free Q: is console.h included when we download qt ? A1: It is part of the CS106 library install (you do this step after installing Qt) Q: When do office hours begin? A1: Today. Mine are today after lecture, come visit me! Q: Do you have to retun something in the main method? A1: Yes A2: Yes, you must return an integer "status code" Q: Why use #include "vector.h" and not #include ?</i> A1: live answered Q: Is this a user-defined vector class? A1: Yes, Stanford-specific Q: how does the 106b style guide compare to those found at tech companies? A1: Our guide is written for an apprentice, more about helping you develop good intuition about what do and why. Corporate guidelines tend to more about setting official standards Q: What should we review from 106A if it's been a while? A1: loops, if statements, syntax, and any data structures you may have learned Q: What does fundamentally? A1: Outputs information to the console, which is the portal for communicating input/output Q: For learning most of the syntax of C++, will we be going over this in class or should it be learned independently? A1: We'll be going over C++ syntax/fundamentals in lecture this week and you will get practice with it on the first programming assignment A2: Most will be covered in clase Q: why do we need the #include lines at the beginning? A1: The #include tells the code where to access certain data structures Q: thank you! A1: Q: Is there an access code for anything we would need from purchasing the textbook? A1: live answered Q: Did the instructions for Qt Creator installation changed for the summer quarter? A1: Yes! A2: Yes, you need to follow this quarter's instructions Q: are there any textbook readings for this week? A1: See readings on schedule page Q: is there any benefit to upgrading to macOS catalina from mojave for this class? A1: live answered Q: I heard something about a CS 106M supplement to this class. Could you clarify what that is? A1: live answered Q: oh okay! thank you A1: Q: What are the primary differences between the Stanford library and the standard library? A1: The Stanford library has been designed to reduce overhead and make things work as smoothly as possible with the goal of being more suited for education purposes Q: How soon after the live lectures will the recording be posted on canvas? A1: Usually take an hour or two to process and upload to Canvas Q: How do we see where the office hours are? A1: Office hours calendar linked in the sidebar of the main page of the course website Q: After downloading CS106 sample project, I am still getting that console.h file is not found. Is anyone else getting this? A1: Can you come to my office hours right after class and let me debug with you Q: That sounds interesting! Is 106M offered this quarter? How can we sign up for it? A1: Enroll in axess! Q: Are readings expected to be done before the corresponding lecture? A1: Readings are optional Q: Should we use our Stanford email for the Qt Account, or a personal email? A1: Doesn't matter, either works Q: What is the difference between 106M and 106L? A1: live answered Q: How do CS106L and CS106M differ? A1: live answered Q: Are the suggested readings on the website schedule "due" on that day or due for the next class? A1: Up to you! all readings are optional A2: The suggested readings for a given day correspond to the content covered that day in lecture Q: The link to the Stanford Libraries zip file seems to be broken(?) A1: Where, which page? I will fix! Q: In the "Select Components" window of the Qt installer, CMake 3.17.1 and Ninja 1.10.0 are checked as default-do we leave them checked after checking the Qt 5.15.1 macOS option? A1: No, you do not need them Q: For our Qt account, we check "I am an individual person not using Qt for a Company" right? A1: yes Q: Can we take CS106L a quarter after we've taken cs106b? A1: yes Q: Can we audit 106M/L for no credit? A1: live answered Q: Should we download qt 5.15.1 or 5.15.0? A1: Both are fine Q: What is the best course sequence to take after CS106B? A1: We'll talk about that at the end of the quarter! But usually most people move to CS107 Q: I don't see the zoom links for the office hours? A1: There's a separate Zoom info page you have to go to, linked form the office hours calendar Q: What is the difference between ACE and M? A1: live answered Q: how can you sign up for cs106m? A1: Enroll in Axess Q: Do we have to get a textbook? A1: No, not required A2: No, it's optional Q: Is that possible to take CS106B ans CS107 together? A1: No, 106B is a prerequisite for 107 Q: Will textbook readings be under Assignments on the website? A1: They're on the course calendar Q: 50 gb, this'll take a while A1: live answered Q: What computer specs are necessary? A1: live answered Q: What are your thoughts on the effects of distance learning on instruction/etc? My personal feeling is that lectures are better in this format although I have nothign to compare it to A1: live answered Q: There seems to be no stanford library in the starter code for assignment 0 so it cannot run A1: live answered Q: How do we register for Ace? A1: live answered Q: how much space do we need on our computer for this class? A1: live answered Q: when we submit code, are there any preferences that the instructors have regarding style? such as brackets around 1 line if statements, etc. A1: live answered Q: ^ check out http://web.stanford.edu/class/archive/cs/cs106b/cs106b.1212/resources/style_guide.html A1: live answered Q: kind of specific, but if I don't take 106A and didn't take high school cs but think I can go straight to 106B, I won't have to go back and take 106A even if my major requires it, right? I'm thinking about mcs major. A1: live answered Q: Where should I submit homework? A1: live answered Q: Thanks! A1: live answered Q: I can't find the Stanford Library download on the website. Where is it located? A1: live answered Q: For assignment 0, will there be any element on the Paperless site or is it just the google form submission? A1: live answered Q: Do you have a favorite lecture in this course? A1: live answered Q: Can you clarify a bit more about collaboration policy: To what extent can students discuss the problems? Can we discuss approaches / algorithms / data structures for a particular assignment? A1: live answered Q: Do we also need to download Developer and Designer Tools in Qt setup select components? A1: live answered Q: For the MinGW requirement for installing Qt Creator, can we download the 64 bit version and ignore the 32bit version if our computer is 64 bit? A1: live answered Q: The starter code for assignment 0 can't run. Undeclared identifier and console.h, simpio.h not found. Stanford library doesn't work A1: live answered Q: this link will give instructions for the library download/install http://web.stanford.edu/class/archive/cs/cs106b/cs106b.1212/qt/library_beta.html A1: live answered Q: Thank you! A1: live answered
http://cs106b.stanford.edu/lectures/03-strings/qa.html
Q: Hi, should we really do "using namespace std"? I don't recommend "using namespace std." for two reasons. 1) If we try to read and debug large projects that include multiple libraries, we're unable to tell from which libraries certain functions come from. 2) If we use multiple libraries that have similar syntax of namespaces and use multiple namespaces, there will be a silent compiler error and function conflicts may arise. The only reason why there's no conflict cctype library and the standard library is because syntactically the functions in the cctype library are named differently and so the compiler knows which functions to apply "using namespace std" to. A1: live answered Q: There's nothing to turn in for assignment zero right? I can't see anything on paperless. A1: Just fill in the Google form, nothing on Paperless. Q: Are we supposed to read ch 4 (streams)? Slides and schedule seem to have conflicting information A1: Reading is optional/supplementary. That said today's reading was for chapter 5 A2: We won't spend much time in lecture on streams, you will want to do that reading to pick up the background info Q: Wait where is this form for assignment 0 A1: Linked to on the assignment page Q: Is it available other quarters? or only fall? A1: live answered Q: how often do they meet? A1: live answered Q: Can we audit the course? A1: live answered Q: whats auditing? A1: Following along with class, but not officially enrolling, not being graded, etc Q: C++ STL library uses snake case for its functions, but the stanford library uses camel case for its functions. Would that be a possible way to tell which functions come from which library without referring to the namsepace? A1: Sharp eyes! Difference in case does help you to identify which library a feature belongs to. Q: can you compare variables of different types using == ? for example an int 4 and a double 4.0 would that return true, false, or not even work? A1: live answered Q: I'm confused about not a, could you re explain it? A1: It inverts the truth value, if a were true, not a evalutes to false and vice versa Q: does c++ have the bitwise XOR operator (like how Java has ^)? A1: yes, although we wont use it in this class Q: Are booleans declared true or false, or are they declared with 0 as false and anything else is true? A1: We'll use true/false for boolean values in this class. Q: if I compare int a =5 and float b = 5.34 and ask Cpp which one is bigger, what result can i expect? A1: the float will be larger Q: why is there 2 at the last line? A1: it creates two new lines Q: if you do more than three if statements are all the rest of them "else"? A1: no, all of them would be evaluated unless using else if Q: Can we still get enough experience for interview questions from CS106B without taking CS106L? A1: yes Q: Can a floating-point number be compared to an integer? For example, would 1.0 == 1 return as true? A1: It would convert the integer to float and yes, would evaluate to true, but there can be cases where the converstion between types int-float produces some roundoff surprises, so there is some pitfalls when comingling types uncarefully Q: Wait, how come you can't declare functions within the scope of another function in C++? A1: live answered Q: were we supposed to get a confirmation email when we submitted assignment 0? A1: no A2: no. as longas you hit submit you should be fine Q: Do all functions (not just the main function) need to return an integer? A1: No, different functions can have different return types Q: Does C++ have access specifiers? A1: On member functions defined with a class, yes, but not for independent functions Q: for function declarations Q: Do all functions need to return something? Is that why main returns an int? A1: no, a void function doesn't return anything A2: main has to return int because of C++ rules (main is special) Q: Does varType mean int, float, double etc? Or is it a variable type itself in the stanford library? A1: varType was a placeholder in that example. Thanks for that clarification! Q: can you have a non-decimal double? A1: live answered Q: why does it only round to 4 digits? Can we specify with cout or do we need to use some sort of printf? A1: live answered Q: why do we need cout endl for the printTenTimes function A1: live answered Q: if you want a void function to end early can you use return; ? A1: yes A2: Yes! Q: Would you have to define char c before passing it thru? A1: yes A2: You could also pass a character constant as the argument, i.e. printTenTimes('D') Q: if you declare a function but dont define it, what does the syntax look like for defining it later? A1: I think Chris will talk about function prototypes a little later on! Q: Does printTenTimes('a') == printTenTimes('b')? A1: live answered Q: how is void different from just typing return 0 at the end or a int function A1: a void function will return nothing (no value) while an int function returning 0 is actually returning a value Q: How do you print an empty line? A1: cout A2: or cout Q: are these slides available on the website? i don't see them there A1: check out the schedule A2: Note that Chris is working through the end of slides from lecture 2 (which is linked onto Wednesday in schedule) Q: does the main function not have to be first? A1: No Q: is python pass-by-value for all function inputs? A1: No, there is an option to pass by reference, we'll see that soon A2: Python is a weird hybrid called pass-by-reference-value things passed in to functions are references, but these referecnes are passed by value Q: do we not need to declare the function doublevalue? A1: The function definition can serve as its own declaration (as long as you define it in file ahead of where you use it) Q: Will we be using function prototypes as a part of style? A1: yes A2: Yes, definitely! They help to better organize your code. Q: do all reference functions return void? A1: no Q: If vectors are pass by value, does that mean the entire internal array is copied? For all classes in general, how would C++ determine which information would be copied and what would be kept as just a pointer? A1: if something is passed by value then yes it is completely copied when passed over. The writer decides what is passes by val vs ref A2: The class itself defines its behavior when passed by value (i.e. is it a deep or shallow copy). All Stanford collections do a deep copy. Since that is expensive, we generally pass collections by reference for efficiency Q: what would happen if there was no &? A1: It would be passed by value Q: how does the x know to go to the my value A1: live answered Q: wouldn't it have to be doubleValueWithRef when you call it? A1: Yes, correct! Q: could we get a quick explanation as to the difference between a pointer and a reference? A1: We won't talk about pointers until week 6, so hold on on that. For now, it is all references Q: why are the function names different? main calls on doublevalue but the function is called doublevaluewithref A1: live answered Q: is int& x the same as int &x? If so which one is better to use? A1: Yres, they're the same. Neither is better, just be consistent with your usage Q: Wouldn't the code by doubleValueWithRef(myValue) or can you omit the WithRef A1: live answered Q: why don't we pass the address of myValue? A1: live answered Q: can we return some values when using reference? instead of void A1: yes, you can return values from a function that takes parameters by reference Q: so can you omit the WithRef? A1: live answered Q: can &x be used later without having to write int again? A1: Depending where you write this it can mean different things Q: So the Ampersand is called a pointer? A1: no, the ampersand in front of a var indicates the var's address A2: In the context of the way we'll be using things for now, the ampersand in a parameter type declaration indicates that a function's paramaeter should be passed by reference Q: When it is beneficial to pass by value rather than reference? A1: live answered A2: We'll see some of the benefits of passing by reference as we move to work with collections. Pass-by-reference is both more efficient (don't have to copy) and lets you make direct changes to data structures Q: Oh okay, then what exactly is a pointer? A1: live answered A2: Hold onto that question until week 6! That's when pointers make their entrance in this course Q: That's cool! Is it sort of convert int into the "immutable" type that passes the URL refference and not the copy? A1: live answered Q: If you passed the WithRef function 7, would it work but just not change any variable? A1: No, this would get a compile error (because 7 is a constant and not mutable) Q: Why use header files as opposed to prototype functions? A1: Sometimes you want to reuse code from a header instead of rewriting every single time A2: Typically you use a header file when you are exporting those functions for use by other files. If you only use the functions within the same file, having the prototypes at the top is more convenient Q: what does "#pragma once" do/mean? A1: Prevents the file from being included more than once Q: what is the "pragma once" that was on top of the .h file? A1: live answered Q: what is console.h A1: live answered A2: terminal output library from stanford c++ libraries Q: Does including a header file basically load prototypes of the functions before main? A1: live answered Q: what's the point of header files if we still need to implement them A1: It separates the interface from the implementation, exports the information about the functions to other files Q: so whats the diff between header files and interfaces? A1: A header file IS an interface - you got this! Q: How do we actually implement the functions that are in the header file? Is it the same syntax as normal? A1: live answered Q: so if we wanted to use a header file as a library in other c++ files that would be a reason not to include #pragma once, right? A1: All header fields should have the #pragma once - it prevents issues where the compiler ends up with multiple copies of the same header wihtin one file, which is a no-no Q: where are those functions defined? A1: In the .cpp Q: Does function order matter? A1: Not if you have a prototype Q: how does QT creator know where to find the Stanford header files? NameHash for example didn't have a directory with header files but it still included console.h A1: The .pro file defines where the library has been included on your computer (as defined by the CS106 project you built during Qt installation) Q: is there downside to writing whole functions in header rather than just declaration? A1: We generally do not put the implementation in the header, code goes in the .cpp files Q: When would it be worth it to write inline functions as opposed to declaring them in header files? A1: live answered Q: is this analogous to an interface? it seems similar A1: Yes, exactly right! Q: Do you have to implement all functions included in the header file? A1: You should Q: What's bool? A1: A true or false value Q: What's the difference between pointer and reference...? A1: live answered A2: We'll talk about that later in the quarter! For now, pretend pointers don't exists. We'll only be using references for now. Q: Is the Assignment 1 due to next Friday? A1: Yes, 11:59pm pacific A2: yes Q: How do we create a header file on Qt? A1: Just create a file with the extension .h A2: You can right-click on the project name and use the "Add new..." option to add a new file, with extension .h Q: Is there a way to use header files, implement the file, and then use inheritance for a single point of control? A1: I'm not sure what you mean by "use inheritance", but putting commonly used functions into your own .cpp/.h and including that it multiple projects would allow you to reuse that cod. Q: so is the benefit of using header files solely just to give us the ability to put the main function at the begining of the file and other component functions after it? A1: live answered A2: Yes, using header files and function prototypes allows us to easier organize the code without having to worry about the order in which things are defined. Q: So to be clear, you declare a function in a header file, define the function below the the int main, and call the function in int main? A1: live answered A2: That is one way to do it. You also can put the funciton declaration before main, without explicitly using a header file. Q: so a function doesnt have to be defined before you use it? only declared? A1: Correct Q: With a .h file, we always have to implement it in each file. How do we reuse the square function, which will most likely be implemented the same way wherever we use it? A1: You would bring both files into a new project, the header file that declares it, and the .cpp that implements it Q: what's the difference between putting func protos in the header vs just at the top of the cpp file? A1: Both will usually work Q: If you don't define it how does the program know what to do A1: It doesn't, which causes an error Q: In the .cpp file, we can declare the functions in any order as long as we have main first right? A1: The general rule is that any function must be declared before it is used. So if a function is used in main, its declaration must come before main in the file. Q: In a lot of the Stanford header files i looked at they have the function code in them? Is that also pretty common for headers? A1: Only for templates (which have to be visible in headers due to C++ compilation semantics) Q: Is the name "header file" reserved for files holding prototypes? A1: Yeah, although it generally refers to any file ending in .h extension (these files mostly only have function prototypes/declarations in them) Q: are c++ strings basically character arrays? A1: Yes, we'll learn about the different types of strings later Q: Last question on declaration, what's the general rule of thumb when to use the Header file aka more than 10+ function declarations? A1: A better rule of thumb would be that you list declaration at the top of a file when you use those functions only in this file, but if you need to export the functionality to another file, then bust them out into a separate header file Q: Do we need to use "#pragma once" everytime? how does it work? A1: Yes, a header file should always have #pragma once. That is a special directive understood by the compiler Q: So for if we pair a .h file, and a .cpp file that only implements the methods declared in the .h file, we can then use that .h file in any other .cpp file without having to define it again? A1: Yes, that is correct. Q: is there an advantage to using one over the other A1: What is this referring to? A2: they're equivalent (assuming this is referring to .at() vs. [] Q: Why ever use the .at() function instead of grabbing the character by it's index? Is one more efficient? A1: style Q: Is that why in C strings are just arrays of characters? A1: Yes! Q: Can you declare characters without a string? Like char c = 'a'; A1: yes Q: stanfordTree[3] vs stanfordTree.at(3) A1: basically the same Q: Is it possible to have a single character string or is it automatically considered a char? A1: you can have a single char string A2: There's a difference between a single character string and a character variable. string s = "a"; char c = 'a'; ^ those are different things Q: Can a string be just one char? for ex: string example = "b" A1: yes Q: is the .length() function specific to the Stanford library or does it exist in the general C++ library as well? A1: standard library Q: Is .at a built in function? A1: yes standard string Q: is there a benefit to putting prototypes in the .h file vs in the cpp file? Is it just the difference between a private and public function? A1: Yes, the header allows you to export that funtionality to other files. If you only use the functions within this file, that having prototypes in .cpp is easier to maintain. Q: there's no need to include an escape character for single quote and double quote? A1: live answered A2: If you want to include a single quote ina string you don't need an escape. If you want to include a double quote in a string, yes you need an escape character. Q: wouldn't you have double single quotes because it is in both four loops? A1: live answered Q: is it possible to do something like enumerate() is c++?</i> A1: No, usually we use a traditional for loop or for each loop in C++ Q: Can you go over the single quotes vs double quotes quickly again? A1: live answered A2: Single quote defines a character, double quote defines a string. Q: If char ch = 'a' and you do ch++, will you get 'b' A1: yes Q: do we need to add "#include" in every program withstrings?</i> A1: yes A2: Generally, yes (sometimes you will get string on behalf of another include that also included string, but it is not a problem to include twice) Q: Why did you do i<(int).plainText.length() instead of i<plainText.length()? A1: live answered Q: will we see an example of using a .h file that is fully implemented? How is the stanford .h file implemented A1: We'll write our own .h files when we get to implementing classes later in the quarter A2: End of Chapter 2 in text gives a good example from library random.h and random.cpp - check it out! Q: Could you make in size_t instead? A1: live answered Q: why does this only work for uppercase? how about lowercase? A1: live answered Q: The else statement is just to make sure that non capital letters aren A1: live answered A2: live answered Q: Can you cast an int so that it becomes a char? A1: yes A2: yes Q: The else statement is just to make sure that non capital letters aren't altered, right? A1: live answered Q: Would decrypting this be a problem because we don't know which character was wrapped (i.e. -26)? A1: You would do the same modular artihmetic on decrypt (wrapover) Q: What is a control character? And what is a printing character? A1: live answered Q: Just a style question, but why aren't the cctype functions in camelCase? A1: standard C++ conventions are snake case, terse abbreviations, our stanford style is camelCase and more verbose - we think better for learners Q: would s[i] = toupper(s[i]); do the same thing as toupper(s[i]) strings are mutable? A1: these functions operate on a single char and it is passed by value. toupper(s[i]) would not change s[i] Q: why does the length function go after the parameter instead of putting the parameter in the parentheses? A1: That is the c/c++ style of getting the attribute. Python is different Q: You said cctype is a standard library. Which standard libraries are we allowed to use? A1: We'll be specific about the standard libraries you need to use. Q: Will the assignment 1 be based on lectures this week. A1: Yes, Assignment 1 will cover content from this week's lecture + Monday's lecture Q: Not sure if you guys are aware of this, but can you audit CS106M? A1: Sorry, no Q: Do strings and characters need to be assigned to variables before using built-in functions? Can I do reverse("string") or toupper("a") ? A1: Yes, you can call those functions on string literals Q: Am I allowed to ask CompSci questions unrelated to today's lecture? A1: We'd prefer to keep lecture questions on topic to that days lecture/ If you have questions beyond the scope of the class, I would recommend dropping by instructor OHs Q: Why are the methods not in the form of the methods from ? Like uses form of str.at() whereas is like isalnum(x) (aka no dot).</i> A1: The string methods are defined on the string object, which is why they're called in the s.function() format. The functions defined in the cctype library do not belong to a certain object are standalone functions that take in a paramater as input and produce output Q: I might've missed this but why did we cast plainText.length() into an int in slide 6 but not anywhere else? A1: because it was a non-int type being compared to an int Q: could you briefly go over what a size_t is A1: A number that cannot hold negative values Q: right but why didn't we cast it anywhere else? A1: that's the only place that we get the length I believe Q: are there any other things besides length that require typecasting? A1: live answered Q: whats the difference between unsigned and size_t A1: live answered Q: is all (or most) c code runnable as c++. E.g can I make strings as char* etc A1: Yes, all C code can be compiled by a C++ compiler (I believe). However, you should not use char* for strings in this class A2: Yes, an intentional design goal of C++ was to be a superset of C (with very very few exceptions) Q: is plaintext.length() called every single time we go through the loop? or is it just called once at the beginning and then saved? because if the length of plaintext changes in the loop then this could affect the results A1: It's called every time the condition is evaluated Q: Is size_t defined as the biggest possible size? A1: live answered Q: The way (int) works is to make str as number, when should we do that? Still confused. A1: live answered A2: live answered Q: when's the next assignment coming out? A1: tomorrow early afternoon Q: When we use += for strings, will a new string be created or will it modify the original string (mutated)? A1: live answered Q: Doesnt't adding the (int) to correct the integer type change the actual value of the integer we're dealing with? instead of actually getting the length of the string we will get its ASCII code no? A1: live answered Q: Does the length of a string include the null character? A1: live answered Q: is there auto casting? A1: live answered Q: So could we use cctype toupper function to make Ceaser Cipher work on any string regardless of case? A1: yes, that function would be usefukl if you wanted to make this program case-insensitive Q: Can functions in the "strlib.h" Stanford library be used in homework assignments without explaining what they're doing? A1: yes Q: Can we use unicode too, in place of ASCII? A1: live answered Q: just to make sure, plainText[i] is the numerical value of the character right? A1: no it's a char Q: is there a page in the text about size_t I could look at? A1: I don't know off the top of my head, but the textbook has an index that you can check out
http://cs106b.stanford.edu/lectures/02-cpp/qa.html
Q: Good Morning, When will the assignement 1 will distributed? A1: Assignment 1 will be released on Saturday and will be due the following Friday Q: I wasn't here on Monday - besides completing assignment 0 is there anything else I need to do/know? A1: Make sure to sign up for a section open tomorrow at 5pm. Q: We're muted by default right? A1: live answered Q: How do you reccomend that we take notes for this course? For instance, in a document or in a program file? A1: Persona preference? Whatever works best for you. I personally like writing on paper, as this act causes the info to register more in my brain more than typing. YMMV A2: Whatever works best for you! A program file might be helpful but keep in mind not all notes will be code based Q: After assignmen 0, do we have to use QtCreator to code our project or can you just use gcc/gdb/make in the commandline? Obviously if we go to office hours QtCreator is expected, I'm just asking for my own personal use. A1: The CS106 projects are all configured to build within Qt (using its build system, qmake). Underneath it is using make, gcc/clang, gdb/lldb, etc) but you won't directly interact with those tools Q: How do you create and set up a new project file in Qt Creator? A1: You can just copy the .pro file from any CS106 project into a folder of .cpp files and voila, you have a new project. A2: project such as Welcome, Assign0, lecture example, etc. There is also a blank sample project on web at cs106b.stanford.edu/qt/SampleProject.zip Q: I submitted Assignment 0 twice :(, which one would be considered? A1: The most recent one Q: So are all these libraries that we're using? And are these constants that we A1: Yes, you will eventually use these same libraries Q: Is it possible to include c++ scripts that we create in other c++ files through this #include statement? A1: Yes, #include is used to import code /interface from other files into the current file Q: So are all these libraries that we're using? And are these constants that we will apply to every program? A1: Yes Q: How can we check whether we've properly submitted assignment 0? I don't think I received a copy of my form. A1: We have your submission. Q: if you #include your own .h file, where does it have to be for it to be able to be read by all-examples.cpp? A1: Easiest is to have both files in same folder. There is also a more complex way to control the search path Q: Do you always have to build your program before running it? A1: If you don't build then QT will automatically build for you when you try to run Q: So we would reference the actual .cpp file or the compiled code? Like if I created the C++ file and wanted to use it in another C++ file that I was developing? A1: You generally #include a header file(name ends in .h) which doesn't contain code, just declarations. This makes the features visible to the other file. The code is in a file named .cpp that is companion to the .h Q: Do we not need a namespace for the Stanford library? A1: namespace isn't necessary, it just makes code cleaner A2: No, the features from the Stanford library are in the global namesapce Q: Is it possible to use the curly brackets in the following way ot it's a bad style? int main() { ... return 0; } A1: Either way is fine, as long as you stay consistent through all your code. Q: Does main always need to return something? A1: Yes, in C++ A2: Yes, it has to return an int (C++ rules) Q: are java methods the same as c++ functions? A1: Basically, yes Q: '@Julie, when you say global namespace, do you mean std or something already integrated into Qt Creator? A1: Global namespace is the catch-all place for C++ functions to be defined, not specific to Qt, this is a C++ language feature Q: how is int main different from int a? is main an integer function? A1: Main is a function that returns an int. int a is a variable of type int Q: do .h header files have to be in the same directory as the project or the cpp file? A1: That is the easiest way to arrange it, yes Q: is there a reason char is single quotes? A1: That is the C++ convention to define a char instead of string Q: can you set a char variable to more than 1 letter or would you need to use a string type? A1: A char type variable can only hold a single character. Storing multiple characters requires a string Q: does main have to be int? A1: Yes, that is convention/required Q: what is float? A1: a number with a decimal. For the purposes of this class it's the same as a double Q: Im getting an error when I try to include the console.h file: "No such file or directory" what exactly could be going on? A1: This sounds like you did not install the CS106 speciic components during the install. Can you go back to the Qt install instructions and redo that step (download CS106.zip, build, run) Q: What happens if you try to set the value of a char equal to a number or a string? A1: You will get an error if you try to set it to a string. A number might work based on ASCII code Q: Why is string a different color A1: That's just syntax highlighting provided by Qt Creator to help string literals standout from other things Q: what happens if we do a=a*1.0. error? A1: live answered Q: can you use a method to change variable types like in java? A1: live answered Q: If you say a = 1.5, will it still run and coerce 1.5 into 1? A1: live answered Q: Is string a reference type in cpp like it is in Java or is it more complex than that? I noticed string isn't capitalized like a reference type A1: There are reference types in C++ but they're designated differently than in Java. We'll cover references at some point later this week or early next week. Q: Is the Stanford library that we are using restrictive since it is not used in industry? A1: The Stanford library is exclusively used for educational pruposes, yes. Q: so would the .h file be be under "Sources" in this example? A1: The .h files are listed under Headers Q: whats the difference between a float and a double? A1: They differ in how much decimal precision they can represent (double is twice as precise as float) Q: why is there a ; after every variable creation? A1: There is a semicolon to terminate every single line of code in C++. Q: can you say: int a = 5; double a = 5;? or will that also give a redefinition error A1: Yes, there can only be one variable with a given name Q: how is main an integer ? A1: Main isn't an int, it returns an int. Every function in C++ is either void or returns a given type Q: If we have functions, do we always need a .h file to declare them? A1: You will need a .h to share those functions outside of hte file they were defined in, but if the functions are only used within the one file, you won't need a separate header for them Q: Could we do something like float a = 5 on line 10 and C++ would convert 5 to 5.0 under the hood? A1: Correct! Q: why might one use a float instead of a double? A1: Best practice is to just use double by default. You would only bother with float if you were severely space-constrainted and could tolerate lower precision. Q: Libraries in angled brackets (<>) must be pre-defined by the C++ library right? A1: Yes Q: Do you have to initialize all values in the main function? A1: No, values can be defined in any function as long as they remain in scope Q: I have moved the file 'CS106.pro' to a folder I created called examples, which is the same folder my file is in. Why am I getting an error for #include console.h? A1: Your projects use the .pro you'll find in the projets for Welcome, Assign0, etc. (the CS106.pro is for the libraries themselves) Q: when I type #include, it said error: 'iostream' file not found</i> A1: This sounds like possibly install issue? Q: So won't I be able to do the same stuff that I am learning here, outside the class? A1: You will, most of this stuff in this class translates to real life. You may see some syntactical changes when not using the Stanford library however. Q: Do we use single quotes or double quotes for characters? A1: chars use single quotes Q: how similar is c++ to java? A1: They share a fair number of syntactical similarities, though there are certainly important underlying differences that we'll cover throughout the quarter. A2: Quite similar in syntax, but rather different under the hood Q: Should we create a new project for each class/lecture? Or should we try to keep all our files in one project A1: Separate projects is probably simpler to manage Q: Why/when should we put a semicolon at the end of a line? A1: You must put a semicolon at the end of every single line of code. There are additional places where we use semicolons as delimiters (like in for loops) which we will discuss later today/on Friday. A2: Put a semicolon at the end of every line that is in a function and that doesn't have a curly brace on it. It tells the computer that the current line is over Q: If doubles are more accurate than floats, what is the advantage to using floats over doubles? I read that floats hold less memory, but does that stand true if the float value is equal to the double value? (e.g. float 3.0 vs double 3.0) A1: live answered Q: Should we make all new projects/files in the same folder as CS106? A1: Most files for this class will be provided to you! Q: Will assignments be available ahead of time or is there a specific date each week they will be released? A1: We release next assignment on due date of previous Q: do you have to put endl? what would happen if you don't? A1: You don't have to. It just appends a new line character to the end Q: Can our variable names include underscores i.e. "The_Answer" or does it have to be one word? A1: We usually avoid use of underscores of variable names in this class. Our standard convention is to use camelCase to name variables with multiple words Q: can we use C-style print settings (e.g., "%0.5f") with cout? A1: I don't think so. But you can use printf in C++ A2: No, you cannot combine the two, but you cna use printf directly Q: Where else is the operator used? Does it just pass an argument into a function or is it doing something else? A1: It is also used in something called overloading, which you'll learn about later Q: no need for a + in between the things we are printing? A1: Not if you use Q: So concatenation happens by just using A1: Sort of, the operator that "inserts" a value into the output stream Q: Is and only used in for io? or will we see those elsewhere? A1: Those two operators are exclusively used for io in the context of this class (they are generally used to process streams, but we won't really see streams outside of cout in this class) Q: can we also concatanate strings using +? A1: Yes. Q: also used in bitwise operations A1: yes Q: Is endl equivalent to "\n" A1: yup! Q: How did Chris run the code, he did not press the button A1: Hot key, command-r A2: He may have a keyboard shortcut confugured to do build + run. I think command-r does this on mac Q: Can you print integers directly, such as count ? A1: Yes Q: what are the advantages of using endl instead of "\n"? A1: More portable, surprisingly the end of line character is not standardized ... Q: '@Paris QtCreator (like other IDE's) have keyboard shortcuts that you can assign at your convenience :) Q: I run the zip in web and it works, what should I do now? A1: I'm sorry, but I don't have the context for this. Can you clarify your question? A2: Is this for downloading the CS106 library? A3: I assume this means you were able to complete A0 properly? If so, try downloading this project and writing your code form lecture there: http://web.stanford.edu/class/cs106b/qt/SampleProject.zip Q: If there is no main() function, the program won't run? A1: It won't build, no. Q: What would be the main reason to prefer a "do-while" loop instead of a simple while loop? A1: live answered Q: do less than or equal to signs exist in C++? A1: yes! <= Q: Could we put the entire while loop on one line-curly brackets and all? A1: yes A2: Yes, but this would be very bad style! Q: does c++ use camel for variable names A1: We do in this class! it's a style choice A2: Yes, in this class, we will use camelCase for variable naming. Q: If i was let's say equal to double i=4.6354 would main be double main()? A1: by C++ rules, the main has to return int type A2: no, you can have variables of different types in one function. int main indicates return type Q: why is #include "console.h" legal here when console.h is not in the Headers folder? A1: This is one of the library files that got installed when you installed the Stanford libraries! It's on your computer, but just hidden from immediate view Q: where do we need to put our projects if we want them to be able to use the Stanford library? I ran the CS106 project but console.h is still giving a "file not found" error. A1: Grab blank sample project on web at cs106b.stanford.edu/qt/SampleProject.zip, use this one as template A2: There's no specific place you need to put projects. Were you able to successfully complete A0? If so, try using this blank project for writing sample code: http://web.stanford.edu/class/cs106b/qt/SampleProject.zip Q: could you declare the variable outside the for loop and then just leave it blank before the first semicolon? A1: yes that is possible Q: can you put a semicolon after i++/ the update statement? A1: I don't think this would compile Q: are the variables declared inside the initialization statement accessible inside the loop? outside the loop? A1: Accessible inside the loop, but not outside the loop Q: Is it possible to elaborate on Do in while loops? Chris mentioned smth like use Do if you want to run at least one... Thank you! A1: The only difference betwen while and do-whilte is whether the test for continuing to loop is tested at the "bottom" of the loop or the "top". By far, most loops will be for or while, do-while is rare Q: if i=0, isn't it always less than 3? and would the loop go through if int i=1? A1: Note the i++ in increment step - i goes up by one each loop iteration Q: In what order does std::cout evaluate its arguments? A1: Things will be printed from left to right Q: When we create a new project, how do we make sure that we include the stanford libraries? A1: you #include the relevant files Q: Question - does c++ change the value of i depending on what happens in the function, or will it definitely run this 3 times. For example, if within the for loop I wrote i=i+1, would this run 3 times or only 2? Q: what does i++ mean? A1: live answered Q: Does it check the condition before the first execution? A1: yes A2: Yes, so it is possible for the for loop to never run if the condition evaluates to false right after the initialization statement. Q: Is console.h some global library then? accessible by all projects made on QT-creator? A1: It is part of our Stanford-specific libraries Q: why didn't #include "all-examples.h" at the beginning? A1: We haven't declared any funciton prototypes yet, so there's no need for a custom header file yet A2: I think Chris was just using that header file to demosntrate how to use #include Q: does the for loop have to use a new var in the init statement? can you use a var that you used/declared in a previous part of the program? A1: live answered Q: why the left } always on a new line A1: Stylistica convention that makes the code better organized and easier to read A2: it's stylistic. It let's you know where the proper indentation should be Q: If you wanted to increment i by two instead, how would that look? A1: i+=2 Q: sorry right } Q: can do you i < = 3 with the same syntax as Java? A1: yes Q: Oh okay! I remember following the instructions step by step but i think i may have missed something! thank you Q: '@paris Li -> its a style choice, It could be on the same line Q: does c++ change the value of i depending on what happens in the function, or will it definitely run this 3 times. For example, if within the for loop I wrote i=i+1, would this run 3 times or only 2? and the program would then print only 0 and 2? A1: it would only run 2 times! Q: '@Chase do we create a new project within the CS106 folder that we downloaded and then unzip instead of creating a project outside that folder? A1: If you want to create new projects, use this as a template: http://web.stanford.edu/class/cs106b/qt/SampleProject.zip No need to do anything with CS106.zip after initial library installation A2: ^^ also for most projects in the class we will give you starter code to download Q: How does the compiler know where the Stanford console.h file is? A1: Specified in the .pro file which is bundled as part of the project Q: Do we must write our code under the same file contain library file? A1: I don't quite understand your question, can you clarify? Q: can we change loopVar within the loop? A1: yes, but it makes things confusing so be careful with this Q: I see Chris is still indenting even though the indentations aren't functionally important. Is it stylistically better that we still indent our functions? A1: Yes!! Thank you for asking! A2: Yes it is stylistically better and makes code easier to read. A3: Yes, indentation is very, very important when it comes to style and readability fo your code. This is one of the components your assignments will be graded on this quarter Q: Do you have style preferences for use of curly brackets in the case that a control flow statement's content is a singular line? For example, I had a prof in a previous C++ based class who preferred we used curly brackets only if the content of the decision-making statement required more than 1 step (spans more than 1 line) and otherwise, indent and include the procedure of the loop in the line below without brackets just end the single line with the semicolon like: if (i < 5) cout is less than 5" instead of if (i < 5) { cout is less than 5" }</i> A1: We prefer that you use braces aways - less error-prone. See https://web.stanford.edu/class/cs106b/resources/style_guide.html for more tips Q: By declaring a variable inside of a loop, does that not try to redeclare every iteration? (ie. "int insideVar = " as opposed to declaring outside of the loop and just saying "insideVar =" A1: it does redeclare in every iteration Q: What is "using namespace std"? A1: if you don't include it you have to type std in a lot of places. for example you would type std::cout instead of just cout. including this gets rid of the need to type std:: Q: Does the for loop increment happen at start or end of the loop? A1: At the end of the loop (first increment won't happen until body of loop has happened once) Q: so earlier we could only initialize a variable once. However is it possible if you use a loop like in this example? A1: The initialization step of the loop still only happens one time Q: Since variables belong to their block could you call insideVar from inside forloop A1: yes Q: Do names always have to be in camelcase? A1: live answered A2: It's a stylistic choice. For this class this is the style we will use Q: Is it acceptable to use first_last format for naming variables and functions? A1: live answered Q: is it possible to get the variable from within a loop? A1: A varibale declared in a loop will still persist after the loop, but you need to be sure that the loop ran. This is not the same for if statements however Q: Without using namespace std, would we have to type std:: only in front of the functions in the standard library (not in front of functions in io or string or console.h)? A1: yes, that is correct. you have to say std::string instead of string, which gets annoying quick Q: Does scoping result from creating the stacks? So like the for loop's variables are on a different stack call? A1: There is a separate stack frame associated with each function call, but there is also a division of those variables into scopes (visibility) within the function too Q: including blank header files should still be legal right? Since we are just pasting nothing into the file. So why didn't "all-examples.h" give an error? Q: why does scoping occur? A1: live answered Q: ^^ Than main's stack call. Hence main doesn't have access to the loop's variables? Q: Correction: including blank header files should still be legal right? Since we are just pasting nothing into the file. So why did including "all-examples.h" give an error? A1: I'm not sure, hard to tell what was happening there. Generally including a blank header file would be legal (but useless) Q: are there situations where changing a variable inside the for loop will only change the variable in the inside scope, but not the outside scope? A1: live answered Q: Can you reinitialise a variable outside a scope? e.g. for (....){ int a =5 }</i> A1: yes! Q: char a=a Q: Can we always define varibles outside, and assign values inside the loop? A1: yes Q: Can a variable with a smaller scope hide a var with the same name? A1: live answered Q: So if the variable is declared outside of the loop and then manipulated inside a loop, the changes will remain when you leave that loop? Like that variable won't disappear? A1: Yes Q: Sorry my english is bad, is there a help section after class? A1: Yes, Chris is having office hours from 11:30-1:30 if you're still running into Qt issues A2: Yes, please come! Q: what's camel case? C++'s version of snake case? A1: Yes A2: Camel case is a variable naming strategy where the first word alwats starts witha lower case letter and all remaining words start with upper case letters like oneTwoThree instead of one_two_three Q: So in that example if we printed insideVar outside the loop it would be 7? A1: I'm not sure exactly which example is being reference, but you would not have access to insideVar outside the loop because its scope is only inside the loop Q: '@Kheli camel case is where you type two words like this -> twoWords Q: Would declaring insideVar within the for loop save memory/improve run times? What's the reason for scoping it/its advantages? A1: Any runtime changes would be negligible. However, this could change functionality so please watch out for this A2: No change in memory, but it is good practice to limit the visibliity to what is needed and no larger to avoid errors Q: Inside the scope in this case is also inside the for-loop curly brackets? So we won't be able to use "insideVar" ourside of for-loop curly brackets, is it correct? A1: Correct Q: a variable with a global scope can be temporarly changed in a function, right? isn't it changed by something called passed by value? can you verify that? A1: Global variables are generally considered to be very bad style, so we won't be working with them this quarter. We'll talk about functions and pass-by-value on Friday I believe Q: Thank you, will do. Q: will we talk about when we should/shouldn't define our variables globally A1: Most times you will want to avoid global variables in this class as it is considered bad style generally A2: No global variables, please! See https://web.stanford.edu/class/cs106b/resources/style_guide.html for more style tips A3: We will never use global variables in this course is generally considered to be bad style, at least for the applicartions we have in this class Q: can you clarify a=b vs a==b? A1: live answered Q: would ?: be considered a boolean operator? expression? A1: Sometimes called the "ternary expression" Q: do you need the endl if you are only printing one line of code? A1: No Q: why does the main function need to return 0? A1: C++ rules require that main return an int, used as a "status code" A2: Established C++ convention carried over from C Q: are the curly braces needed if there is only one line after the if(a==b)? A1: No Q: Does it matter if we write variables like firstVariable or first_variable? Does this class have a preference? A1: Yes, we are camelCase. See https://web.stanford.edu/class/cs106b/resources/style_guide.html for more style tips Q: '@Ryan, thank you! Q: Are there triple === in C++? A1: No A2: No Q: If I'm not wrong, isn't there something like a === b as well? A1: No, not in C++ Q: '@Kheli you're welcome! Q: is 0=="0" true? A1: No Q: This is going back in the lecture a bit, but if I initialized a with "int a = 5;", but later in the program, I want to use "a" as a double, how do I "delete" the previous initialization? A1: live answered Q: is 1==true true? A1: live answered Q: when comparing strings do we use something similar to .equal() A1: No you can use == to compare strings in C++ Q: difference between else if and elif, syntax wise? A1: elif doesn't exist in C++, you must use else if Q: when you are returning 0 at the end of the main function, what is that 0 being returned to? A1: To the operating system. A return of 0 says "program executed fine and exited normally" Q: In C++ can you not use squiggly brackets if it is only one line of code like in Java? A1: yes Q: 679928 Q: what does the .pro file do in QT? A1: it contains all of the information needed for a project A2: It configures the build settings Q: Is it bad practice to do the last statement in an if/elseif/else set as an elseif a>b just for ease of understanding purposes? A1: no, that's fine Q: can we chain equalities like a == b == c? A1: no, you'd do a== b && b== c A2: That construct is legal, but doesn't do what you intend, watch out! Q: what are the red and green color on the line number A1: it indicates changed lines Q: What happens if you just type in a single & ot |? A1: You should avoid those in this class. They do bitwise operations, which you'll learn about in CS107 A2: it's called a bitwise operator. This is 107 content Q: I can't see on the style guide a preference or reason to prefer either. If we have a large number of conditions, is there a preference between using switch cases or using if/else if iterations/else control statements? A1: live answered A2: switch applies only in the particular case that you have integer value cases, so mostly you'll use if/else if Q: So the only reason not to use (and) or (or) is because stylistically this class prefers it? Do we get style marks off for not conforming A1: You can use either for this class. There are other style rulese we are more prescriptive about, see https://web.stanford.edu/class/cs106b/resources/style_guide.html Q: Is it a bitwise operator? A1: yes Q: what does & mean A1: this is 107 material A2: It is a bitwise operator, which you'll leanr about in CS107. Not necessary for this class. Q: Do integers in C++ have a true/false value? A1: We use bool type for true/false (but yes non-zero ints are treated as true, and 0 equates to false) Q: When I do "else (a == b && b == c){}" it says expected ; after expression - where would the semicolon go? A1: you would use else if () {} and the semicolon goes on any line inside of the curly braces Q: where do we find the link to office hours for CS106B? A1: https://web.stanford.edu/class/cs106b/restricted/zoom_info A2: Quick link on right side of course home page Q: can you do if(... && .... &&) A1: Yes Q: Can you run through the process of creating a new project? Should we copy and paste the sample project, or should we go File > New File/Project? If so then which settings should we pick to set it up to work with the CS106 library. Thanks! A1: Copy this folder, and open the .pro file. That should be all you need to do. http://web.stanford.edu/class/cs106b/qt/SampleProject.zip Q: Julie, what's the best way I can reach you if I want to discuss non-CS106B related topics? A1: live answered Q: '@Julie, thank you! Will use camelCase. Is C++ technically capable of using snake_case? A1: Yes, C++ itself doesn't really care A2: Yes, C++ itself agnostic, our class has its own preferences Q: When I tried to open Assignment 0 in Qt, it said I could not open it because the file path contained an invalid characer, which was ~. However, the ~ was part of the file path produced by iCloud Drive, which is where I store my assignments. Is it possible to work around this or will I have to always store my assignments locally? A1: live answered Q: General question, how big is the class? A1: live answered Q: Awesome, thanks! Q: Is there a way I can confirm my Assignment 0 google form response was received? A1: live answered A2: email chase and nick Q: Will Friday's lecture start with a new slide deck? Or will we start Friday's lecture by finishing up this slide deck? A1: live answered Q: '@nick so i just copy it for all my projects? A1: Yes A2: For any personal projects you want to use. For section/assignments we will provide specific starter code. Q: Is there an easy way to extract the makefile from the .pro file? I REALLY dislike IDEs and would greatly prefer Vim + make + gcc + gdb on the command line A1: live answered Q: Would it likewise cause errors to sinc program files with google drive? A1: Most likely yes. I'd reccommend dowloading locally Q: can you use "return" in different ways? can you return a string or integer? A1: yes! Q: Is the code that was written in the lecture going to be posted on the website? A1: Yes, Chris usually posts the lecture code on the lecture pages. Q: After this class, should I take CS 107 or CS 103? A1: up to you! 107 is more code and 103 is more theory A2: We'll talk about this at the end of the quarter, but you can go to either. It depends on what your goal are, but the most common path is to 107. Q: Can someone like new who is very good(learned composition and arrays) in Java do well in CS106B? A1: live answered Q: if you define a variable in main and then call a function from main, will that variable be visible in the function or do you have to use parameters/arguments A1: you have to pass the variable as a parameter Q: Could you explain how to use the ReferenceExamples file to code our own projects? A1: live answered Q: Going back to when we were talking about typed variables - do we get an error when re-typing the same variable (trying int a = 5 and then int a = 12) because it tries to create a new int object variable/what's the reason for the error? A1: It's an error because you cannot decalre a variable with the same name twice int he same scope Q: I'm confused on what the " #include " functions as. I know you mentioned libraries but I am confused to what that means. A1: live answered Q: Does this cause confusion when I take Java and C++ at the same time, since I just learned Python before? A1: I don't think this would cause confusion as long as you have an appropriate background for this class Q: How do u open a blank doc in qt creator in order to test different things? A1: live answered Q: Could someone further explain the whole std and namespace thing? A1: live answered Q: if you declare int i = 0 outside the for loop, does your for loop say for( i < 10; i++){//code} or for(i = 0; i < 10; i++){//code} A1: live answered Q: is there a lot of content in the textbook readings that are not covered in lecture (that we are responsible for)? A1: Everything that you need to know will be discussed in lecture A2: No, the textbook readings are supplementary Q: How long should Assignment zero typically take? I just signed up today A1: 30 mins or so, its quick Q: Which is the #include statement to import the Stanford library? A1: #include "console.h" is referencing a specific part of the Stanford library A2: There is no #include to include the entire library Q: why was QT creator chosen? A1: Cross-platform compatiblity Q: Why don't we need semicolons for the #include statements? A1: That's just part of the syntax of code starting with # do not end with a semicolon Q: where do you fine the sample project template? A1: http://web.stanford.edu/class/cs106b/qt/SampleProject.zip Q: how does the compiler find the cs106b library? A1: Configured by the .pro file Q: Is the specific syntax for printing, or does it have a more general meaning? A1: It has other meanings but we won't cover those in this class (it is used as a general stream operator) Q: Do you use access modifiers on C++ functions like you would on Java methods A1: Only on member functions within a class, not on global functions Q: Is assignment 0 the only required assignment for this week? A1: yes A2: yes Q: Thanks! Q: Why is a debug folder created when debugging? Can we delete these? A1: live answered
http://cs106b.stanford.edu/qt/recommended-settings.html
Below are our suggested configuration settings for Qt Creator. You are not required to adopt these settings, but we recommend them for a more pleasant experience. Access the settings for Qt Creator from the top menu bar: on Windows or Linux, menu item is Tools -> Options... on Mac, menu item is Qt Creator -> Preferences... Build & Run settings We recommend checking the following boxes: Save all files before build This saves your code files before you compile or run your project. Compile Output: Open pane when building Display information about the compilation process when your project is being built. Application Output: Open pane on output when running always Display your program's output in a pane at the bottom of window. Normally you can see the output in the popup graphical console and don't need this bottom pane, but if your window crashes, the bottom output can be helpful to figure out what went wrong. Application Output: Clear old output on a new run This clears out previous output from the output pane. Debugger settings Debugger font size follows main editor This will make your debugger font size grow if the main text editor font size is enlarged. Switch to previous mode on debugger exit This closes unneeded debugger panes when the debugger is no longer running. Analyzer settings Qt Creator has a feature called the "Clang Code Model" that highlights errors and gives code warnings as you type. Neat! However, the feature is a bit too picky, and it spits out a lot of warnings about code that is just fine. To make the feature a bit less picky, we'll change its default flags and settings to more closely match the CS 106B style guide. In Qt Creator's preferences, go to the Analyzer area, then in the initial Clang Tools tab, find the area labeled "Default Clang-Tidy and Clazy checks" and click on it. Now a "Diagnostic Configurations" window will pop up with several entries in it. Click "Copy..." This will pop up a small window asking for your configuration's name. Name your new configuration something like "CS 106B settings" and press Enter. You should now see your configuration in the Diagnostic Configurations list. Make sure it is selected. Now, below, under the "Clang Warnings" tab, replace the existing text with this text: -Wall -Wextra -Wno-unused-parameter -Wmissing-field-initializers -Wno-old-style-cast -Wno-sign-compare -Wno-sign-conversion -Wno-unused-const-variable Then click OK. Now the unwanted warnings should go away. If your project still isn't using the new settings, in the left bar of Qt Creator, click "Projects", then click "Clang Code Model", then at right, change the drop-down from "Use Global Settings" to "Use Customized Settings." If you ever decide that you want to turn off the Code Model feature entirely, in Qt Creator click: Help -> About Plugins ... -> C++, then uncheck "ClangCodeModel".
http://cs106b.stanford.edu/assessments/refsheet.html
We often distribute a reference sheet during exams that gives the syntax of common operations so that students do not need to memorize these details. Below is a sample such reference sheet. You may want to have this on hand when practicing or taking an exam. This list isn't comprehensive - for that, read the header files (available in Qt Creator) or view the online docs for standard C++ functions or the Stanford C++ libraries. Standard string s.at(index) or s[index] // access single char s + text OR s += text s.substr(start) // return new substring s.substr(start, length) s.find(key) // returns index or string::npos s.erase(index, length) // erase, insert, replace destructively modify s s.insert(index, text) s.replace(index, length, text) for (char ch: s) { ... } // chars visited in order Stanford strlib.h if (equalsIgnoreCase(s1, s2)) { ... } if (endsWith(str, suffix)) { ... } if (startsWith(str, prefix)) { ... } if (stringContains(str, key) { ... } integerToString(int) stringToInteger(str) realToString(double) stringToReal(str) stringSplit(str, delimiter) // returns Vector<string> of tokens toLowerCase(str) toUpperCase(str) trim(str) // remove leading/trailing whitespace Vector Vector<T> v = {elem, elem, ... , elem}; v.add(elem) OR v += elem v.clear() v.get(index) OR v[index] v.insert(index, elem) if (v.isEmpty()) { ... } v.remove(index) v.set(index, elem) OR v[index] = elem v.size() for (T elem: v) { ... } // visited in order of index Grid Grid<T> g(nRows, nCols); int numCells = grid.numRows() * grid.numCols() if (grid.inBounds(row, col)) { ...} grid[row][col] = value for (T elem: grid) { ... } // visited left-to-right, top-to-bottom GridLocation GridLocation loc = {row, col}; grid[loc] = value if (grid.inBounds(loc)) { ... } GridLocation neighbor = {loc.row + 1, loc.col - 1}; if (loc == neighbor) { ... } Stack Stack<T> s = {bottom, ... , top}; s.push(elem) s.peek() // Look at top s.pop() // Removes top s.size() if (s.isEmpty()) { ... } s.clear() // no iterator, no direct access to elements other than top Queue Queue<T> q = {front, ... , back}; q.enqueue(elem) q.peek() // Look at front q.dequeue() // Removes front q.size() if (q.isEmpty()) { ... } q.clear() // no iterator, no direct access to elements other than front Set Set<T> s = {elem1, elem2, ... , elemN}; if (s.contains(elem)) { ... } s.add(elem) s + elem; s + set2; // union s.remove(elem) s - elem; s - set2; // difference intersectSet = s1 * s2; s.size() if (s.isEmpty()) { ... } if (s.isSubsetOf(s2)) { ... } s.clear() // Visits elements in sorted order for (T elem: set) { ... } Map Map<K, V> m = { { key1, val1}, ... {keyN, valN } }; m.put(key, value) OR m[key] = value m.get(key) OR m[key] // bracket form auto-inserts default value if not present if (m.containsKey(key)) { ... } m.size() if (m.isEmpty()) { ... } m.remove(key) m.clear() Vector<K> keys = m.keys(); // Visits keys in sorted order for (K key: m) { ... } Lexicon Lexicon lex(filename); if (lex.contains(word)) { ... } if (lex.containsPrefix(prefix)) { ... }
http://cs106b.stanford.edu/schedule.html
This is a preview of our planned schedule. We will update this schedule as we go. This page should faithfully describe the past, but it won't always accurately predict the future. Live lectures on Zoom MWF 10am PT, recordings posted to Canvas for later asynchronous viewing 1 Sep 14 Welcome! Readings: Syllabus Sep 16 C++ Fundamentals Text Ch. 1, 2.1-2.4 Sep 18 Strings Text Ch. 3, strlib.h Assignment 0. due Sep 18 2 Sep 21 Vectors and Grids Text 5.1, Vector, Grid Sep 23 Stacks and Queues Text 5.2, 5.3, Stack, Queue Sep 25 Sets and Maps Text 5.4, 5.5, 5.6, Set, Map Section 1. Assignment 1. due Sep 25 3 Sep 28 Big O and Asymptotic Analysis Text 10.1, 10.2 Sep 30 Introduction to Recursion Text Ch. 7 Oct 2 Fractals Text 8.4 Section 2. Assignment 2. due Oct 2 4 Oct 5 Procedural Recursion Text 8.1, 8.2, 8.3 Oct 7 Backtracking 1 Text 9.1 Oct 9 Backtracking 2 Section 3. Assignment 3. due Oct 9 5 Oct 12 C++ Classes Text 6.1,6.2,6.3 Oct 14 Dynamic Memory Text 12.1,12.3 Oct 16 Memory and Pointers Text Ch. 11 Section 4. Assignment 4. due Oct 16 6 Oct 19 Implementing VectorInt Text 14.4, Vector Oct 21 Heaps Text 14.3,16.5 Oct 23 Sorting Text 10.1,10.3,10.5 Section 5. 7 Oct 26 Linked Lists 1 Text 12.2 Oct 28 Linked Lists 2 Oct 30 Trees Text 16.1 Section 6. Assignment 5. due Oct 28 8 Nov 2 Binary Search Trees Text 16.2 Nov 4 Huffman Coding [Huffman handout][huffman_background] Nov 6 Hashing Text 15.3,15.4 Section 7. Assignment 6. due Nov 4 9 Nov 9 Graphs Text 18.1,18.4 Nov 11 Graph Shortest Path Algorithms Text 18.6 Nov 13 Esoteric Data Structures Section 8. Assignment 7. due Nov 11 10 Nov 16 /lectures/28-wrap/ Nov 18 TBA Nov 20 TBA Section 9.
http://cs106b.stanford.edu/assignments/2-adt/searchengine.html
An introduction to search engines Search engines are one of the most influential developments of the modern internet age, having completely revolutionized the way that people use and interact with the web. What was once an intractable jumble of data with no semblance of organization has been transformed into an easily searchable repository of information. For this part of the assignment, you will recreate this phenomenal technological development by using the Map and Set ADTs to build a document search engine that can find matching pages for a user's query with lighting-fast response time. This is a simplified version of the technology underpinning Spotlight, Google, Bing, and every other modern search engine that you encounter in your day-to-day internet use. Want to see the power of search right at your finger tips? Click Search in the top-right of our website navigation bar and search for the phrase "easter egg" and see what you instantly find hidden deep in the recesses of the course website... In our version of the search engine, each web page has a URL ("Uniform Resource Locator") that serves as its unique id and a string containing the body text of the page. The magic of search is enabled by pre-processing the body text of each page and storing the contents into a data structure optimized for fast retrieval of pages matching the search query. You will first write functions that process the body text and populate the data structure. Next you'll implement the function to search for pages matching a search query. Finally, you will write a console program that allows the user to enter many search queries and retrieve the matching web pages. Put all together, you will have built your own mini search engine! Understanding the web page data We have harvested the body text from the pages of our course website into a database file to use as input to your search engine. The format of the database file is as follows: The lines of the file are grouped into pairs with the following structure: The first line of a pair is a page URL. The second line of a pair is the body text of that page, with all newlines removed (basically text of the page in a single string). The first two lines in the file form the first pair. The third and fourth lines form another pair, the fifth and sixth another, and so on, with alternating lines of page URL and page content. To view an example database, open the file tiny.txt or website.txt in the folder Other files/res of the starter project. Using an inverted index for searching The key to enabling efficient search of a large data structure comes down to how we structure and store the data. A poor choice in data structures would make search painfully slow, while a wise arrangement can allow search to be near instantaneous. To begin with, let's consider the index of a book. For example, when you look in the index of the CS106B textbook, one of the entries is the keyword "Internet" and two page numbers, 18 and 821. The word internet occurs on page number 18 and again on page number 821. A book's index is an example of an inverted index, where you have a word in mind and you can find the page number it is listed on (a book's index does not usually include every instance of the word on all pages but is instead curated to give you the best matches). In other words, an inverted index creates a mapping from content to locations in a document (or table, etc.). This is in contrast to a forward index, which, for our book example, would be a list of page numbers with all the words listed on that page. A search engine uses an inverted index to allow for fast retrieval of web pages we will first figure out how to build one of these inverted indexes to efficiently store the data that we want to be able to search through. Efficiency note: To create an inverted index, you must process the entire document, or set of documents, and catalog where each word is located. This may not be a fast process, but once the inverted index is complete, searching for words and their corresponding locations is extremely fast. Onto the code! Decomposition is one of your best tools for tackling a complex problem. We'll guide you along by breaking the problem down into a sequence of steps. Follow our steps to success! All of the functions and tests for the search engine will be implemented in the file search.cpp. 1) Write helper function cleanToken() Start by writing a reusable helper function that will make your later work easier. string cleanToken(string token) cleanToken takes in a whitespace-separated string of characters that appears in the body text and returns a "cleaned" version of that token, ready to be stored in the index. The cleaned version has trimmed off any leading or trailing punctuation characters and has been converted to lowercase. If the token contains no letters whatsoever, cleanToken returns an empty string to indicate this token is to be discarded entirely. More precisely, cleanToken should: Remove all punctuation from the beginning and end of a token, but not from inside a token. The tokens section and section. and "section" are each trimmed to the same token section, which makes searching more effective. Tokens such as doesn't or zelenski@cs are unchanged, since the punctuation occurs in the middle of these tokens. By punctuation, we mean any character for which ispunct returns true. There are a few oddball characters (curly quotes, bullets, and the like) that are not recognized as punctuation by ispunct. Do not make a special case of this; just trim according to ispunct. Return the empty string if the token does not contain at least one letter, i.e. isalpha must be true for at least one character. By returning the empty string, cleanToken indicates this token should be discarded as it is not a word. Convert the token to lowercase. Standardizing on a canonical form for the tokens allows search queries to operate case-insensitively. The return value from cleanToken is the trimmed, lowercase version (or empty string if the token is to be discarded). As always, after writing a function and before moving on, you should stop here and write test cases to confirm your function works correctly on all inputs. You should write at least 3-4 additional tests to make sure your helper function works. Remember to label your tests as STUDENT_TEST. 2) Write helper function gatherTokens() The helper function gatherTokens extracts the set of unique tokens from the body text. Set<string> gatherTokens(string bodytext) The single argument to gatherTokens is a string containing the body text from a single web page. The function returns a Set of the unique cleaned tokens that appear in that body text. The function must first tokenize the body text - in other words, divide into individual tokens, which will be strings separated by spaces. Do this division using the stringSplit function available in the Stanford library. Each token is then cleaned using your cleanToken helper function. The cleaned tokens are stored in a Set. Even if the body text contains a thousand occurrences of the word "llama," the set of unique tokens contains only one copy, so gathering the unique words in a set is perfect for avoiding unnecessary duplication. Time to test! Add test cases that confirm the output from gatherTokens, so you will later be able to call on this function with confidence that it does its job correctly. 3) Create inverted index in buildIndex() The function buildIndex reads the content from the database file and processes it into the form of an inverted index. int buildIndex(string dbfile, Map<string, Set<string>>& index) The first argument to buildIndex is the name of the database file of the web page data, the second argument is the Map to be populated with data for the inverted index. The return value of buildIndex is the number of documents processed from the database file. Before starting to write code, first work through a small example on paper to ensure you understand what your function is trying to build. Q8. Draw out the inverted index for the res/tiny.txt database file. Review the section Understanding the web page data to remind yourself of the format of the database file. Next, read over the code we provided for readMazeFile in maze.cpp to see an example of opening a file and reading the contents into a vector of lines. Feel free to reuse that code for buildIndex. Once you have read the line containing the body text of page, call your gatherTokens to extract the set of unique tokens. For each token in the set, update the inverted index to indicate that this token has a match to this page's URL. The action of buildIndex is to populate index with entries where each key word is associated with a set of URLs where that word can be found. The function returns the count of web pages that were processed and added to the index. The Map and Set classes are the right data structures for storing the inverted index itself. Sets are especially handy when evaluating a complex query because of the awesome high-level set operations that combine sets. Our starter code contains some provided tests to get you started. Make sure all the provided tests pass, but that won't be enough to fully vet the function. You should add student tests of your own to ensure you have comprehensive coverage. Don't move on until all tests pass. 4) Search using findQueryMatches() The inverted index you just built is exactly the data structure needed to enable quickly finding those pages that match a search query. Next up is to implement the function: Set<string> findQueryMatches(Map<string, Set<string>>& index, string query) The query string argument can either be a single search term or a compound sequence of multiple terms. A search term is a single word, and a sequence of search terms is multiple consecutive words, each of which (besides the first one) may or may not be preceded by a modifier like + or - (see below for details). The same stringSplit function you used to divide the body text into tokens can be used to divide the user's query sentence into search terms. When finding the matches for a given query, you should follow these rules: For a single search term, matches are the URLs of the web pages that contain the specified term. A sequence of terms is handled as a compound query, where the matches from the individual terms are synthesized into one combined result. A search term has a slightly altered meaning when the term is prefaced by certain modifiers: By default when not prefaced with a + or -, the matches are unioned across search terms. (any result matching either term is included) If the user prefaces a search term with +, then matches for this term are intersected with the existing results. (results must match both terms) If the user prefaces a search term with -, then matches for this term are removed from the existing result. (results must match one term without matching the other) The same token cleaning applied to the body text is also applied to query terms. Call your helper cleanToken to process each search term to strip punctuation, convert to lowercase, and discard non-words before performing the search for matches. Here are some example queries and how they are interpreted quokka matches all pages containing the term "quokka" simple cheap means simple OR cheap matches pages that contain either "simple" or "cheap" or both tasty +healthy means tasty AND healthy matches pages that contain both "tasty" and "healthy" tasty -mushrooms means tasty WITHOUT mushrooms matches pages that contain "tasty" but do not contain "mushrooms" tasty -mushrooms simple +cheap means tasty WITHOUT mushrooms OR simple AND cheap matches pages that match ((("tasty" without "mushrooms") or "simple") and "cheap") There is no precedence for the operators, the query is simply processed from left to right. The matches for the first term are combined with matches for second, then combined with matches for third term and so on. In the last query shown above, the matches for tasty are first filtered to remove all pages containing mushrooms, then unioned with all matches for simple and lastly intersected with all matches for cheap. In implementing this logic, you will find the Set operators for union, intersection, and difference to be very handy! There is a lot of functionality to test in query processing, be sure you add an appropriate set of student tests to be sure you're catching all the cases. 5) Put it all together with searchEngine() Thus far, your amazing code has re-arranged a mass of unstructured text data into a highly-organized and quickly-searchable inverted index with fancy query-matching capability. Now take it over the finish line to build your own search engine! The final function to implement is: void searchEngine(string dbfile) This function implements a console program that works as follows: It first constructs an inverted index from the contents of the database file. It prints how many web pages were processed to build the index and how many distinct words were found across all pages. It then enters a loop that prompts the user to enter a query For each query entered by the user, it find the matching pages and prints the URLs. The user enters the empty string ("") to indicate they are done and the program finishes executing. Note that searching should be case-insensitive, that is, a search for "binky" should return the same results as "Binky" or "BINKY". Be sure to consider what implications this has for how you create and search the index. After you have completed this function, your program should behave as shown in the transcript shown below. Example program run (executed by running searchEngine("res/website.txt") in main.cpp): Stand by while building index... Indexed 50 pages containing 5595 unique terms. Enter query sentence (RETURN/ENTER to quit): llama Found 1 matching pages {"http://cs106b.stanford.edu/assignments/assign2/searchengine.html"} Enter query sentence (RETURN/ENTER to quit): suitable +kits Found 2 matching pages {"http://cs106b.stanford.edu/assignments/assign2/searchengine.html", "http://cs106b.stanford.edu/qt/troubleshooting.html"} Enter query sentence (RETURN/ENTER to quit): Mac linux -windows Found 3 matching pages {"http://cs106b.stanford.edu/lectures/sets-maps/qa.html", "http://cs106b.stanford.edu/qt/install-linux.html", "http://cs106b.stanford.edu/qt/install-mac.html"} Enter query sentence (RETURN/ENTER to quit): as-is wow! Found 3 matching pages {"http://cs106b.stanford.edu/about_assignments", "http://cs106b.stanford.edu/assignments/assign1/soundex.html", "http://cs106b.stanford.edu/assignments/assign2/searchengine.html"} Enter query sentence (RETURN/ENTER to quit): All done! Way to go, you're well on your way to becoming the next internet search pioneer! Notes The res folder of the starter project includes two database files: tiny.txt is the small example used in the writeup and website.txt is the body text extracted from all of the pages in our course website (as of Sept 24). You can open these files in Qt Creator to view their contents. The project resource files are listed under Other files -> res. Your program can open a resource file by specifying the path as "res/myfilename". References Inverted Index on GeeksForGeeks Wikipedia article on Inverted Indexes Stanford Natural Processing Group on Tokenization Extensions If you have completed the basic assignment requirements and and want to go further, we encourage you to try adding an extension! A non-exhaustive list of potential extensions is listed below: Weights When you get the results from a Google search, they are ranked so that the more relevant results are first on the list. The current Google algorithm is a well-kept trade secret (though it was originally the Page Rank algorithm, named for its creator, then-Stanford graduate student Larry Page), but a simple approach is to give higher rank to pages with more occurrences of the search term. For this extension, you would need to re-think how you create your index to include the number of matches. Phrase search The assignment does not allow a search for multi-word terms, such as section leader. Searching for phrases is not trivial, as you cannot simply keep a mapping of all possible phrases in the document. You could, however, keep track of where in each document a word is, and then use that information to determine if words in a phrase are next to each other in any particular document. Stop Words The English language has many, many words that show up in text but are not particularly important for content, such as the, and, if, a, etc. These words are called Stop Words, and it would make your index smaller if you removed such stop words from the index. Here is more info about stop words. Stemming In the current design, if a user searches for section they won't find matches for sections, even though pages that talk about sections might be relevant match. Stemming is the process of reducing words to their base form, so that (for example) both section and sections would become, simply, section in the index. If you have other creative ideas for extensions, run them by the course staff, and we'd be happy to give you guidance!
http://cs106b.stanford.edu/lectures/02-cpp/slides.html
From Python to C++ CS 106B: Programming Abstractions Fall 2020, Stanford University Computer Science Department Lecturers: Chris Gregg and Julie Zelenski Announcements Qt Installation Session Tomorrow night (Thursday 4/9) from 6-8pm Get help with installing the software that you need to do assignments in this class. Information on how to sign up and get help will be posted in an announcement on the course website tomorrow. Section Signups Everyone in this class (SCPD students included) is required to sign up for a section. Your assigned section leader will teach your weekly section, and also be responsible for grading all of your assignments and conducting your assessments. Section signups will open tomorrow (Thursday 9/17) at 5pm PDT and close on Sunday (9/20) at 5pm PDT is not first-come first-served but you must submit your preferences at some point during this time span! Fill out your section preferences on the CS198 website. Slide 2 A Tour Through C++ Topics for Today: What are the core differences between Python and C++? Comments #include statements typed variables standard output (cout) Blocks: curly braces while loops for loops scoping boolean expressions, boolean operators, and the if statement functions The main function Passing by value and reference header files we will cover Vectors in the next lecture, and strings in the following lecture Slide 3 Overview of C++ If you took CS 106A, taught in Python, this lecture is particularly suited to you. If you took CS 106AJ in Javascript, you will see a good bit of new syntax, but it will be more familiar. If you took AP CS in Java, much of this lecture will be familiar, but some parts will still be new. C++ is a high-performance, robust (and complex) language. It originally began (in 1985 ) as C with Classes. It has been an Object Oriented language from the beginning, and its inventor, Bjarne Stroustrup, chose to base the language on the "C" language because it was a fast, widely used language already. C++ is complex enough that it is very, very hard to completely master it. We will touch on only a small fraction of the language in this course, but if you want to learn more, there are plenty of tutorials and resources. Unlike Python, C++ does not come with a built-in library of data structures and functionality, and almost all of those features are provided through libraries. In CS 106B, we rely primarily on the iostream and string libraries (part of the Standard library available with most C++ compilers), and also with the Stanford library, which includes many data structures, and helper functions. If you go on to program in C++ in the future (e.g., in CS 110, or in an internship), you will need to learn other standard libraries, which sometimes mimic the Stanford library but with mostly minor differences and some major differences. C++ is a compiled language, as opposed to Python, which is an interpreted language. This means that before running a C++ program, you must first compile it to machine code. Slide 4 Comments You might be used to the following types of comments in Python: Single-line comments: # Python: # A hash comments out the rest of the line myVar = 5 # everything past the hash is a comment Multi-line comments: # Python: """ This is a multiline comment, and I end it with three quotes """ C++ also has two types of comments: Single-line comments: // C++: // Two forward slashes comment out the rest of the line int myVar = 5; // everything past the double-slash is a comment Multi-line comments: // C++: /* This is a multiline comment, and I end it with an asterisk-slash */ Slide 5 #include statements In Python, you import modules, and the equivalent in C++ is a #include (pound include). There are two different ways to use this statement: #include <iostream> When using the angle brackets, < and >, this tells the compiler to include libraries that are in pre-defined locations based on the setup for your compiler or IDE (e.g., Qt Creator). #include "all-examples.h" When using double quotes, this tells the compiler to first search in the same directory as the current file. In this case, the .h extension means header file, which we will discuss soon. #include directives literally tell the compiler to read in and paste code from another file at that particular point in your program. Slide 6 Typed Variables As you should know from prior programming classes, all variables have a type associated with them, where the type describes the representation of the variable. For example, a variable may be an integer, or a floating point number, or a string. In Python, variables have types, but the type is not explicitly written out when defining a variable. E.g., # Python: a = 5 # the Python interpreter knows this is an integer a = "aardvark" # now the variable is a string! In C++, all types must be defined when the variable is created, and a variable cannot change its type. For example: // C++: int a = 5; // a is an integer char b = 'x'; // b is a char ("character") float c = 1.42; // c is a floating point number double d = 1.4245593330222211176; // d is a double, a more accurate floating point number string s = "this is a C++ string"; float a = 4.2; // ERROR! You cannot redefine a variable to be another type int a = 12; // ERROR! You do not need the type when re-assigning a variable a = 12; // this is okay By the way: In C++, all statements must end with a semicolon ; Indentation is not enforced by the compiler, but Qt Creator should indent properly for you. Slide 7 Standard Output Printing to the screen is the most common output in a program. Being able to output to the screen gives your user feedback, and also can be a great way to debug your programs. In Python, you have the print function: # Python: num = 42 theAnswer = "The answer to life, the universe, and everything" print(f"{theAnswer} is {num}.") Output: The answer to life, the universe, and everything is 42. In C++, we have a function called cout that prints, but we use it in a different way: // C++: int num = 42; string theAnswer = "The answer to life, the universe, and everything"; cout << theAnswer << " is " << num << "." << endl; Output: The answer to life, the universe, and everything is 42. You can think of the double-angle brackets, << as meaning "send to cout". The endl is necessary to put the cursor on a different line. Here is an example with and without the endl: // C++: cout << "This is some text followed by endl." << endl; cout << "This is more text."; cout << "We want to go to the next line here, too" << endl; cout << "We made it to the next line." << endl; Output: This is some text followed by endl. This is more text.We want to go to the next line here, too We made it to the next line. Slide 8 Blocks: curly braces, while loops In Python, a block is defined as an indentation level, where whitespace is important. C++ does not have any whitespace restrictions, so blocks are denoted with curly braces, { to begin a block, and } to end a block. Blocks are used primarily for functions (we will see this shortly), and also for loops. Let's first look at the while loop. Here is what you might be used to in Python: # Python: i = 0 while i < 5: print(i) i += 1 Output: 0 1 2 3 4 In C++, we also have a while loop, in the following form: while (expression) { statement; statement; ... } As long as expression is true, the loop continues (we will discuss boolean expressions soon). The parentheses surrounding expression are required. Example: // C++: int i = 0; while (i < 5) { cout << i << endl; i++; } Output: 0 1 2 3 4 The i++ increments the variable i by 1, and is the reason C++ got its name! (and there is a corresponding decrement operator, --, as in i--). Slide 9 for loops If we know ahead of time how many times we want to run a loop, the for loop is often a better choice than a while loop. In Python, for loops are actually a bit more robust than in C++, and they have a different structure. Here is a typical Python for loop: # Python: for i in range(3): print(i) Output: 0 1 2 In C++, for loops have the following form, which may take a bit of getting used to: for (initializationStatement; testExpression; updateStatement) { statement; statement; ... } The initializationStatement happens at the beginning of the loop, and initializes a variable. E.g., int i = 0. The testExpression is evaluated initially, and after each run through the loop, and if it is true, the loop continues for another iteration. E.g., i < 3. The updateStatement happens after each loop, but before testExpression is evaluated. E.g., i++. Here is the above example, written in C++: // C++ for (int i = 0; i < 3; i++) { cout << i << endl; } Output: 0 1 2 Here is the equivalent way to write the above code as a while loop: // C++: int i = 0; while (i < 3) { cout << i << endl; i++; } There is another type of for statement that we will cover when we reach collections (e.g., the Vector class), so stay tuned! Slide 10 Scoping Variables in C++ are scoped to the block they belong in. In other words, a variable is not accessible outside of the block where it is defined. This is also true for the initialization statement in a for loop - if you define a variable there, it is not accessible outside the loop. Example: // C++: int main() { int outsideVar = 5; for (int loopVar = 0; loopVar < 3; loopVar++) { int insideVar = 10 * outsideVar; cout << outsideVar << ", " << insideVar << endl; outsideVar += 2; } cout << outsideVar << endl; // okay cout << insideVar << endl; // error! insideVar not in scope cout << loopVar << endl; // error! loopVar not in scope return 0; } Output (with the last two cout statements removed): 5, 50 7, 70 9, 90 11 Slide 11 Boolean expressions, boolean operators, and the if statement As in virtually all other programming languages, C++ has boolean expressions and boolean operators, as shown in the following tables: Expression Meaning a < b a is less than b a <= b a is less than or equal to b a > b a is greater than b a >= b a is greater than or equal to b a == b a is equal to b a != b a is not equal to b Operator(preferred) Alternative Meaning a && b a and b Both a AND b are true a || b a or b Either a OR b are true !a not a If a is true, returns false, and vice-versa The "preferred" operators from the second table above are the standard C boolean operators. The C++ if statement tests a boolean expression and runs a block of code if the expression is true, and, optionally, runs a different block of code if the expression is false. The if statement has the following format: if (expression) { statements if true } else { statements if false } The parentheses around expression are required. Additional if statements can be used to check for different conditions, as well: if (expression1) { statements if expression1 is true } else if (expression2) { statements if expression2 is true } else { statements if neither expression1 nor expression2 is true } Example code: // C++: int firstNum = 1; string compareText; for (int secondNum = 0; secondNum < 3; secondNum++) { if (firstNum < secondNum) { compareText = "less than"; } else if (firstNum > secondNum) { compareText = "greater than"; } else { compareText = "equal to"; } cout << "firstNum is " << firstNum << ", secondNum is " << secondNum << endl; cout << "firstNum is " << compareText << " secondNum" << endl << endl; } Output: firstNum is 1, secondNum is 0 firstNum is greater than secondNum firstNum is 1, secondNum is 1 firstNum is equal to secondNum firstNum is 1, secondNum is 2 firstNum is less than secondNum Example code: int x = 5; int y = 7; if (x == 5 && y == 7) { cout << "x equals 5 and y equals 7" << endl; } if (x == 5 || y == 5) { // note: cannot combine as if (x || y == 5) cout << "x equals 5 or y equals 5" << endl; } if (x != 5 && y != 5) { cout << "x is not equal to 5 and y is not equal to 5" << endl; } else if (x != 5 || y != 5) { cout << "x is not equal to 5 or y is not equal to 5" << endl; } if (!(x == 5 && y == 5)) { cout << "not (x is equal to 5 and y is equal to 5) (DeMorgan's Law)" << endl; } Output: x equals 5 and y equals 7 x equals 5 or y equals 5 x is not equal to 5 or y is not equal to 5 not (x is equal to 5 and y is equal to 5) (DeMorgan's Law) Slide 12 Functions Much like in Python, Java, Javascript, etc., C++ has functions that you can call (e.g., from a library), and that you can create yourself. Functions can also return a single value, however we will see how we can utilize reference parameters to share data between functions. In C++, functions must be declared before they are used. Functions are declared as follows: returnType functionName(varType parameter1, varType parameter2, ...); A function can be declared and defined (i.e., have the code, as well) at the same time, but again, only if done before use in another function later in the program. The first function that runs in any program is the main function, declared as follows: int main() { statement statement ... } Before we start declaring other functions besides main, let's use one. The C++ <cmath> library has many mathematical functions. E.g., the square root function, sqrt: // C++: #include <cmath> #include <iostream> using namespace std; int main() { double fpNum = 1234; // a floating point number double result = sqrt(fpNum); // set result to be equal to the return value of the sqrt function cout << "fpNum: " << fpNum << endl; cout << "square root of fpNum: " << result << endl; return 0; // the return value for main must be an integer. // In main(), a return value of 0 means "everything worked out" } Output: fpNum: 1234 square root of fpNum: 35.1283 Let's write a function of our own, that computes and returns the factorial of a number: int factorial(int number) { int result = 1; for (int n = number; n > 1; n--) { result *= n; } return result; } The function above requires that we pass it an integer, and it guarantees that it will return an integer. You might ask, What if I don't want to return anything from my function? and C++ answers that with the void keyword, which means, the function does not return a type. E.g., void printTenTimes(char c) { for (int i = 0; i < 10; i++) { cout << c; } cout << endl; } This function can be called, but won't return a value: printTenTimes('c'); Output: cccccccccc If we try to get a return value from a void function, the compiler produces an error: int someResult = printTenTimes('c'); Compiler output: my-file.cc:32:9: error: cannot initialize a variable of type 'int' with an rvalue of type 'void' int someResult = printTenTimes('c'); ^ ~~~~~~~~~~~~~~~~~~ 1 error generated. One thing you may have to get used to is arcane C++ error messages! The above error message means that we tried to give an integer a value with a type of void, and the compiler won't let us do that. Slide 13 Passing values to functions by value or reference Let's jump back to Python for a moment, for those of you who took CS 106A in Python. What is the output of the following program? # Python: def doubleValue(x): x *= 2 return x if __name__ == "__main__": myValue = 5 doubleResult = doubleValue(myValue) print(myValue) print(doubleResult) Output: Solution 5 10 The reason for the output is that the parameter x was passed to the doubleValue function by value, meaning that the variable x is a copy of the variable passed in. Changing it inside the function does not change the value in the calling function. You can modify the contents of objects (such as a list) by passing in the list, but that does not work for regular values. When passing arguments as parameters to a function in C++ the way we have already seen, we have the same behavior: // C++: #include<iostream> using namespace std; int doubleValue(int x) { x *= 2; return x; } int main() { int myValue = 5; int result = doubleValue(myValue); cout << myValue << endl; cout << result << endl; } Output: 5 10 In this case, the parameter x was passed by value. C++ has a completely different way of passing in arguments as parameters to a function, called pass by reference. To pass a value by reference, the parameter has the ampersand (&) symbol before the variable name, e.g., void doubleValueWithRef(int &x); Now, we have provided the doubleValueWithRef function with a reference to the variable x, which means that if the function modifies x, it is actually modifying the original value - it has a reference to x, or it refers to it. Let's see how this might work, without needing to return a value from doubleValueWithRef: #include<iostream> using namespace std; void doubleValueWithRef(int &x) { x *= 2; } int main() { int myValue = 5; // int result = doubleValueWithRef(myValue); // Error! the function does not return a value now. doubleValue(myValue); cout << myValue << endl; } Output: 10 In this case, myValue was changed by the function, and we did not need a return value. With references, C++ lets you modify data directly, without copying the data. This is powerful, but as Uncle Ben (in Spiderman) says, With great power comes great responsibility. If you pass a value by reference, you need to understand that the function can modify it directly. We will discuss ways of making this a bit safer in later lectures, but for now know that you need to be somewhat careful and you need to understand it thoroughly. Passing by reference is most-often used when we want access to the contents of data structures without passing all of the values (which can take time). We will see this when we cover Vectors in the next lecture. One caveat: in order to pass a variable by reference, you need to actually have a variable. The following does not work, for our example above: doubleValueWithRef(15); // error! cannot pass a literal value by reference Compiler error: ../all-examples.cpp:135:5: error: no matching function for call to 'doubleValueWithRef' doubleValueWithRef(15); ^~~~~~~~~~~~~~~~~~ ../all-examples.cpp:11:6: note: candidate function not viable: expects an l-value for 1st argument void doubleValueWithRef(int &x); ^ 1 error generated. Slide 14 Header files As C++ has its roots in the C language, it uses C-style header files. A header file generally serves to define functions, classes, and structs (defined later in the course) that will be used by various parts of your program. C++ programs often have multiple code files, and if two different C++ files (which have the extension .cpp or .cc) use the same functions, they may be defined in a header so that each of the .cpp files knows about the functions. Header files can also make the compilation steps of a large program faster, which is part of the original reason they were used in C. Header files should have the .h extension (or, less often, .hpp). It may be the case that a header file is included in a cascading set of files - one header may include another header, and then a .cpp file might include both headers. As this could cause certain objects to be defined twice, we use a special directive inside header files to limit this: #pragma once This means that the compiler will only include the file once during compilation. Example header file, and corresponding C++ file: Header: // all-examples.h #pragma once int square(int x); bool even(int value); C++ file: // all-examples.cpp #include <iostream> #include "all-examples.h" // we can call the functions before the appear in this file, because they've // already been defined in the header file and we've #included it. int main() { cout << square(15) << endl; if (even(42)) { cout << "even" << endl; } else { cout << "odd" << endl; } } int square(int x) { return x * x; } bool even(int v) { return v % 2 == 0; } Output: 225 even
http://cs106b.stanford.edu/lectures/04-vector-grid/slides.html
The Vector and Grid Classes CS 106B: Programming Abstractions Fall 2020, Stanford University Computer Science Department Lecturers: Chris Gregg and Julie Zelenski Slide 2 Announcements Section starts this week! Section assignments will be released on Tuesday (9/22) evening and sections will begin Wednesday (9/23) morning. Reminder: All section times are displayed in PDT. If you can no longer make the time to which you're assigned (or if you were originally unassigned because you did not submit time preferences), go to the CS198 website and you'll be able to switch into any section which still has space. The (virtual) LaIR is now open is a space where you can get live code debugging help from our fleet of awesome section leaders. The schedule has recently changed to add morning hours to accommodate those students that are in timezones where the typical LaIR time is inaccessible. Check the Zoom details page for information on how to get help at the LaIR. Please make your best effort to save code debugging questions for the LaIR or instructor office hours we will offer as much flexibility as we can to answer debugging questions on Ed, we only have a limited capacity to do so, and would like to reserve this for folks that are unable to make any of the synchronous help resources that have been offered. Slide 3 Code Mystery In the last lecture, we introduced the idea of a C++ reference. What is the output of this code? Fill out the Zoom poll with your answer! void mystery(int& b, int c, int& a) { a++; b--; c += a; } int main() { int a = 5; int b = 2; int c = 8; mystery(c, a, b); cout << a << " " << b << " " << c << endl; return 0; } Poll: A. 5 2 8 B. 5 3 7 C. 6 1 8 D. 61 13 E. other Slide 4 Poll answer: output A. 5 2 8 B. 5 3 7 C. 6 1 8 D. 61 13 E. other Note: please don't obfuscate your code like this! :( See the International Obfuscated C Contest for much, much worse examples Slide 5 A function for Solving the Quadratic Equation A quadratic equation for variable x is one of the form: ax2 + bx + c = 0 for some numbers a, b, and c. The two roots of a quadratic equation can be found using the quadratic formula above. Example: The roots of x2 - 3x - 4 = 0 are x=4 and x=-1 How would we write a function named quadratic to solve quadratic equations? What parameters should it accept? Which parameters should be passed by value, and which by reference? What, if anything, should it return? We have choices! Slide 6 A Function for Solving the Quadratic Equation /* * Solves a quadratic equation ax^2 + bx + c = 0, * storing the results in output parameters root1 and root2. * Assumes that the given equation has two real roots. */ void quadratic(double a, double b, double c, double& root1, double& root2) { double d = sqrt(b * b - 4 * a * c); root1 = (-b + d) / (2 * a); root2 = (-b - d) / (2 * a); } How are we "returning" the results? Answer: by using references to variables What other choices ccould we have made? Slide 7 Collections One of the most powerful aspects of C++ is the ability to have a "collection": we will study the six collections shown above. We will talk about all of these as we go through CS 106B, but you will need to use the Vector and Grid classes for assignment 1. Slide 8 The Vector Collection What is a Vector? It is like a list in Python, or an ArrayList in Java. It is a list of elements that can grow and shrink. Each element has a place (or index) in the list. Important Details The constructor creates an empty list (more on constructors soon) The Stanford Vector class performs bounds checks, meaning that if you try to access an element that is outside the bounds of a Vector, the program crashes. A Vector Knows its size. To use Vectors, you #include "vector.h". Under the hood, a vector is an array, which means that in the computer's memory, one value follows the next. Slide 9 Creating a Vector You must specify the type of your vector (e.g., int, string, etc.) When a vector is created it is initially empty. To create a vector called vec that can hold integers (ints), we write the following: Vector<int> vec; This calls the default constructor, which just means that it initializes and creates (constructs) an empty vector for us. Slide 10 Adding elements to a vector Here is an example where we create a vector called magic and add the numbers 4, 8, 15, and 16 to the vector, and then print out the elment at index 2: Vector<int> magic; magic.add(4); magic.add(8); magic.add(15); magic.add(16); cout << magic[2] << endl; Output: 15 Notice that the index ordering starts from zero! In the computer's memory, our vector is represented by one number after another, as follows: magic: index: 0 1 2 3 value: 4 8 15 16 Slide 11 Vectors have useful functions, like size() magic: index: 0 1 2 3 value: 4 8 15 16 The following loops through the values in the vector and prints them: for(int i = 0; i < magic.size(); i++) { cout << magic[i] << endl; } Output: 4 8 15 16 Slide 12 A new type of for loop: the for each loop: magic: index: 0 1 2 3 value: 4 8 15 16 The following is a loop that automatically gets the next value in a collection: for(int value : magic) { cout << value << endl; } Output: 4 8 15 16 Slide 13 Vector Functions The following functions are part of the vector collection, and can be useful: vec.size(): Returns the number of elements in the vector. isEmpty(): Returns true if the vector is empty, false otherwise. vec[i]: Selects the ith element of the vector. vec.add(value): Adds a new element to the end of the vector. vec.insert(index, value): Inserts the value before the specified index, and moves the values after it up by one index. vec.remove(index): Removes the element at the specified index, and moves the rest of the elements down by one index. vec.clear(): Removes all elements from the vector. For the exhaustive list, check out the Stanford Vector class Slide 14 The Grid Container The Grid is a Stanford library class for 2-dimensional arrays, like a matrix in math: a0 b0 c0 a1 b1 c1 a2 b2 c2 Slide 15 Grid What is it? Advanced 2D array. Think spread sheets, game boards Important Details Default constructor makes a grid of size 0 Doesn't support "ragged right". Bounds checks Knows its size. We could use a combination of Vectors to simulate a 2D matrix, but a Grid is easier! Slide 16 Grid Example Code Grid<int> matrix(2,2); matrix[0][0] = 42; matrix[0][1] = 6; matrix[1][0] = matrix[0][1]; cout << matrix.numRows() << endl; cout << matrix[0][1] << endl; cout << matrix[1][1] << endl; cout << matrix[2][3] << endl; Let's draw what happens on each line. Grid<int> matrix(2,2); // Create a 2x2 grid, with 0 as the default entries 0 1 0 0 0 1 0 0 matrix[0][0] = 42; // put 42 at row 0, column 0 0 1 0 42 0 1 0 0 matrix[0][1] = 6; // put 6 at row 0, column 1 0 1 0 42 6 1 0 0 matrix[1][0] = matrix[0][1]; // put the value from r0,c1 at r1,c0 0 1 0 42 6 1 6 0 cout << matrix.numRows() << endl; cout << matrix[0][1] << endl; cout << matrix[1][1] << endl; Prints the number of rows, then the value at r0,c1, then the value at r1,c1: 2 6 0 cout << matrix[2][3] << endl; // attempts to print out the value at r2,c3 *** *** STANFORD C++ LIBRARY *** An ErrorException occurred during program execution: *** Grid::operator [][]: (2, 3) is outside of valid range [(0, 0)..(1, 1)] *** libc++abi.dylib: terminate_handler unexpectedly threw an exception 15:25:55: The program has unexpectedly finished. 15:25:55: The process was ended forcefully. Grids do bounds checking! If you want to bounds check without crashing, you should call the grid.inBounds(row, col) function, which returns true if the row and column are in bounds for the grid. Slide 17 Grid Functions The following functions are part of the grid collection, and can be useful: grid.numRows(): Returns the number of rows in the grid. grid.numCols(): Returns the number of columns in the grid. grid[i][j]: selects the element in the ith row and jth column. grid.resize(rows, cols): Changes the dimensions of the grid and re-initializes all entries to their default values. grid.inBounds(row, col): Returns true if the specified row, column position is in the grid, false otherwise. For the exhaustive list, check out the Stanford Grid class Slide 18 Grid Example: Traversing a Grid void printGrid(Grid<char> &grid) { for(int r = 0; r < grid.numRows(); r++) { for(int c = 0; c < grid.numCols(); c++) { cout << grid[r][c]; } cout << endl; } } If we pass in the following grid, what will print? 0 1 0 a b 1 c d 2 e f Output: ab cd ef Slide 19 Common pitfalls when working with collections in C++ Vector numbers; Needs a type! Should be: Vector<int> numbers; void myFunction(Grid<bool> gridParam); Two issues: If you want the original gridParam to be changed in the calling function, you're out of luck. Inefficient because you have to make a copy of gridParam. void printOutGrid(Grid<bool> & grid) { for(int i = 0; i < grid.numRows(); i++) { for(int j = 0; j < grid.numCols(); j++) { cout << grid[j][i]; } } Watch your variable ordering! Better to use r for rows, and c for columns. Slide 20 Let's Code Instagram! Slide 21 A color is an int, and and Image is just a Grid<int>! Slide 22 Let's change the palette of the image Slide 23 Let's Code!
http://cs106b.stanford.edu/lectures/06-set-map/slides.html
Lecture 6: The Set and Map Classes CS 106B: Programming Abstractions Autumn 2020, Stanford University Computer Science Department Lecturers: Chris Gregg and Julie Zelenski Slide 2 Announcements Assignment 1 is due tonight, end-of-day PDT. Assignment 2 coming soon! The recorded section video for this week has been posted on Canvas for anyone that wants extra review on the last week and a half of lecture content. Slide 3 Sets and Maps Today we are going to discuss two new collections: sets and maps. A set is a collection of elements with no duplicates: A map is a collection of key / value pairs, and the key is useed to find the value. In python, we call this collection a dict. Slide 4 Sets A set is a collection of elements with no duplicates. Sets have (at least) the following operations (and they are fast): add(value): adds a value to a set, and ignores if the set already contains the value contains(value): returns true if the set contains the value, false otherwise. remove(value): removes the value from the set. Does nothing if the value is not in the set. size(): returns the number of elements in the set isEmpty(): returns true if the set is empty, false otherwise. Sets have other useful functions, and you should check the Set documentation to see them. Sets do not have indexes! Slide 5 Sets: simple example Set<string> friends; friends.add("nick"); friends.add("chris"); friends.add("julie"); cout << boolalpha << friends.contains("voldemort") << << noboolalpha << endl; for(string person : friends) { cout << person << endl; } Output: false chris julie nick Notice - the output from the for loop is alphabetical! Sets keep their values sorted. Slide 6 Looping over a Set for(type currElem : set) { // process elements one at a time } You can't use an index-based for loop, becuase Sets do not have indexes! for(int i=0; i < set.size(); i++) { // does not work, no index! cout << set[i]; } Slide 7 Types of Sets There are actually two types of sets in the Stanford library: Set Iteration over the elements is in sorted order Really fast access times! O(log n) per retrieval - we will learn about this next week! Sets are implemented using a "binary search tree" HashSet Iteration over the elements is not in a useful order (it is jumbled) Really, ridiculously fast! O(1) per retrieval (again, we will learn what this means next time!) Slide 8 Set Operands Sets can be compared, combined, etc. s1 == s2 true if the sets contain exactly the same elements s1 != s2 true if the sets don't contain the exact same elements s1 + s2 returns the union of s1 and s2 (i.e., all elements in both) s1 * s2 returns the intersection of s1 and s2 (i.e., only the elements in both sets) s1 - s2 returns the difference of s1 and s2 (the elements in s1 but not in s2) Slide 9 Counting Unique Words Let's write a program to count the unique words in a file Slide 10 Maps A map is a collection of pairs (k, v), sometimes called key/value pairs, where v can be found quickly if you know k. Other terms you may hear for a map are dictionary or associative array. A map is a generalization of an array, where the "indexes" don't need to be integers: Slide 11 Using Maps A map allows you to get from one half of a pair to the other. E.g., to store an association from "Jenny" to "867-5309": // key value m["Jenny"] = "867-5309"; // or: m.put("Jenny", "867-5309"); To get Jenny's number: string ph = m["Jenny"] // or string ph = m.get("Jenny") cout << ph << endl; Output: 867-5309 Slide 12 Maps are Everywhere Wikipedia: the key is the title, the value is the article: Slide 13 Creating Maps A Stanford Map requires two parameters: one for keys, one for values: // maps from string keys to integer values Map<string, int> votes; // maps from string keys to Vector<string> values Map<string, Vector<string>> friendMap; Slide 14 Map Functions The following functions are part of the Map class: m.clear() : removes all key/value pairs from the map m.containsKey(key) : returns true if the map contains a value for the given key m[key]m.get(key) : returns the value mapped to the given key; if key is not in the map, adds it with the default value (e.g., 0 or "") m.isEmpty() : returns true if the map contains no key/value pairs (size 0) m.keys() : returns a Vector copy of all keys in the map m[key] = valuem.put(key, value) : adds a mapping from the given key to the given value; if the key already exists, replaces its value with the given one m.remove(key) : removes any existing mapping for the given key (ignored if the key doesn't exist in the map) m.size() : returns the number of key/value pairs in the map m.toString() : returns a string such as "{a:90, d:60, c:70}" m.values() : returns a Vector copy of all the values in the map Slide 15 Map Example Map<string, string> wiki; // adds name / text pair to dataset wiki.put("Neopalpa donaldtrumpi", articleHTML); // returns corresponding articleHTML cout << wiki.get("Yosemite National Park"); // removes the article wiki.remove("Britain in the E.U."); Slide 16 Types of Maps There are actually two types of maps in the Stanford library: Map Iteration over the elements is in sorted order Really fast access times! O(log n) per retrieval - we will learn about this next week! Maps are implemented using a "binary search tree" HashMap Iteration over the elements is not in a useful order (it is jumbled) Really, ridiculously fast! O(1) per retrieval (again, we will learn what this means next time!) Slide 17 Map Example: Tallying Votes // tally votes: // (M)ilk, (S)tokes, (R)ogers string allVotes = "MMMRMSSMSSMMMMMRRMMMMRRRMMM"; Map<char, int> voteTally; for (char v : allVotes) { voteTally[v]++; } // loop over the map for (char initial : voteTally) { int numVotes = voteTally[initial]; cout << initial << ": " << numVotes << " votes" << endl; } Why does voteTally[v]++; work? It turns out that when you access a Map's value, you get back a reference! Therefore, updating it here allows it to update inside the map. Cool! It is equivalent to the following: int& currentTotal = voteTally[v]; currentTotal++; // update inside the map Notice how we looped over the map - we only get the keys, and have to manually ask for each value from the key. Slide 18 Tallying Words Let's write a program to tally how many of each word is in a file
http://cs106b.stanford.edu/lectures/01-welcome/slides.html
Lecture 1: Welcome! CS 106B: Programming Abstractions Autumn 2020, Stanford University Computer Science Department Lecturers: Chris Gregg and Julie Zelenski Slide 2 Lecture 1: It is a Brave New World Instead of worrying about what you cannot control, shift your energy to what you can create. Roy T. Bennett, The Light in the Heart First: Welcome Frosh! Second: As you know, CS 106B is going to be completely online for the quarter. Course lectures will be delivered on Zoom in a "Webinar" format, and students who attend live will be able to ask typed questions that will be moderated by the co-instructor or head TA and passed to the lecturer. Lectures will also be recorded, and students can watch them at any time during or after lecture delivery. The course material will closely follow the regular CS 106B curriculum, and post-conditions for the course will be the same as any other quarter - in other words: we are going to do our best to give you an equivalent experience as during a normal quarter, and we hope you will put in the work to learn as much as you can. We will have more logistical details later in this slide deck. This is the third quarter in a row (including Summer) that the course has been fully online, and we have hopefully worked out most of the bugs. Slide 3 Today's Topics What day is it? asked Pooh. It's today, squeaked Piglet. My favorite day, said Pooh. A.A. Milne Instructor Introductions What is CS 106B? Goals for the Course Components of CS 106B Assignments, Grading, Due dates, Late days, Sections, Getting Help C++ Why C++? Qt Creator Our first program Our second program The importance of Data Structures Assignment 0 Slide 4 Instruction Team: Lecturers and Head CA Tell me and I forget, teach me and I may remember, involve me and I learn. - Benjamin Franklin Lecturers Chris Gregg Julie Zelenski Head CA Chase Davis Course Coordinator Nick Bowman Slide 5 Instruction Team: Section Leaders When you learn, teach, when you get, give. Maya Angelou There will be tons of Section Leaders, who will each lead a small online section, and will grade your work. They will also hold individual grading sessions (IGs), and they will staff the virtual LaIR for office hours. SLs are a tremendously dedicated group, and are outstanding teachers in their own right. Slide 6 What is CS 106B? Computer Science is no more about computers than astronomy is about telescopes. Edsger Dijkstra CS106B: Learn core ideas in how to model and solve complex problems with computers Complex Problem #1: Self Driving Cars Source Slide 7 What is CS 106B? The most important property of a program is whether it accomplishes the intention of its user. C.A.R. Hoare CS106B: Learn core ideas in how to model and solve complex problems with computers Complex Problem #2: Compressing Data Source Comcast says that I should get "Upload speeds up to 5 Megabits per second (Mbps)". If I did (I usually don't), it would be impossible to send uncompressed video to you through Zoom. Luckily, the H.264 video standard that streaming services like Zoom often use have an incredible 2000:1 compression ratio, meaning that we can accomplish it. At the end of the course, we will investigate (and you will program!) an encoding algorithm that produces lossless compression (Zoom is lossy compression, meaning that some data is lost, but hopefully not enough to compromise the viewability of the stream). Slide 8 What is CS 106B? Speech recognition and the understanding of language is core to the future of search and information, but there are lots of hard problems such as understanding how a reference works, understanding what 'he', 'she' or 'it' refers to in a sentence. ... That's just one of the millions of problems to solve in language. Ben Gomes, Head of Search at Google CS106B: Learn core ideas in how to model and solve complex problems with computers Complex Problem #3: Speech Recognition The fact that you can ask your phone, in your own language and with your own accent, a question and have it answer within seconds is incredible. The technology that allows this is not only complex, but it takes a tremendous amount of processing - your voice is analyzed in the cloud, not on your phone. Slide 9 CS 106B Goals A goal without a plan is just a wish. - Antoine de I think goals should never be easy, they should force you to work, even if they are uncomfortable at the time. -Michael Phelps One of CS 106B's goals: Learn core ideas in how to model and solve complex problems with computers To that end, we want to: Explore common abstractions Harness the power of recursion Learn and analyze efficient algorithms Slide 10 Explore Common Abstractions Abstraction is one of the greatest visionary tools ever invented by human beings to imagine, decipher, and depict the world. Jerry Saltz The first programming assignment I had in high school was to find the first 100 Fibonacci numbers. Instead, I thought it would be cooler to write a program to get the teacher's password and all the other students' passwords. And the teacher gave me an A and told the class how smart I was. Mitnick How are user passwords kept secure when logging into a website (or, why shouldn't a website ever be able to send you your password?) Slide 11 Explore Common Abstractions The radio doesn't want to play you until you're No.1 on Shazam, and you can't get No.1 on Shazam without getting played. and I How does Shazam figure out what song is playing by listening through your microphone? Slide 12 Explore Common Abstractions I'm so fast that last night I turned off the light switch in my hotel room and was in bed before the room was dark. Ali How can it be possible to search for a value in a data structure without having to look at any of the other values (or at least only a few other values)? I.e., how can we program super fast search? Source Slide 13 Explore Common Abstractions The best book on programming for the layman is 'Alice in Wonderland'; but that's because it's the best book on anything for the layman. Perlis What is a digital signature, and how can it be used to prove that I was the person that sent an email, or signed a document? Source Slide 14 Common Abstractions The effective exploitation of his powers of abstraction must be regarded as one of the most vital activities of a competent programmer. -Edsger Dijkstra How are user passwords kept secure when logging into a website (or, why shouldn't a website ever be able to send you your password?) How does Shazam figure out what song is playing by listening through your microphone? How can it be possible to search for a value in a data structure without having to look at any of the other values (or at least only a few other values)? I.e., how can we program super fast search? What is a digital signature, and how can it be used to prove that I was the person that sent an email, or signed a document? It turns out that all of these are solved with the same abstraction! They all use hashing, which we will talk about near the end of the course. By learning common abstractions, we can use those abstractions to solve many problems. See the course website to see the list of topics we will cover. Slide 15 CS 106B Goals CS106B: Learn core ideas in how to model and solve complex problems with computers In order to understand recursion you must first understand recursion. Unknown To that end, we want to: Explore common abstractions Harness the power of recursion Learn and analyze efficient algorithms Slide 16 Harness the power of recursion When students first encounter recursion, they often react with suspicion to the entire idea, as if they have just been exposed to some conjurer's trick rather than a critically important programming methodology. Eric S. Roberts The logic behind the recursive tree below takes about five lines of code: Slide 17 Harness the power of recursion Learning to think in this new way requires students to examine recursion from several different perspectives. -Eric Roberts Recursion is a powerful tool that we will learn - once you start thinking recursively, you will be able to solve many problems that would be extremely hard to solve without it. Slide 18 CS 106B Goals CS106B: Learn core ideas in how to model and solve complex problems with computers I took a computer-science course to fill a prerequisite at Stanford, and I realized that every day was a new problem, and every day you got to think about how to solve something new, how to reason through something new, how to develop an algorithm to solve for something you hadn't worked on before. Mayer To that end, we want to: Explore common abstractions Harness the power of recursion Learn and analyze efficient algorithms Slide 19 CS 106B: Learn Efficient Algorithms Efficiency is intelligent laziness. - David Dunham The following image is from a puzzle game that is part of a potential CS 106B assignment: Tiles are matched by ensuring that object halves make a pair - so, for instance, a bottle top in red must be next to (or above / below) a bottle bottom in red, as in the second and last tile in the top row. A puzzle is solved when all tiles match Slide 20 CS 106B: Learn Efficient Algorithms I will be ruthless in cutting out waste, streamlining structures and improving efficiency. - Theresa May The following is the solved puzzle: Edge-matching games are surprisingly difficult to solve by hand. Each tile can be oriented four ways, and each tile can be in any of the nine board positions. This gives a total of 9! * 4^9 combinations, or roughly 95 billion different positions. Knowing what you learned in CS 106A, you could probably write an algorithm that could enumerate all possible combinations, and test each one. If it took one microsecond to check each solution (pretty fast for a desktop computer!), it would take 95,000 seconds to solve the puzzle, or over 26 hours to completely solve the puzzle. But with the ideas you'll learn in CS 106B, you will be able to write an algorithm to find all correct solutions (and there are eight of them) in a quarter of a second! Slide 21 CS 106B: Course Information The Google algorithm was a significant development. I've had thank-you emails from people whose lives have been saved by information on a medical website or who have found the love of their life on a dating website. Tim Berners-Lee - Tim Berners-Lee (inventor of the World Wide Web) The class website is here: https://web.stanford.edu/class/cs106b/ It will have all announcements, general information, lecture slides, section handouts, and other resources. We will also be using the Ed Discussion forum this quarter, where you can ask and answer questions about course material (with runnable test code), and also discuss other course-related information. Slide 22 CS 106B: Course Components Many jobs at Google require math, computing, and coding skills, so if your good grades truly reflect skills in those areas that you can apply, it would be an advantage. But Google has its eyes on much more. - Thomas Friedman The mid-quarter assessment and final project will be detailed soon, but they should be a unique experience. We want section discussions to be robust, so we are including a section participation component. The assignments are the most important part of the course, and weighted accordingly. Important: If you are an undergraduate, you must take the course for 5 units. We will not assign grades to undergraduates who take the course for fewer than 5 units. Slide 23 CS 106B: Assignments in CS 106B When I've least expected it, an enormous opportunity or stroke of luck has crossed right under my nose. So I tell everybody, if you're passionate about what you do and you love it, do it. But do your homework. Because you'll never know when the opportunity is going to happen. - Julie Andrews Due Fridays (Assignments 0-4) or Wednesdays (Assignments 5-7), Midnight PDT (but will switch to PST on November 1) If you hand the assignment in on time, there will be a small bonus applied to your grade. If you hand it in by Sunday, Midnight, PDT, you don't get the bonus. Assignments won't be accepted after Sunday (Friday for assignments 5-7). Extensions approved by Chris, Julie, or Chase. Graded by your section leader. Interactive, one-on-one grading session. Graded on Style and Functionality. We will give you many exposed functionality tests, but we won't necessarily give you all of them for all assignments. Slide 24 CS 106B: Grading Style Style is the substance of the subject called unceasingly to the surface. - Victor Hugo Grade Description + Exceeds requirements. &#10003;+ Satisfies all requirements of the assignment. &#10003; Meets most requirements, but with some problems. &#10003;- Has more serious problems. - Better than nothing. Slide 25 CS 106B: Sections Poetry comes alive to me through recitation. - Natalie Merchant Weekly 50-min Zoom section led by awesome section leaders (the backbone of the class!) Signups begin Thursday at 5:00pm PDT Signups close Sunday at 5:00pm PDT Slide 26 You need to ask questions if you are confused The best scientists and explorers have the attributes of kids! They ask question and have a sense of wonder. They have curiosity. 'Who, what, where, why, when, and how!' They never stop asking questions, and I never stop asking questions, just like a five year old. - Sylvia Earle Please make judicious use of Ed Discussion, Section, and Office Hours! Slide 27 Getting Help I am going to change the world, and I'm talking to everybody in the possible world that I can get to that can help me to do that. - Abby Wambach Steps to get help in CS 106B: Ed Discussion Sign in to the LaIR / Instructor Office Hours Contact your Section Leader Email Chris, Julie, or Chase Slide 28 One Last Detail... Writing in C or C++ is like running a chain saw with all the safety guards removed. - Bob Gray Within C++, there is a much smaller and cleaner language struggling to get out. - Bjarne Stroustrup (the creator of C++) C++: an octopus made by nailing extra legs onto a dog. - Steve Taylor C++ Slide 29 C++ Writing in C or C++ is like running a chain saw with all the safety guards removed. - Bob Gray Although there are hundreds of computer languages, in CS 106B we will be using the C++ language, which is not the easiest language to learn, but it is powerful and popular (and will help you get an internship!) What is the most used language in programming? (select to show) Profanity! Slide 30 CS 106/107 languages If someone claims to have the perfect programming language, he is either a fool or a salesman or both. - Bjarne Stroustrup Class Language Year Created CS 106A Python 1990 CS 106AX Javascript 1995 CS 106B/X C++ 1983 CS 107 C 1972! Javascript and C++ have their syntax based on C (Python is a bit different) The languages are different enough that each does take time to learn. Slide 31 Your First C++ Program! And programming computers was so fascinating. You create your own little universe, and then it does what you tell it to do. - Vint Cerf (the "father of the internet") As you'll find out, learning a new language when you already know a language is not really that hard, especially for "imperative" languages like Java, C++, and C (and Javascript, Python, and Ruby, etc.) Non-imperative languages -"functional" languages - (LISP, Haskell, ML, etc.) take a completely different mentality to learn, and you'll get to those in later CS classes, like Programming Languages. Let's write our "Hello, World!" program in C++. Slide 32 Your First C++ Program! There are two ways to write error-free programs; only the third one works. - Alan Perlis Steps: Install Qt Creator (see install QT instructions) Download the Sample project Open the Sample.pro project file in Qt Creator In Qt Creator, "Configure Project" for your system Select Sources->main.cpp in the browser Now we're ready to code... Slide 33 Your First C++ Program! When someone says: "I want a programming language in which I need only say what I wish done", give him a lollipop. - Alan Perlis // Our first C++ program! // headers: #include <iostream> #include "console.h" // Stanford library using namespace std; // main int main() { cout << "Hello, World!" << endl; return 0; } Output: Hello, World! To compile: Select Build->Build Project "hello-world" (or or Alt-B) To run in "Debug" mode: Select Debug->Start Debugging->Start Debugging (or or Alt-Y) You should see a console window pop up that says, "Hello, World!" Slide 34 Your Second C++ Program! If people built houses the way we write programs, the first woodpecker would wipe out civilization. - Dennis Hall Let's write a more advanced program, one that creates a vector (which is similar to a list in Python), and populates the vector with 100,000 even integers from 0 to 198,998. You'll see that this looks somewhat different than the equivalent program in Python - ther are a number of differences in C++. For time reasons, we'll just write it in the same hello-world.cpp file. Slide 35 Your Second C++ Program! Software and cathedrals are much the same - first we build them, then we pray. - Sam Redwine // Populate a Vector // headers: #include <iostream> #include "console.h" // Stanford library #include "vector.h" // Stanford library using namespace std; const int NUM_ELEMENTS = 100000; // main int main() { Vector<int> myList; cout << "Populating a Vector with even integers less than " << (NUM_ELEMENTS * 2) << endl; for (int i=0; i < NUM_ELEMENTS; i++){ myList.add(i*2); } for (int i : myList) { cout << i << endl; } return 0; } Slide 36 The Importance of Data Structures Beware of bugs in the above code; I have only proved it correct, not tried it. - Donald Knuth One reason we care about data structures is, quite simply, time. Let's say we have a program that does the following (and times the results): Creates four "list-like" containers for data. Adds 100,000 elements to each container - specifically, the even integers between 0 and 198,998 (sound familiar?). Searches for 100,000 elements (all integers 0-100,000) Attempts to delete 100,000 elements (integers from 0-100,000) What are the results? Slide 37 The Importance of Data Structures Computer Science is embarrassed by the computer. - Alan Perlis Results: Processor: 2.7GHz Intel Core i7 (Macbook Pro), Compiler: clang++ Compile options: clang++ -Os -std=c++11 -Wall -Wextra ContainerTest.cpp -o ContainerTest Structure Overall(s) Unsorted Vector: 1.45973 Linked List: 8.17542 Binary Tree: 0.02734 Hash Table: 0.01316 Sorted Vector: 0.22202 Difference between unsorted vector and hash table: 111x Difference between linked list and hash table: 621x! Note: In general, for this test, we used optimized library data structures (from the "standard template library") where appropriate. The Stanford libraries are not optimized. Overall, the Hash Table "won" - but (as we shall see!) while this is generally a great data structure, there are trade-offs to using it. Slide 38 The Importance of Data Structures On two occasions I have been asked, - "Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?" In one case a member of the Upper, and in the other a member of the Lower House put this question. I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question. - Charles Babbage Structure Overall(s) Insert(s) Search(s) Delete(s) Unsorted Vector: 1.45973 0.00045 0.92233 0.53694 Linked List: 8.17542 0.00688 5.92075 2.24779 Binary Tree: 0.02734 0.02415 0.00199 0.00120 Hash Table: 0.01316 0.01116 0.00088 0.00112 Sorted Vector: 0.22202 0.14747 0.00206 0.07248 Why are there such discrepancies?? Some structures carry more information simply because of their design. Manipulating structures takes time Slide 39 HW 0 If you lie to the computer, it will get you. - Perry Farrar HW 0 is a "get to know the tools" assignment. Here is the Assignment 0 writeup. Installing Qt Creator will take the most time (multiple hours, in some cases). The rest of the assignment should not take more than half an hour to complete, and it includes configuring Qt Creator, running an example program, learning about the debugger, and filling out a form. Thursday night there will be a special LaIR to help install tools if necessary. Due: Friday, September 18th, at Noon PDT
http://cs106b.stanford.edu/lectures/05-stack-queue/slides.html
Stacks and Queues CS 106B: Programming Abstractions Fall 2020, Stanford University Computer Science Department Lecturers: Chris Gregg and Julie Zelenski Announcements Section starts this week! Section assignments were released yesterday, please check your email for your time assignment and Zoom information. If you have not yet signed up for a section, or you can no longer make your assigned section time, you can go to the CS198 Website and add yourself to any section that has an open spot. If you can't make any of the remaining section times, reach out to Nick. There will be a recorded video of section problems released on Canvas at the end of every week is meant to supplement your experience in section, not replace it. Assignment 1 is due on Friday! Assignment 2 will be released shortly after. Note on Ed usage: please reserve assignment code debugging questions for the LaIR or for instructor office hours. We have office hours coverage at many different points in the day throughout the week, and this environment is much more conducive to getting successful debugging help. Slide 2 Abstract Data Types We are about to discuss two new containers in which to store our data: the stack and queue containers. These are also known as abstract data types, meaning that we are defining the interface for a container, and how it is actually implemented under the hood is not of our concern (at this point!) An abstract data type is defined by its behavior from the point of view of the user of the data, and by the operations it can accomplish with the data. The stack and queue containers have similar interfaces, but they are used for very different problems, as we shall see. Slide 3 Stacks A stack is an abstract data type with the following behaviors / functions: push(value) - add an element onto the top of the stack pop() - remove the element from the top of the stack and return it peek() - look at the element at the top of the stack, but don't remove it isEmpty() - a boolean value, true if the stack is empty, false if it has at least one element. (note: a runtime error occurs if a pop() or peek() operation is attempted on an empty stack.) Why do we call it a stack? Because we model it using a stack of things: The push, pop, and peek operations are the only operations allowed by the stack ADT, and as such, only the top element is accessible. Therefore, a stack is a Last-In-First-Out (LIFO) structure: the last item in is the first one out of a stack. Slide 4 Stacks Despite the stack's limitations (and indeed, because of them), the stack is a very frequently used ADT. In fact, most computer architectures implement a stack at the very core of their instruction sets - both push and pop are assembly code instructions. Stack operations are so useful that there is a stack built in to every program running on your PC - the stack is a memory block that gets used to store the state of memory when a function is called, and to restore it when a function returns. Why are stacks used when functions are called? Let's say we had a program like this: main calls function1, which calls function2, which calls function3. First, function3 returns, then function2 returns, then function1 returns, then main returns. This is a LIFO pattern! Slide 5 Stacks: Tradeoffs What re some downsides to using a stack? No random access. You get the top, or nothing. No walking through the stack at all - you can only reach an element by popping all the elements higher up off first No searching through a stack. What are some benefits to using a stack? Useful for lots of problems - many real-world problems can be solved with a Last-In-First-Out model (we'll see one in a minute) Very easy to build one from an array such that access is guaranteed to be fast. Where would you have the top of the stack if you built one using a Vector? Why would that be fast? Slide 6 Reversing the words in a sentence Let's build a program from scratch that reverses the words in a sentence. Goal: reverse the words in a sentence that has no punctuation other than letters and spaces. How might we do this? Use a stack Read characters in a string and place them in a new word. When we get to a space, push that word onto the stack, and reset the word to be empty. Repeat until we have put all the words into the stack. Pop the words from the stack one at a time and print them out. Slide 7 Reversing the words in a sentence with a stack #include <iostream> #include "console.h" #include "stack.h" using namespace std; const char SPACE = ' '; int main() { string sentence = "hope is what defines humanity"; string word; Stack<string> wordStack; cout << "Original sentence: " << sentence << endl; for (char c : sentence) { if (c == SPACE) { wordStack.push(word); word = ""; // reset } else { word += c; } } if (word != "") { wordStack.push(word); } cout << " New sentence: "; while (!wordStack.isEmpty()) { word = wordStack.pop(); cout << word << SPACE; } cout << endl; return 0; } Output: Original sentence: hope is what defines humanity New sentence: humanity defines what is hope Slide 8 Next... Slide 9 Queues The next ADT we are going to talk about is a queue. A queue is similar to a stack, except that (much like a real queue/line), it follows a "First-In-First-Out" (FIFO) model: The first person in line is the first person served. The last person in line is the last person served. Insertion into a queue enqueue() is done at the back of the queue, and removal from a queue dequeue() is done at the front of the queue. Slide 10 Queues Like the stack, the queue Abstract Data Type can be implemented in many ways (we will talk about some later!). A queue must implement at least the following functions: enqueue(value) - add an element onto the back of the queue dequeue() - remove the element from the front of the queue and return it peek() - look at the element at the front of the queue, but don't remove it isEmpty() - a boolean value, true if the queue is empty, false if it has at least one element. (note: a runtime error occurs if a dequeue() or peek() operation is attempted on an empty queue). Example Queue<int> q; // {}, empty queue q.enqueue(42); // {42} q.enqueue(-3); // {42, -3} q.enqueue(17); // {42, -3, 17} cout << q.dequeue() << endl; // 42 (q is {-3, 17}) cout << q.peek() << endl; // -3 (q is {-3, 17}) cout << q.dequeue() << endl; // -3 (q is {17}) Slide 11 Queue Examples There are many real world problems that are modeled well with a queue: Jobs submitted to a printer go into a queue (although they can be deleted, so it breaks the model a bit) Ticket counters, supermarkets, etc. File server - files are doled out on a first-come-first served basis Call centers ("your call will be handled by the next available agent") The LaIR is a queue! Chris G's research! Scheduling work between a CPU and a GPU is queue based. Actual slide from Chris's Ph.D. dissertation defense: Slide 12 Queue Mystery Both the Stanford Stack and Queue classes have a size() function that returns the number of elements in the object. What is the output of the following code? Queue<int> queue; // produce: {1, 2, 3, 4, 5, 6} for (int i = 1; i <= 6; i++) { queue.enqueue(i); } for (int i = 0; i < queue.size(); i++) { cout << queue.dequeue() << " "; } cout << queue.toString() << " size " << queue.size() << endl; A. 1 2 3 4 5 6 {} size 0 B. 1 2 3 {4,5,6} size 3 C. 1 2 3 4 5 6 {1,2,3,4,5,6} size 6 D. none of the above Answer: Solution B. 1 2 3 {4,5,6} size 3 Reason: watch out! queue.size() changes while the loop runs! You have to be careful when looping and also checking the size of your container. Slide 13 Queue Idiom 1 If you are going to empty a stack or queue, a very good programming idiom is the following: Queue<int> queueIdiom1; // produce: {1, 2, 3, 4, 5, 6} for (int i = 1; i <= 6; i++) { queueIdiom1.enqueue(i); } while (!queueIdiom1.isEmpty()) { cout << queueIdiom1.dequeue() << " "; } cout << queueIdiom1.toString() << " size " << queueIdiom1.size() << endl; Output: 1 2 3 4 5 6 { } size 0 Slide 14 Queue Idiom 2 If you are going to go through a stack or queue once for the original values, a very good programming idiom is the following, which calculates the size of the queue only once: Queue<int> queueIdiom2; for (int i = 0; i < 6; i++) { queueIdiom2.enqueue(i + 1); } int origQSize = queueIdiom2.size(); for (int i=0; i < origQSize; i++) { int value = queueIdiom2.dequeue(); cout << value << " "; // re-enqueue even values if (value % 2 == 0) { queueIdiom2.enqueue(value); } } cout << endl; cout << queueIdiom2 << endl; Output: 1 2 3 4 5 6 {2, 4, 6} There will still be three values left in the queue (2, 4, 6), but we only looped through the queue for the original values. Slide 15 More advanced stack example When you were first learning algebraic expressions, your teacher probably gave you a problem like this, and said, "What is the result?" 5 * 4 - 8 / 2 + 9 The class got all sorts of different answers, because no one knew the order of operations yet (the correct answer is 25, by the way). Parenthesis become necessary as well (e.g., 10 / (8-3)). This is a somewhat annoying problem - it would be nice if there were a better way to do arithmetic so we didn't have to worry about order of operations and parenthesis. As it turns out, there is a "better" way! We can use a system of arithmetic called "postfix" notation - the expression above would become the following: 5 4 * 8 2 / - 9 + Slide 16 Postfix Example 5 4 * 8 2 / - 9 + Postfix notation* works like this: Operands (the numbers) come first, followed by an operator (+, -, *, /, etc.). When an operator is read in, it uses the previous operands to perform the calculation, depending on how many are needed (most of the time it is two). So, to multiply 5 and 4 in postfix, the postfix is 5 4 * To divide 8 by 2, it is 8 2 / There is a simple and clever method using a stack to perform arithmetic on a postfix expression: Read the input and push numbers onto a stack until you reach an operator. When you see an operator, apply the operator to the two numbers that are popped from the stack. Push the resulting value back onto the stack. When the input is complete, the value left on the stack is the result. *Postfix notation is also called "Reverse Polish Notation" (RPN) because in the 1920s a Polish logician named Jan invented "prefix" notation, and postfix is the opposite of postfix, and therefore so-called "Reverse Polish Notation" Slide 17 Postfix Example Code // Postfix arithmetic, implementing +, -, *, / #include <iostream> #include "console.h" #include "simpio.h" #include "stack.h" using namespace std; const string OPERATORS = "+-*x/"; const string SEPARATOR = " "; // function prototypes double parsePostfix(string expression); string getNextToken(string &expression); void performCalculation(Stack<double> &s, char op); // Postfix arithmetic, implementing +, -, *, / #include <iostream> #include "console.h" #include "simpio.h" #include "stack.h" using namespace std; const string OPERATORS = "+-*x/"; const string SEPARATOR = " "; // function prototypes double parsePostfix(string expression); string getNextToken(string &expression); void performCalculation(Stack<double> &s, char op); int main() { string expression; double answer; do { expression = getLine("Please enter a postfix expression (blank to quit): "); answer = parsePostfix(expression); cout << "The answer is: " << answer << endl << endl; } while (expression != ""); return 0; } int main() { string expression; double answer; do { expression = getLine("Please enter a postfix expression (blank to quit): "); if (expression == "") { break; } answer = parsePostfix(expression); cout << "The answer is: " << answer << endl << endl; } while (true); return 0; } string getNextToken(string &expression) { // pull out the substring up to the first space // and return the token, removing it from the expression string token; int sepLoc = expression.find(SEPARATOR); if (sepLoc != (int) string::npos) { token = expression.substr(0,sepLoc); expression = expression.substr(sepLoc+1,expression.size()-sepLoc); return token; } else { token = expression; expression = ""; return token; } } double parsePostfix(string expression) { Stack<double> s; string nextToken; while (expression != "") { // gets the next token and removes it from expression nextToken = getNextToken(expression); if (OPERATORS.find(nextToken) == string::npos) { // we have a number double operand = stringToDouble(nextToken); s.push(operand); } else { // we have an operator char op = stringToChar(nextToken); performCalculation(s,op); } } return s.pop(); } void performCalculation(Stack<double> &s, char op) { double result; double operand2 = s.pop(); // LIFO! double operand1 = s.pop(); switch(op) { case '+': result = operand1 + operand2; break; case '-': result = operand1 - operand2; break; // allow "*" or "x" for times case '*': case 'x': result = operand1 * operand2; break; case '/': result = operand1 / operand2; break; } s.push(result); } Example run: Please enter a postfix expression (blank to quit): 5 4 * 8 2 / - 9 + The answer is: 25 Please enter a postfix expression (blank to quit): 1 2 3 4 + + + The answer is: 10 Please enter a postfix expression (blank to quit): 1 2 3 4 - - - The answer is: -2 Please enter a postfix expression (blank to quit): 1 2 + 3 * 6 + 2 3 + / The answer is: 3 Please enter a postfix expression (blank to quit): 2 3 4 + * 6 - The answer is: 8 Slide 18 World's First Programmable Desktop Computer The HP 9100A Desktop Calculator: the world's first programmable scientific desktop computer - really, the first desktop computer. (Wired, Dec. 2000) RPN (postfix) Special algorithm for trigonometric and logarithmic functions Cost $5000 in 1968 ($37,000 today)
http://cs106b.stanford.edu/lectures/03-strings/slides.html
Lecture 3: Strings CS 106B: Programming Abstractions Fall 2020, Stanford University Computer Science Department Lecturers: Chris Gregg and Julie Zelenski Reading: Programming Abstractions in C++, Chapters 3 & 4 Slide 2 Announcements Section signups opened yesterday and will be open until Sunday, September 20th at 5pm PDT. Sign up on the CS198 Website. All listed section times are in PDT. Lecture Format We are currently working on finding a way to export the live Q&A logs and post them on the course website. For in-lecture questions, we want to start incorporating more live questions directly from students! If you want to ask a question, you have two options: Raise your virtual hand and we will unmute you and call on you Type your question in the Q&A window followed with "(ask live)" and we can give you a chance to ask your question live Assignment 0 is due today, Friday September 18th, 11:59pm PDT Assignment 1 will be released on Saturday early-afternoon PDT. Keep your eyes on the course website for an announcement once it's released! Slide 3 Today's Topics Strings C++ strings vs C strings Characters Member Functions Stanford Library extensions char The <cctype> library Slide 4 Strings in C++ Not this type of string: or this one: #include<string> ... string s = "hello"; A string is a sequence of characters, and can be the empty string: "" In C++, a string has "double quotes", not single quotes: "this is a string" 'this is not a string' Strings are similar to Python and Java strings, although the functions have different names and in some cases different behavior. The biggest difference between a Python or Java string and a C++ string is that C++ strings are mutable (changeable). The second biggest difference is that in C++, we actually have two types of strings (more on that in a bit) Slide 5 Strings and Characters Strings are made up of characters of type char, and the characters of a string can be accessed by the index in the string (this should be familiar): string stanfordTree = "Fear the Tree"; index: 0 1 2 3 4 5 6 7 8 9 10 11 12 character: 'F' 'e' 'a' 'r' ' ' 't' 'h' 'e' ' ' 'T' 'r' 'e' 'e' char c1 = stanfordTree[3]; // 'r' char c2 = stanfordTree.at(2); // 'a' Notice that chars have single quotes and are limited to one ASCII character. A space char is ' ', not '' (in fact, '' is not a valid char at all. It is hard to see on the slide, but there is an actual space character between the single quotes in a valid space char, and there is no space in the not-valid example) There are two ways to loop through the characters in a string: for (int i = 0; i < stanfordTree.length(); i++) { cout << i << " : '" << stanfordTree[i] << "'" << endl; } cout << endl; for (char c : stanfordTree) { cout << "'" << c << "'" << endl; } cout << endl; Output: 0 : 'F' 1 : 'e' 2 : 'a' 3 : 'r' 4 : ' ' 5 : 't' 6 : 'h' 7 : 'e' 8 : ' ' 9 : 'T' 10 : 'r' 11 : 'e' 12 : 'e' 'F' 'e' 'a' 'r' ' ' 't' 'h' 'e' ' ' 'T' 'r' 'e' 'e' Slide 6 ASCII The Caesar Cipher is an encryption formed by shifting letters to the left or right in an alphabet, and re-encoding a phrase with the new letters. For a Caesar Cipher of +3, all 'A's would become 'D's, all 'B's would become 'E's, etc. At the end of the alphabet, the letters wrap, so 'X's become 'A's, 'Y's become 'B's, and 'Z's become 'C's. Julius Caesar himself is said to have used this encryption scheme to discuss battle plans with his generals, and it was (in his time) never decrypted. Characters have a numerical representation, as shown in the ASCII table above. cout << (int) 'A' << endl; // 65 This means you can perform math on characters, but you need to be careful: string plainText = "ATTACK AT DAWN"; string cipherText = ""; int key = 5; // caesar shift by five // only works for uppercase! for (int i=0;i<(int)plainText.length();i++) { char plainChar = plainText[i]; char cipherChar; if (plainChar >= 'A' && plainChar <= 'Z') { cipherChar = plainText[i] + key; if (cipherChar > 'Z') { cipherChar -= 26; // wrap back around } } else { cipherChar = plainChar; } cipherText += cipherChar; } cout << "Plain text: " << plainText << endl; cout << "Cipher text: " << cipherText << endl; Output: Plain text: ATTACK AT DAWN Cipher text: FYYFHP FY IFBS Slide 7 The <cctype> library #include<cctype> This library provides functions that check a single char for a property (e..g, if it is a digit), or return a char converted in some way (e.g., to uppercase) isalnum: checks if a character is alphanumeric isalpha: checks if a character is alphabetic islower: checks if a character is lowercase isupper: checks if a character is an uppercase character isdigit: checks if a character is a digit isxdigit: checks if a character is a hexadecimal character iscntrl: checks if a character is a control character isgraph: checks if a character is a graphical character isspace: checks if a character is a space character isblank: checks if a character is a blank character isprint: checks if a character is a printing character ispunct: checks if a character is a punctuation character tolower: converts a character to lowercase toupper: converts a character to uppercase Examples: string mixed = "ab80c3d27"; cout << "The digits in " << mixed << ": " << endl; for (int i = 0; i < mixed.length(); i++) { if (isdigit(mixed[i])) { cout << mixed[i] << endl; } } string s = "my string"; for (int i = 0; i < s.length(); i++) { s[i] = toupper(s[i]); } cout << "Now " << s << " is all UPPERCASE." << endl; Slide 8 String Operators As in Python and Java, you can concatenate strings using + or += string s1 = "Chris"; string s2 = s1 + "Gregg"; // s2 == ChrisGregg Like in Python (but unlike) in Java, you can compare strings using relational operators: string s3 = "Zebra"; if ((s1 < s3) && (s3 != "Walrus")) { cout << s1 << " < " << s3 << endl; cout << "letters earlier in the alphabet are " << endl << "less than letters later in the alphabet." << endl; } cout << endl; s1[0] = tolower(s1[0]); // s1 now == "chris" if (s1 > s3) { cout << s1 << " > " << s3 << endl; cout << "UPPERCASE letters are less than LOWERCASE letters" << endl; } Output: Chris < Zebra letters earlier in the alphabet are less than letters later in the alphabet. chris > Zebra UPPERCASE letters are less than LOWERCASE letters Unlike in Python and Java, strings are mutable and can be changed (!): s3.append("Giraffe"); // s2 is now "ZebraGiraffe" s3.erase(4,3); // s2 is now "Zebrraffe" (which would be a very cool animal) s3[5] = 'i'; // s2 is now "Zebrriffe" s3[9] = 'e'; // BAD!!!1! PROGRAM MAY CRASH! POSSIBLE BUFFER OVERFLOW! NO NO NO! Unlike in Python and Java, C++ does not bounds check for you! The compiler doesn't check for you, and Qt Creator won't warn you about this. We have entered the scary territory of you must know what you are doing. Buffer overflows are a critical way for viruses and hackers to do their dirty work, and they can also cause hard to track down bugs. The following functions are part of the string class, and can be useful: s.append(str): add text to the end of a string s.compare(str): return -1, 0, or 1 depending on relative ordering s.erase(index, length) : delete text from a string starting at given index s.find(str) s.rfind(str): first or last index where the start of str appears in this string (returns string::npos if not found) s.insert(index, str): add text into a string at a given index s.length() or s.size(): number of characters in this string s.replace(index, len, str): replaces len chars at given index with new text s.substr(start, length) or s.substr(start): the next length characters beginning at start (inclusive); if length omitted, grabs till end of string Slide 9 C++ -vs- C strings C++ has (confusingly) two kinds of strings: C strings (char arrays), inherited from the C language C++ strings (string objects), which is part of the standard C++ library. When possible, declare C++ strings for better usability (you will get plenty of C strings in CS 107!) Any string literal such as "hi there" is a C string. C strings don't have member functions, and you must manipulate them through regular functions. You also must manage the memory properly - this is SUPER IMPORTANT and involves making sure you have allocated the correct memory - again, this will be covered in detail in CS 107. E.g., C strings do not have a .length() function (there are no member functions, as C strings are not part of a class. You can convert between string types: string("text"); converts C string literal into C++ string string s = someCStr; converts a C string into a C++ string string.c_str() returns a C string out of a C++ string Slide 10 C string issues Does not compile! C strings can't be concatenated with + string hiThere = "hi" + "there"; These three all compile and work properly. string hiThere = string("hi") + "there"; string hello = "hi"; hello += "there"; Bug: sets n to the memory address of the C string "42" (ack!). Qt Creator will produce a warning. int n = (int) "42"; Works - this explicitly converts "42" to a C++ string, and then uses the Stanford library, stringToInteger() to convert to an int. int n = stringToInteger("42"); Slide 11 More C string issues Both bugs. Produces garbage, not "hi?" or "hi42" (memory address stuff). string hiQuestion = "hi" + '?'; // C-string + char string hi41 = "hi" + 41; // C-string + int Does work because of the empty C++ string at the beginning string okayHighQuestion = string("") + "hi" + '?'; Works, because of auto-conversion. string howdy = "hi"; howdy += '?'; // "hi?", char '?' is converted to string Adds character with ASCII value 41, ')', doesn't produce "hi?41". s += 41; // "hi?)" Works, because of conversion from int to string using a function. s += integerToString(41); // "hi?41" Slide 12 Mystery Function! What is the output? void mystery(string a, string &b) { a.erase(0,1); b += a[0]; b.insert(3, "FOO"); } int main() { string a = "Stanford"; string b = "Tree"; mystery(a,b); cout << a << " " << b << endl; return 0; } Answer: Solution Stanford TreFOOet Slide 13 The Stanford String library #include "strlib.h" These are not string class functions. endsWith(str, suffix)startsWith(str, prefix): returns true if the given string begins or ends with the given prefix/suffix text integerToString(int)realToString(double)stringToInteger(str)stringToReal(str): returns a conversion between numbers and strings equalsIgnoreCase(s1, s2): true if s1 and s2 have same chars, ignoring casing toLowerCase(str)toUpperCase(str): returns an upper/lowercase version of a string trim(str): returns string with surrounding whitespace removed Use as follows (remember, not member functions of the string class!): if (startsWith(nextString, "Age: ")) { name += integerToString(age) + " years old"; } Slide 14 String recap C++ has both C strings and C++ strings. Both are, under the hood, simply arrays of characters. C++ strings handle details for you automatically, C-strings do not. C++ strings are much more functional and easier to use Many times (but not always), C-strings auto-convert to C++ strings when necessary Characters are single-quoted, single-character ASCII numerical values (be careful when applying arithmetic to them) C++ strings have many functions you can use, e.g., s.length() and s.compare() The Stanford library also has some extra string functions, which are not part of the string class, but are helpful Slide 15 References and Advanced Reading References (in general, not the C++ references!): Chapter 3 of Textbook <cctype> functions Caesar Cipher Advanced Reading: C++ strings vs C strings String handling in C++ Stackoverflow: Difference between string and char[] types in C++
http://cs106b.stanford.edu/assignments/1-cpp/soundex.html
This program is all about C++ string processing, with a little bit of file reading and use of Vector. For this program, you will be writing code and making changes in soundex.cpp, as well as answering a few short answer questions in short_answer.txt. You can find this text file under "Other Files" in the Qt Creator project pane. Here is a summary of what you can expect to complete in this part of the assignment: You will evaluate the efficacy of a real-world algorithm used by the U.S. Census to encode the phonetic pronunciation of surname. You will implement the algorithm, developing a function that can take surnames as input and produce phonetic encodings as output. You will implement a console program that allows users to input a surname and then find all matches in a database of Stanford surnames that have the same encoding. Why phonetic name matching is useful One of the more pesky features of the English language is the lack of consistency between phonetics and spelling. Matching surnames is a particularly vexing problem because many common surnames come in a variety of spellings and continue to change over time and distance. Many of these variations are the result of incorrectly inputted data, cultural differences in spelling, and transliteration errors. Traditional string matching algorithms that use exact match or partial/overlap match perform poorly in this messy milieu of real world data. In contrast, the Soundex system groups names by phonetic structure to enable matching by pronunciation rather than literal character match. This make tasks like tracking genealogy or searching for a spoken surname easier. Soundex was patented by Margaret O'Dell and Robert C. Russell in 1918, and the U.S. Census is a big consumer of Soundex along with genealogical researchers, directory assistance, and background investigators. The Soundex algorithm is a coded index based on the way a name sounds rather than the way it is spelled. Surnames that sound the same but are spelled differently, like "Vaska," "Vasque," and "Vussky," have the same code and are classified together. How Soundex codes are generated Before you get started with coding, we want to introduce the Soundex algorithm itself. A Soundex code is a four-character string in the form of an initial letter followed by three digits, such as Z452. The initial letter is the first letter of the surname, and the three digits are drawn from the sounds within the surname using the following algorithm: Discard all non-letter characters from surname: dashes, spaces, apostrophes, and so on. Encode each letter as a digit using the table below. Digit represents the letters 0 A E I O U H W Y 1 B F P V 2 C G J K Q S X Z 3 D T 4 L 5 M N 6 R Coalesce adjacent duplicate digits from code (e.g. 222025 becomes 2025). Replace the first digit of code with the first letter of the original name, converting to uppercase. Remove all zeros from code. Make the code exactly length 4 by padding with zeros or truncating the excess. To ensure you understand the construction, get a piece of scratch paper and manually compute a few names, such as "Curie" (C600) and "O'Conner" (O256). Q11. What is the Soundex code for "Angelou"? What is the code for your own surname? Decomposing the problem Your best strategy for approaching a complex algorithm like this is to decompose the problem into smaller, more manageable tasks and proceed step by step, testing as you go. Q12. Before writing any code, brainstorm your plan of attack and sketch how you might decompose the work into smaller tasks. Briefly describe your decomposition strategy. To get you started, we're going to walk you through what it might look like to decompose and implement the first step of the Soundex algorithm. Decomposition is important here because if you tried to implement a single function that accomplished the whole Soundex algorithm all in one go, you could end up with one big, unwieldy piece of code. However, if you break down the problem into a number of different steps, each corresponding to its own helper function, you can develop these helper functions one at a time and test each one as you go. For example, Step 1 of the Soundex algorithm might correspond to a helper function to remove non-letters from the string. The C++ library function isalpha will report whether a character is alphabetic, and the function substr can be used to extract subsequences from a string. Putting those two together, we have this starting point (provided for you in soundex.cpp): // WARNING: Code is buggy! Use unit tests to identify which inputs are mishandled string removeNonLetters(string s) { for (int i = 0; i < s.length(); i++) { if (!isalpha(s[i])) { // remove the character at index i s = s.substr(0,i) + s.substr(i+1); } } return s; } Testing, testing, testing With an implementation of removeNonLetters drafted, the next step is to test it. We've provided a few unit tests to get you started. Run the program and when prompted, select the option from the menu for tests from soundex.cpp. When you run these provided tests, you will see that the tests for the removeNonLetters function all pass. From this, you might conclude that the function is good to go. However, there is a problem lurking within the code that has yet to be uncovered! Review our provided test cases to see what sorts of inputs we tested, and, more importantly, what sorts of inputs we didn't test. Brainstorm what those missing cases are and then add them. Think about edge cases that could lurk in the extremes or cases that are uniquely distinguished from the provided tests. As a hint, notice that all of the provided test cases have exactly one non-letter in the input. Add your own tests that target inputs at the extremes or that are otherwise unusual, such as input that is completely empty or composed of only non-letters. You should add at least 1 new student test to expose the bug in the given implementation of removeNonLetters. Your goal in writing tests is to enumerate a comprehensive set of tests that brings any bugs in the code to light so you can debug and fix them. Good tests are the key to writing robust software. A great developer is not only a great coder, but also a great tester. Debugging a failing test case Once you have added a test case that fails, use the debugger to get more information about how the function has gone wrong. Set a breakpoint within the code block that contains your test case. A good place to stop is on the line with the operation that you want to trace through, like so: Now run the tests while using the debugger. When you hit the breakpoint, you can single step through the call to removeNonLetters while watching the debugger's variables pane to see the different values that your variables take on. This "step-and-watch" approach is the same as you used in the Assignment 0 debugging tutorial. From this point, you should be able to find the bug and fix it ahead and do that! Implementing the Soundex algorithm Once you've fixed the bug from above, you have a working helper function to complete the first step of the Soundex algorithm. From here, you'll follow a similar process to complete the remaining steps of the full Soundex algorithm. Your ultimate goal is to implement the function: string soundex(string s) But not in one fell sweep. Instead, revisit the instructions in the How Soundex codes are generated section and follow this process: Pick a small task or part of the algorithm to implement. Define a new helper function to accomplish that task. Write student tests that confirm the expected behavior of the new function. Fill in the code for your helper function, debugging as you go. Continue writing code and debugging until you have passed all the tests from the previous step. Rinse and repeat. Your end goal is to pass all of the top-level Soundex tests that we've provided for you in the starter code. Once you pass all these tests, you've got a pretty solid working implementation of the Soundex algorithm! As always though, it is important to add tests of your own to make sure you have covered the full possible range of inputs into your function. Make sure to add some tests on the completed high-level soundex function, in addition to the tests that you're writing for your decomposed helper functions. Note: Remember, the Soundex algorithm does not distinguish case in the input; letters can be lower, upper, or mixed case. The first character in the result code is always in upper case. Developing a census search program The capstone of this part of the assignment is to build a program that emulates the way in which the U.S. Census uses the Soundex algorithm. In particular, the console program that you will write allows a user to perform a Soundex search on a database of surnames. You should implement the following function prototype: void soundexSearch(string filepath) This function defines a console program that allows the user to specify a text file containing a database of names to search. The program then repeatedly allows the user to enter a surname to look up in the database. For each surname that is entered, the program calculates the Soundex code of the entered name and then finds all names in the database that have a matching Soundex code. You should implement the following steps when writing this program: Read a database of surnames from the specified text file. This step is provided for you in the starter code. The "database" is simply a Vector<string>. Prompt the user to enter a surname. The function getLine from "simpio.h" will be helpful here. Compute the Soundex code of the surname. Iterate over the database, compute Soundex code of each name, and gather a vector of those surnames with a matching code. Print the matches in sorted order. The Vector has a handy sort() operation (you can use vec.sort() where vec is the name of your vector), and you can print a vector using the << operator, e.g. cout << vec << endl;. Please note that the sort() function sorts the vector in place and does not return a value. Repeat steps 2-5 until the user indicates that they are done. In order to run this code, we will need to switch back from running in testing mode to running in main mode. Go to main.cpp and change the SELECTED_TESTS argument back to NO_TESTS. Then, comment out the call to findPerfects from the first part of the assignment and uncomment the call to soundexSearch. Once you have completed these two steps, running your program should bring up a console window that allows you to test your database search console program. Below is the output from a sample run of the program. If you are able to match this sample output exactly, then you have successfully completed this part of the assignment! Read file res/surnames.txt, 26584 names found. Enter a surname (RETURN to quit): Zelenski Soundex code is Z452 Matches from database: {"Zelenski", "Zelnick", "Zelnik", "Zielonka"} Enter a surname (RETURN to quit): hanrahan Soundex code is H565 Matches from database: {"Hammerman", "Hamren", "Haner-McAllister", "Hanrahan"} Enter a surname (RETURN to quit): All done! Considering limitations of Soundex Now that you understand how Soundex works, we want you to consider some of its limitations. The U.S. census has extensively used a variation of the Soundex algorithm for almost a century, but just because it has been used in practice does not make it a perfect algorithm! Q13. Think about one or more examples of a class of names that the Soundex system might not work well for. Explain what this class of names is and why the system might incorrectly group them or mis-categorize one of the names. (Hint: You may find it useful to look over the other possible phonetic systems in Extending Your Phonetic Algorithm.) A consistent theme of this class is that we want you to consider the ethical implications of the algorithms that we ask you to implement. While using computational systems to solve problems can be powerful, the cases that these systems ignore or perform poorly on can have a disproportionate negative impact on people. Considering a wide variety of use cases is part of why testing your code is so important! Additional advice for testing Testing is key for implementing this problem. Make sure that you take advantage of the SimpleTest testing framework! If a test is failing, put a breakpoint inside the failing test, and step through the code line by line using the debugger. Keep an eye on the variables pane will be your most helpful resource to figure out what is going wrong! The starter project includes a text file res/surnames.txt containing the surnames of Stanford students, faculty, and staff for the use of Soundex search. There are some 26,000 unique surnames within the Stanford community, wow! For early testing, you may want to change the program to read names from the file res/small.txt instead which contains a tiny set of names that is easier to debug on. Useful resources On the Qt Creator window, there is search field in the lower left labeled with a magnifying glass icon. If you enter the name of a header file (e.g. strlib.h or cctype), Qt will display its contents. This is a quick way to review the features of a given library. You can also browse/search all library documentation online: Stanford C++ Library Documentation C++ Standard Library Documentation For this assignment, you will be using library functions that operate on strings and characters, in particular: The standard library string functions length, substr, concat, replace, etc. will be useful, along with the Stanford-specific string functions in strlib.h. For case conversions, you can use the functions in cctype to convert a single char or string functions in strlib.h to convert an entire string. Remember that C++ treats individual characters differently than strings of characters. Individual characters have type char and are enclosed in single quotes (i.e. 'a' not "a"). Strings have type string and enclose a sequence of characters in double-quotes (i.e. "hello" not 'hello'). There are helpful functions in strlib.h to aid you with converting between the two, including the charToString and stringToChar functions. In a similar vein, the integer 5 is a distinct beast from the digit character '5' or the string "5". Take care to express the type carefully to match your intentions. Guide to Transitioning from Python to C++ Textbook Soundex references https://www.archives.gov/research/census/soundex Online Soundex code calculator: http://www.eogn.com/soundex/ Extending your phonetic algorithm If you have completed the assignment and want to go further, we encourage you to try working on an extension! There are many other phonetic systems out there besides Soundex. Here is a non-extensive list: Daitch-Mokotoff Beider-Morse Metaphone New York State Identification and Intelligence System Try implementing one of these other systems and see if you can get better or more intuitive surname matches! When implementing an extension, add a new .cpp file to your project that contains the extension code, keeping it separate from the regular Soundex implementation. If you have other creative ides for extensions, run them by the course staff, and we'd be happy to give you guidance!
http://cs106b.stanford.edu/resources/style_guide.html
You may think the motivation for good style is earning that from your section leader, but the most important beneficiary of your efforts is you yourself. Committing yourself to writing tidy, well-structured code from the start sets you up for good times to come. Your code will be easier to test, will have fewer bugs, and what bugs there are will be more isolated and easier to track down. You finish faster, your results are better, and your life is more pleasant. What's not to like? The guidelines below identify some of style qualities we will be looking for when grading your programs. As with any complex activity, there is no one "best" style, nor a definitive checklist that covers every situation. That said, there are better and worse choices and we want to guide you toward the better choices. In grading, we will expect that you make a concerted effort to follow these practices. While it is possible to write code that violates these guidelines and yet still exhibits good style, we recommend that you adopt our habits for practical purposes of grading. If you have theoretical points of disagreement, come hash that out with us in person. In most professional work environments you are expected to follow that company's style standards. Learning to carefully obey a style guide, and writing code with a group of other developers where the style is consistent among them, are valuable job skills. This guide gives our general philosophy and priorities, but even more valuable will be the guidance on your own particular style choices. Interactive grading with your section leader is your chance to receive one-on-one feedback, ask questions, and learn about areas for improvement. Don't miss out on this opportunity! Layout, Indentation, and Whitespace Indentation: Consistent use of whitespace/indentation always! Proper whitespace/indentation illuminates the structure of your program and makes it easier to follow the code and find errors. Increment indent level on each opening brace {, and decrement on each closing brace }. Chose an increment of 2-4 spaces per indent level. Be consistent. Do not place more than one statement on the same line. // confusing, hard to follow while (x < y) { if (x != 0) { binky(x); } else { winky(y); y--; }} return x; // indentation follows structure while (x < y) { if (x != 0) { binky(x); } else { winky(y); y--; } } return x; Long lines: When any line is longer than 100 characters, break it into two lines. Indent the overflow text to align with text above. result = longFunctionName(argument, 106 * expression * variable) + variable - longerFunctionName() + otherFunction(variable); result = longFunctionName(argument, 106 * expression * variable) + variable - longerFunctionName() + otherFunction(variable); Blank lines: Use blank lines to separate functions and logical groups of statements within a function. Whitespace: Add space between operators and their operands. Add parentheses to show grouping where precedence might be unclear to reader. int root = (-b+sqrt(b*b-4*a*c))/2*a; int root = (-b + sqrt((b * b) - (4 * a * c))) / (2 * a); Names Choose meaningful identifiers. This reduce the cognitive load for reader and self-documents the purpose of each variable and function. Nouns for variable names: For variables, the question is "What is it?" Use a noun (name,scores) add modifier to clarify (courseName, maxScore). Do not repeat the variable type in its name (not titleString, just title). Avoid one-letter names like a or p (exceptions for loop counters i, j or, coordinates x and y). Never name a variable l, much too easily confused with the number one. Verbs for function names: For functions, the question is "What does it do?" Functions which perform actions are best identified by verbs ( findSmallest, stripPunctuation, drawTriangle). Functions used primarily for their return value are named according to property being returned (isPrime, getAge). Use named constants: Avoid sprinkling magic numbers throughout your code. Instead declare a named const value and use where that value is needed. This aids readability and gives one place to edit value when needed. const int VOTING_AGE = 18; Capitalization: Use camel-case for names of functions and variables (countPixels), capitalize names of classes/types (GridLocation), and uppercase names of constants (MAX_WIDTH). Conventions allows reader to quickly determine which category a given identifier belongs to. Variable scope Scope: Declare variables in the narrowest possible scope. For example, if a variable is used only inside a loop, declare it inside the scope for the loop body rather than at the top of the function or at the top of the file. Don't reuse same name in inner scope: Declaring a variable in inner scope with same name as a variable in outer scope will cause inner use of name to "shadow" the outer definition. Not only is this confusing, it often leads to difficult bugs. No global variables: Do not declare variables at global scope. When there is information to be shared across function calls, it should flow into and out via parameters and return values, not reach out and access global state. Use of C++ language features Prefer C++ idioms over C idioms: Since C++ is based on C, there is often a "C++ way" to do a given task and also a "C way". For example, the "C++ way" to print output is via the output stream cout, while the "C way" is using printf. C++ strings use the string class, older code uses the C-style char*. Prefer the modern C++ way. // old school char* str = "My message"; printf("%s\n", str); // modern and hip string str = "My message"; cout << str << endl; for vs while: Use a for loop when the number of repetitions is known (definite); use a while loop when the number of repetitions is unknown (indefinite). // loop exactly n times for (int i = 0; i < n; i++) { ... } // loop until there are no more lines string str; while (input >> str) { ... } break and continue in loops: Wherever possible, a loop should be structured in the ordinary way with clear loop start, stop, advance and no disruptive loop control. That said, there are limited uses of break that are okay, such as loop-and-a-half (while(true) with break) or need to exit loop mid-iteration. Use of continue is quite rare and often confusing to reader, better to avoid. Use of fallthrough in switch cases: A switch case should almost always end with a break or return that prevents continuing into the subsequent case. In the very rare case that you intend to fallthrough, add a comment to make that clear. Accidental fallthrough is the source of many a difficult bug. switch (val) { case 1: handleOne(); break; case 2: handleTwo(); // NOTE: fallthrough *** case 3: handleTwoOrThree(); return statements Although it is allowed for a function to have multiple return statements, in most situations it is preferable to funnel through a single return statement at the end of the function. An early return can be a clean option for a recursive base case or error handled at the beginning of a function. return can also serve as a loop exit. However, scattering other return throughout the function is not a good idea- experience shows they are responsible for a disproportionate number of bugs. It is easy to overlook the early-return case and mistakenly assume the function runs all the way to its end. Always include {} on control statements: The body an if/else, for, while, etc., should always be wrapped in {} and have proper line breaks, even if the body is only a single line. Using braces prevents accidents like the one shown below on left. // ugh if (count == 0) error("not found"); for (int i = 0; i < n; i++) draw(i); if (condition) doFirst(); doSecond(); // inside? Indent looks so, but no braces! // better if (count == 0) { error("not found"); } for (int i = 0; i < n; i++) { draw(i); } if (condition) { doFirst(); doSecond(); } Booleans: Boolean expressions are prone to redundant/awkward constructions. Prefer concise and direct alternatives. A boolean value is true or false, you do not need to further compare to true/false or convert a boolean expression to true/false. if (isWall == true) { ... } if (matches > 0) { return true; } else { return false; } // better if (isWall) { ... } return (matches > 0); Favor &&, ||, and ! over and, or, and not: For various reasons mostly related to international compatibility, C++ has two ways of representing the logical connectives AND, OR, and NOT. Traditionally, the operators &&, ||, and ! are used for AND, OR, and NOT, respectively, and the operators are the preferred ways of expressing compound booleans. The words and, or, and not can be used instead, but it would be highly unusual to do so and a bit jarring for C++ programmers used to the traditional operators. // non-standard if ((even and positive) or not zero) { ... } // preferred if ((even && positive) || !zero) { ... } Use error to report fatal conditions: The error function from the Stanford library can be used to report a fatal error with your custom message. The use of error is preferred over throwing a raw C++ exception because it plays nicely with the debugger and our SimpleTest framework. // raw exception if (arg < 0) { throw arg; } // preferred if (arg < 0) { error("arg must be positive!"); } Efficiency In CS106B, we value efficient choices in data structure and algorithms especially where there is significant payoff, but are not keen on micro-optimizations that serve to clutter the code for little gain. Better BigO class: Given a choice of options for implementing an algorithm, the preference is generally for the one with better Big O, i.e. an O(NlogN) algorithm is preferable to quadratic O(N^2), constant O(1) or logarithmic O(logN) beats out linear O(N). Choose best performing ADT for situation: For example, if you need to do many lookup operations on collection, Set would be preferable to Vector because of efficient contains operation. All Stack/Queue operations are O(1) making Stack an ideal choice if you only add/remove at top or Queue perfect if you remove from head and add at tail. There is a small win for choosing HashSet/HashMap over Set/Map when you do not require access to elements in sorted order. Save expensive call result and re-use: If you are calling an expensive function and using its result multiple times, save that result in a variable rather than having to call the function multiple times. This optimization is especially valuable inside a loop body. // computes search twice if (reallySlowSearch(term) >= 0) { remove(reallySlowSearch(term)); } // avoid recompute int index = reallySlowSearch(term); if (index >= 0) { remove(index); } Avoid copying large objects: When passing an object as a parameter or returning an object from a function, the entire object must be copied. Copying large objects, such as collection ADTs, can be expensive. Pass the object by reference avoid this expense. The client and the function then share access to the single instance. // slow because of copying void process(Set<string> data) { ... } Vector<int> fillVector() { Vector<int> v; // add data to v ... return v; // makes copy } // improved efficiency void process(Set<string>& data) { ... } // shares vector without making copy void fillVector(Vector<int>& v) { // add data to v ... } Unify common code, avoid redundancy When drafting code, you may find that you repeat yourself or copy/paste blocks of code when you need to repeately perform the same/similar tasks. Unifying that repeated code into one passage simplifies your design and means only one piece of code to write, test, debug, update, and comment. Decompose to helper function: Extract common code and move to helper function. // repeated code if (g.inBounds(left) && g[left] && left != g[0][0] ) { return true; } else if g.inBounds(right) && g[right] && right != g[0][0] ) { return true; } // unify common into helper bool isViable(GridLocation loc, Grid<bool>& g) { return g.inBounds(loc) && g[loc] && loc != g[0][0]); } ... return isViable(left, g) || isViable(right, g); Factoring out common code: Factor out common code from different cases of a chained if-else or switch. // repeated code if (tool == CIRCLE) { setColor("black"); drawCircle(); waitForClick(); } else if (tool == SQUARE) { setColor("black"); drawSquare(); waitForClick(); } else if (tool == LINE) { setColor("black"); drawLine(); waitForClick(); } // factor out common setColor("black"); if (tool == CIRCLE) { drawCircle(); } else if (tool == SQUARE) { drawSquare(); } else if (tool == LINE) { drawLine(); } waitForClick(); Function design A well-designed function exhibits properties such as the following: Performs a single independent, coherent task. Does not do too large a share of the work. Is not unnecessarily entangled with other functions. Uses parameters for flexibility/re-use (rather that one-task tool). Clear relationship between information in (parameters) and out (return value) Function structure: An overly long function (say more than 20-30 lines) is unwieldy and should be decomposed into smaller sub-functions. If you try to describe the function's purpose and find yourself using the word "and" a lot, that probably means the function does too many things and should be subdivided. Value vs. reference parameters: Use reference parameters when need to modify value of parameter passed in, or to send information out from a function. Don't use reference parameters when it is not necessary or beneficial. Notice that a, b, and c are not reference parameters in the following function because they don't need to be. /* * Solves a quadratic equation ax^2 + bx + c = 0, * storing the results in output parameters root1 and root2. * Assumes that the given equation has two real roots. */ void quadratic(double a, double b, double c, double& root1, double& root2) { double discr = sqrt((b * b) -(4 * a * c); root1 = (-b + discr) / (2 * a); root2 = (-b - discr) / (2 * a); } Prefer return value over reference 'out' parameter for single value return: If a single value needs to be sent back from a function, it is cleaner to do with return value than a reference out parameter. // harder to follow void max(int a, int b, int& result) { if (a > b) { result = a; } else { result = b; } } // better as int max(int a, int b) { if (a > b) { return a; } else { return b; } } Avoid "chaining" calls, where many functions call each other in a chain without ever returning to main. Here is a diagram of call flow with (left) and without (right) chaining: // chained control flow main | +-- doGame | +-- initAndPlay | +-- configureAndPlay | +-- readCubes | +-- playGame | +-- doOneTurn // better structured as main | +-- welcome | +-- initializeGame | | | +-- configureBoard | | | +-- readCubes | +-- playGame | | | +-- doOneTurn Commenting Some of the best documentation comes from giving types, variables, functions, etc. meaningful names to begin and using straightforward and clear algorithms so the code speaks for itself. Certainly you will need comments where things get complex but don't bother writing a large number of low-content comments to explain self-evident code. The audience for all commenting is a C++-literate programmer. Therefore you should not explain the workings of C++ or basic programming techniques. Some programmers like to comment before writing any code, as it helps them establish what the program is going to do or how each function will be used. Others choose to comment at the end, now that all has been revealed. Some choose a combination of the two, commenting some at the beginning, some along the way, some at the end. You can decide what works best for you. But do watch that your final comments do match your final result. It's particularly unhelpful if the comment says one thing but the code does another thing. It's easy for such inconsistencies to creep in the course of developing and changing a function. Be careful to give your comments a once-over at the end to make sure they are still accurate to the final version of the program. File/class header: Each file should have an overview comment describing that file's purpose. For an assignment, this header should include your name, course/section, and a brief description of this file's relationship to the assignment. Citing sources: If your code was materially influenced by consulting an external resource (web page, book, another person, etc.), the source must be cited. Add citations in a comment at the top of the file. Be explicit about what assistance was received and how/where it influenced your code. Function header: Each function should have a header comment that describes the function's behavior at a high level, as well as information about: Parameters/return: Give type and purpose of each parameter going into function and type and purpose of return value. Preconditions/assumptions: Constraints/expectations that client should be aware of.("this function expects the file to be open for reading"). Errors: List any special cases or error conditions the function handles (e.g. "...raises error if divisor is 0", or "...returns the constant NOT_FOUND if the word doesn't exist"). Inline comments: Inline comments should be used sparingly where code complex or unusual enough to warrant such explanation. A good rule of thumb is: explain what the code accomplishes rather than repeat what the code says. If what the code accomplishes is obvious, then don't bother. // inline babbling just repeats what code already says, don't! int counter; // declare a counter variable counter++; // increment counter while (index < length) // while index less than length TODOs: Remove any // TODO: comments from a program before turning it in. Commented-out code: It is considered bad style to submit a program with large chunks of code "commented out". It's fine to comment out code as you are working on a program, but if the program is done and such code is not needed, just remove it. Doc comments: You can use "doc" style (/** ... */) comment style if you like, but it is not required for this class. A style of commenting using // or /* ... */ is just fine.
http://cs106b.stanford.edu/resources/submit_checklist.html
This handy checklist is designed to help confirm your code is fully ready to go before you submit it. Before you send it in for grading, take a few minutes to work through this checklist. Functionality I've re-read the assignment writeup and verified my program matches the required specification. I've reviewed my code and understand each line of code I've written, why it's there, and why it's necessary. Test cases I've run all of the provided test cases against my code and resolved any test failures. I've supplemented the provided test cases with student tests of my own. For each part of the assignment, I've written at least one test case to make sure it works well in the common case. For each part of the assignment, I've thought of at least one edge case that could cause problems and written a student test for it. (And ideally, I've done this for multiple edge cases!) Style I've read the CS106B Style Guide at least once in its entirety and asked questions about any parts I don't understand. My code follows the guidelines from the Style Guide. My code meets the expectations for readability, decomposition, and program design and adheres to restrictions such as no global variables, no use of obscure language features, and so on. Each of my functions, conceptually, performs a single task. All of my variables and functions use clear and descriptive names. The dense parts of my code are commented, and those comments describe what the code accomplishes rather than restating the logic in plain English. Every function I've written has a comment preceding it that explains what the function does, what its parameters are, and what its return value (if any) means. Each file I am submitting has a header overview comment that clearly identifies the code authorship, including any necessary citations. Final Submission I've auto-indented my code in Qt Creator. The final layout is clean and readable. I've completed the tasks from all TODO comments in the starter code and removed those comments. I've removed all print statements left in the code that I used for debugging purposes. I've removed all commented-out blocks of code that are no longer necessary. I've read the Submit section of the assignment handout and confirmed that I'm submitting all of the required files.
http://cs106b.stanford.edu/syllabus
Hi there and welcome to CS106B! CS106B Programming Abstractions is the second course in our introductory programming sequence. The prerequisite CS106A establishes a solid foundation in programming methodology and problem-solving in Python. With that under your belt, CS106B will acquaint you with the C++ programming language and introduce advanced programming techniques such as recursion, algorithm analysis, data abstraction, explore classic data structures and algorithms, and give you practice applying these tools to solving complex problems. We're excited to share this great material with you and have a superb team of section leaders that will support you through the challenges to come. We hope you will find the time worth your investment and that you enjoy your growing mastery of the art of programming! Teaching Team Chris Julie Chase Nick Our wonderful undergraduate section leaders. I) Online Course Essentials Our course website is located here at https://cs106b.stanford.edu. Our website is your go-to for all course materials (schedule, lecture slides, assignment, section handouts, course policies, and more). Please regularly visit so that you are up-to-date with the latest announcements and course information. We have a course page on Canvas but we only canvas to distribute videos and nothing more - all other materials are published on our course website. The discussion forum on Ed is the place for students to to ask questions and discuss course topics with one another and the staff. Paperless is our tool for assignment submission and grading. You use Paperless to submit assignments, schedule grading sessions and view grading feedback. Signing up for LaIR helper hours is also accessed through the Paperless portal. II) Course Topics Learning Goals After you're finished with CS106B, we hope you'll have achieved the following learning goals: I am excited to use programming to solve real-world problems I encounter outside class. I recognize and understand common abstractions in computer science. I can identify programmatic concepts present in everyday technologies because I understand how computers process and organize information. I can break down complex problems into smaller subproblems by applying my algorithmic reasoning and recursive problem-solving skills. I can evaluate design tradeoffs when creating data structures and algorithms or utilizing them to implement technological solutions. We'll also be giving you tools to tackle the following questions (note that these don't have single right or wrong answers!): What is possible with technology and code? What isn't possible? How can I use programming to solve problems that I otherwise would not be able to? What makes for a "good" algorithm or data structure? Why? Lecture Schedule While the below schedule is subject to change over the course of the quarter, we will cover the following topics (in approximate order): C++ basics Abstract data structures Recursion Classes and object-oriented programming Memory management and implementation-level abstractions Linked data structures Advanced algorithms Prerequisites The prerequisite for CS106B is completion of CS106A and readiness to move on to advanced programming topics. A comparable introductory programming course or experience (including high school AP courses) is often a reasonable substitute for Stanford's CS106A. If you are unsure if this course is the right for you, read more about course placement. III) Course Structure Units If you are an undergraduate, you must enroll in CS106B for 5 units (this is by department and university policy, no exceptions). If you are a graduate student, you may enroll in CS 106B for 3 or 4 units to reduce your units for administrative reasons. Taking the course for reduced units has no change on the course workload. Lectures Lectures will take place on MWF 10-11am Pacific (GMT -7) via Zoom Webinar. Students are encouraged to attend lectures live if possible. Recordings will be posted to Canvas for later asynchronous viewing. Read more about lecture. Sections Students will be assigned to a small group discussion section that meets weekly for 50-minutes via Zoom. The section will be facilitated by your assigned section leader. Read more about section. Assignments There will be regular assignments, about one per week. An assignment may include written problems, hands-on exercises with the tools, coding tasks and/or a larger complete program. Read more about assignments. The assignment deadline policy has been designed to build in flexibility , given that the circumstances of online learning can be unpredictable. Assignments submitted by the due date earn a small on-time bonus. After the due date, there is a "grace period" (typically 48 hours) where we will accept late submissions without penalty. Read more about the late policy. Assessments We plan for a mid-quarter diagnostic and an end-quarter personal project. The mid-quarter diagnostic will serve as a check-in to help you assess your understanding of fundamental topics covered in the first half of the course. The end-quarter personal project will ask you to design a problem of your own that you will write and present to your section leader. This serves as a small capstone to your course experience where you demonstrate how you have grown from a novice padawan into one now capable of teaching to others. We will have more information about these assessments as the quarter progresses. Our primary focus is to take advantage of the virtual learning environment to create assessments that will allow you to demonstrate what you've learned in the class rather than testing you under strict time constraints as in a traditional exam. Read more about assessments. Course Grades Final grades for the course will be determined using the following weights: 60% Programming assignments 15% Mid-quarter diagnostic 15% Personal project 10% Section participation Incompletes The university "I" grade ("incomplete") is appropriate for circumstances of significant personal or family emergency disruption that prevent a student from finishing course requirements on schedule. To be considered for an incomplete, you must have completed all assignments up to the time of the request at a passing level. You must also have an extenuating circumstance that warrants an extension of time beyond the end of the quarter to complete the remaining work. Approval for an incomplete is at the instructors' discretion. Incompletes will not be considered for reasons such as low performance or overcommitment. IV) Course Resources Textbook Roberts, Eric. Programming Abstractions in C++. ISBN 978-0133454840. You can either purchase a physical copy or use the course reader . Recommended readings for each lecture will be posted on our lecture schedule. Software The official CS106 programming environment is Qt Creator, which is an editor bundled with C++ compiler and libraries. The software runs on Windows, Mac, and Linux. The Qt Installation Guide has instructions for installing the tools onto your computer. Getting help We want to enable everyone to succeed in this course and offer different paths to help. The instructors and head TA will hold office hours (Zoom). The course helpers and section leaders staff regular LaIR helper hours (Zoom). The CS106B Ed Discussion forum allows public Q&A and discussion with your peers. Read more about getting help. Accommodations Students who need an academic accommodation based on the impact of a disability should initiate a request with the Office of Accessible Education. Professional staff will evaluate the request with required documentation, recommend reasonable accommodations, and prepare an Accommodation Letter dated in the current quarter. Students should contact the OAE as soon as possible since timely notice is needed to coordinate accommodations. The OAE has contact information on their web page http://oae.stanford.edu. V) Honor Code As a student taking a Stanford course, you agree to abide by the Stanford Honor Code, and we expect you to observe our course-specific Honor Code expectations. Your programs should be your own original, independent effort and must not be based on, guided by, or jointly developed with the work of others. The CS department employs powerful automated plagiarism detection tools that compare assignment submissions with other submissions from the current and previous quarters, as well as related online resources. The tools also analyze your intermediate work, and we will run the tools on every assignment you submit. The vast majority of you are here to learn and will do honest work for an honest grade. We celebrate and honor your commitment. Because it's important that all cases of academic dishonesty are identified for the sake of those playing by the rules, we will refer all cases of concern to the Office of Community Standards.
http://cs106b.stanford.edu/resources/testing_guide.html
Why testing? Anybody that writes code for some purpose (whether as a researcher, a software engineer, or in any other profession) will get to the point where others are relying on their code. Bugs in software can be dangerous or even deadly. Additionally, users do not enjoy using software that is buggy and crashes and fixing bugs once the software is in production is very costly. Most importantly, good engineers take pride in building things that work well and are robust. The key to writing working software is developing good tests. In this course we follow an approach called test-driven development. As you write code, you will also write companion tests. These tests are used to verify that the code you just finished writing works as intended. This strategy is sometimes called "test-as-you-go". You work in small steps, being sure to test thoroughly, and only move on after you having confirmed the correctness and fixed all issues. The beauty of this approach is that each step is relatively straightforward and easy to debug. Imagine the opposite approach: you write hundreds of lines of code, the code does not work, and now you need to figure out which one of those hundreds of lines of code isn't working as expected! That is the sort of frustration that we want to help you all avoid as you continue to develop your skills as programmers. SimpleTest For CS106B, we provide a unit-test framework called SimpleTest that you will use to test your code. This framework was pioneered by our ace colleague Keith Schwarz. SimpleTest provides a simple, clean approach to writing and running test cases. Here is an example of how you might see the SimpleTest framework used in the starter code of an assignment. // reversed(str) returns copy of str with characters in reverse order. string reversed(string s) { string result; for (int i = s.length() - 1; i >= 0; i--) { result += s[i]; } return result; } /* * * * * * Test Cases * * * * * */ PROVIDED_TEST("Demonstrate different SimpleTest use cases") { EXPECT_EQUAL(reversed("but"), "tub"); EXPECT_EQUAL(reversed("stanford"), "drofnats"); } When we provide tests for you in the starter code, each test case is wrapped in the special macro PROVIDED_TEST. The string argument in parentheses describes the purpose of the test and the code block that follows (enclosed in curly braces) defines the actual test behavior. When you add your own test cases, you will wrap your test code blocks in the STUDENT_TEST macro instead. The STUDENT_TEST functionality and structure is exactly the same as PROVIDED_TEST, it simply distinguishes the tests you've written yourself from those we provide for the benefit of your grader. You will see many examples of this in the following sections. EXPECT_EQUAL Within the code block, the test macro most commonly used is EXPECT_EQUAL which confirms the two arguments are equal. A typical use case for EXPECT_EQUAL is to take a value produced by your code, e.g. the return value from a call to one of your functions, and confirm that value matches to the expected outcome. For example, in the above code, EXPECT_EQUAL is used to compare the result of the call reversed("but") to the string "tub". If the two are indeed equal, the test passes. If they do not match, the test is reported as a failure. For example, after adding your own tests (using the STUDENT_TEST identifier as previously mentioned) to the above file, it could look something like this: // reversed(str) returns copy of str with characters in reverse order. string reversed(string s) { string result; for (int i = s.length() - 1; i >= 0; i--) { result += s[i]; } return result; } /* * * * * * Test Cases * * * * * */ PROVIDED_TEST("Demonstrate different SimpleTest use cases") { EXPECT_EQUAL(reversed("but"), "tub"); EXPECT_EQUAL(reversed("stanford"), "drofnats"); } STUDENT_TEST("my added cases not covered by the provided tests") { EXPECT_EQUAL(reversed("racecar"), "racecar"); EXPECT_EQUAL(reversed(""), ""); EXPECT_EQUAL(reversed("123456789"), "987654321"); } Important note: You should never modify the provided tests are the same tests that will be used for grading, so it is not in your best interest to modify them. If you want to test different scenarios, always add new tests using the STUDENT_TEST macro. EXPECT Another test macro that is regularly used is the EXPECT which confirms the truth of a single expression. If the expression evaluates to true, the test passes. If false, it reports a test failure. For example, if you added the isPalindrome function to the above program, you could add a test case that uses EXPECT to confirm the correct result from isPalidrome, as shown below. // reversed(str) returns copy of str with characters in reverse order. string reversed(string s) { string result; for (int i = s.length() - 1; i >= 0; i--) { result += s[i]; } return result; } bool isPalindrome(string s) { return s == reversed(s); } /* * * * * * Test Cases * * * * * */ PROVIDED_TEST("Demonstrate different SimpleTest use case") { EXPECT_EQUAL(reversed("but"), "tub"); EXPECT_EQUAL(reversed("stanford"), "drofnats"); } STUDENT_TEST("test additional cases not covered by the provided tests") { EXPECT_EQUAL(reversed("racecar"), "racecar"); EXPECT_EQUAL(reversed(""), ""); EXPECT_EQUAL(reversed("123456789"), "987654321"); } STUDENT_TEST("test my isPalindrome function") { EXPECT(isPalindrome("racecar")); EXPECT(!isPalindrome("stanford")); } When would you use EXPECT instead of EXPECT_EQUAL? EXPECT_EQUAL which is appropriate for any situation in which you have two values that can be compared for equality (two numbers, two strings, two Vectors, etc.). EXPECT allows you to express a wider variety of conditions beyond simple equality. For example, you could confirm the truth of a complex set of conditions by passing a compound expression such as EXPECT(x > y && y != z || y == 0); EXPECT_ERROR You pass an expression to EXPECT_ERROR and it evaluates the expression and observes whether it calls the error() function to report an error. If an error is raised, this causes the test to pass. If not, it causes the test to fail and reports that the expression failed to trigger an error. EXPECT_ERROR is used in the specific situation of confirming expected handling of errors within your code. EXPECT_NO_ERROR This macro is exactly the opposite of EXPECT_ERROR. With this macro, you pass it an expression, and if the expression successfully runs to completion without running an error, then the test passes. However, if evaluating the expression calls the error() function somewhere along the way, the error causes the test case to report failure. EXPECT_NO_ERROR is used in specific situations where you want to confirm that functions behave properly on correct input. TIME_OPERATION SimpleTest also has support for simple execution timing. To time an operation, evaluate the expression within the macro TIME_OPERATION(size, expression), as shown below: STUDENT_TEST("Time operation vector sort on tiny input") { Vector<int> v = {3, 7, 2, 45, 2, 6, 3, 56, 12}; TIME_OPERATION(v.size(), v.sort()); } The first argument to TIME_OPERATION is the input size; this is used to label this timing result to distinguish from other results. The second argument is the expression to evaluate. TIME_OPERATION will start a new timer, evaluate the expression, stop the timer, and report the elapsed time. You can have more than one use of TIME_OPERATION within a test case. Each operation is individually evaluated and timed. Below demonstrates use of TIME_OPERATION in a loop to time sorting successively larger vectors. STUDENT_TEST("Time operation vector sort over a range of input sizes") { for (int size = 50000; size < 1000000; size *= 2) { Vector<int> v; for (int i = 0; i < size; i++) { v.add(randomInteger(1, 1000)); // fill vector with random values } TIME_OPERATION(v.size(), v.sort()); } } Here are the test results for running the test cases above: Using TIME_OPERATION over a range of sizes lets you see how the time required changes with respect to input size, i.e. predicts the algorithm's Big O. Handy! By default, a test case that uses TIME_OPERATION will be reported as Correct as long as the expression being evaluated does not result in an error or crash. If you want to verify the actual correctness of the result as well as time it, you can mix in regular use of EXPECT_EQUAL and EXPECT into the test case as shown below: STUDENT_TEST("Time operation vector sort on tiny input and verify is sorted") { Vector<int> v = {3, 7, 2, 45, 2, 6, 3, 56, 12}; TIME_OPERATION(v.size(), v.sort()); EXPECT(checkIsSorted(v)); } runSimpleTests The main program of every project will be configured so that you have three choices every time you want to run your program: run all the tests, run a selected portion of the tests, or run no tests at all and proceed with normal execution of the program. The way that you can control this is demonstrated below: int main() { if (runSimpleTests( <test choice argument> )) return 0; ... } The argument to runSimpleTests is either: NO_TESTS (skip testing altogether, just run rest of normal main function) ALL_TESTS (run all tests for all files) SELECTED_TESTS (provide menu to select which file to run tests) Debugging a failing test The goal you are shooting for is for all of your tests to pass. However, if you get a failed test result, don't look at this as sad times, this test result is news you can use. The failing test case indicates that you have identified a specific operation that behaves counter to your expectations. This means you know where to focus your attention. Dig into that test case under the debugger to analyze how it has gone astray. Set a breakpoint inside the text code block, and choose to stop at the line that is at or before the failing EXPECT/EXPECT_EQUAL statement. Now run the tests under the debugger. When the program stops at the breakpoint, single step through the code while watching in the variables pane to observe the changing state of your variables, using a technique just like you did in the debugging tutorial in Assignment 0. After you understand the failure and apply a fix, run that test again. When you see the test now pass, you can celebrate having squashed that bug! Test-driven development We highly recommend employing test-driven development when working on your assignments. To do so, follow these steps: identify a small, concrete task (bug to fix, feature to add, desired change in behavior) construct tests for the desired outcome, add them to the file in which you're currently working, and verify the current code fails these tests implement the changes in your code to complete the task re-run your newly added tests and verify they now succeed test the rest of the system (by running all tests) to verify you didn't inadvertently break something else You change only a small amount of code at once and validate your results with carefully constructed tests before and after. This keeps your development process moving forward while ensuring you have a functional program at each step! Test cases and grading The SimpleTest framework will be supplied with each assignment, and there will be some initial test cases provided in the starter project, but you will also be expected to add your own tests. You will submit your tests along with the code, and the grader's review will consider the quality of your tests. We will also provide comments on your tests to help you improve your testing approach. Please incorporate our feedback into future assignments; it will improve your grade and, more importantly, your effectiveness as a programmer. We guarantee future employers will appreciate your ability to write good tests and well-tested code! Here are some things we look for in good tests. Are the tests comprehensive? Is all the functionality tested? Where possible, are the tests self-contained and independent? Did you anticipate potential problems, tricky cases, on boundary conditions? Did you develop the tests in a good order? Did you test basic functionality before more advanced functionality? Did you take small, carefully chosen steps? Common questions Should each EXPECT/EXPECT_EQUAL be in a STUDENT_TEST code block of its own or can I list several within one code block? For tests that are closely related, it may be convenient to group them together in the same code block under one test name. The tests will operate as one combined group and show up in the report as one aggregate success (if all pass) or one failure (if at least one fails). However, there are advantages to separating each individual test case into its own code block. You will be able to choose a clear, specific name for this block. The separation isolates each test so you can easily identify exactly which cases are passing and which are failing. For example if you have STUDENT_TEST("Many tests together"){ EXPECT(... Test A ...) EXPECT(... Test B ...) EXPECT(... Test C ...) } then if Test B fails, Test C will never run and you won't be able to see the output - you won't know if Test C passed or failed. On the other hand, if you structure your tests like this STUDENT_TEST("Test A"){ EXPECT(... Test A ...) } STUDENT_TEST("Test B"){ EXPECT(... Test B ...) } STUDENT_TEST("Test C"){ EXPECT(... Test C ...) } then all the tests will run individually, and even if Test B fails, you will still get independent information about Tests A and C. Having this sort of isolated behavior might make debugging any problems you encounter a little bit easier! What happens if my test case is bogus or malformed? When testing your code, you should construct each test case so that a correct implementation will pass (receive a "CORRECT"). A test case that been written to "fail" given a correct implementation is considered "bogus". If a test case is bogus, it is usually asking the wrong question. Suppose you have written an isEven function to determine if a number is even and you wish to test its correctness. You have written the bogus test case below that is designed to fail if the isEven function returns false on a odd input. STUDENT_TEST("Test isEven() on odd numbers should fail") { EXPECT(isEven(3)); } If you run the above test on a correct implementation of isEven, the test will fail and the result is reported as "INCORRECT". The only way to "pass" this test would be with a broken implementation of isEven. Confirming whether your function is actually correctness becomes very confusing if your test case is bogus. Instead, you want to ask the question, "Does isEven return true for an even number?" and "Does isEven return false for an odd number?" The tests below are correct ways to test for both true and false results. STUDENT_TEST("Test isEven() on even number should return true") { EXPECT(isEven(8)); } STUDENT_TEST("Test isEven() on odd number should return false") { EXPECT(!isEven(13)); } Both of these tests will pass for a correct implementation of isEven. In short, make sure to design your tests to pass not fail to demonstrate that your code is working.
http://cs106b.stanford.edu/resources/textbook.html
The CS106B textbook is Roberts, Eric S. Programming Abstractions in C++ , ISBN 978-0133454840. The book was written by Stanford CS professor Eric Roberts and targeted directly for this course. Readings from the textbook are suggested to accompany lecture. Section problems and programming homework will not be assigned directly out of the textbook and it possible to succeed in the course without it. However, we think you will appreciate it as a supplement to the presentation of the material in lecture and section. It also contains a wealth of practice problems for self-study. The book is stocked by the Stanford Bookstore or can be ordered online from various retailers. There are copies on reserve in the engineering library. Before the textbook was formally published, a "course reader" version was distributed as a PDF and is available below. The beta version PDF is missing some of the content and polish of the final textbook, but might be sufficient for your needs. Course Reader, Beta 2012
http://cs106b.stanford.edu/qt/troubleshooting.html
This page contains information on how to resolve common problems with Qt Creator projects. Consider searching this page using Ctrl+F (Command+F on Mac) to jump quickly to the text matching the error message or issue you are having. You may also want to check the Guide to Common Build/Run/Debug problems if for issues compiling or running your program. How to "re-initialize" a Qt Creator project A large number of Qt Creator ills can be resolved by following these steps to re-initialize your project. (Please note that this requires deleting some files from your project. Be careful not to delete your assignment solution code. Make frequent backups of your files.) Quit Qt Creator. Navigate to the folder where your project is stored. Delete the file with the extension .pro.user, such as Life.pro.user Take care: Delete only the file with exactly the pro.user extension , not the other files such as the Life.pro (screenshot) Also delete the "build" folder for your project. This is located in the parent directory of your project's directory, and has a long name like build-Life-Desktop_Qt_5_x_x_kit_xxbit-Debug. Delete the entire build directory. (screenshot) Re-start Qt Creator. Choose menu item "File" -> "Open File or Project...", navigate to your project folder and open its .pro file. Qt should ask you to "Configure Project", just as if you were opening for the first time. Now try to build and run to see if things work any better. Installation woes I installed Qt Creator previously. Must I reinstall or can I use my existing installation? You should install the latest. Our projects are written to work with the latest version and the most recent fixes. Check the Qt Creator menu "About Qt Creator" to confirm what version you are running. The version for Fall Quarter 2020 must be at least Qt Creator 4.13.0 Based on Qt 5.15.0. Confirm your version number is equal or greater. If not, delete your existing Qt folder, and follow the steps in our QT install instructions. When I open a new project, the "Configure Project" options are empty. Error: No kits available. A "kit" is a C++ compiler. If no kits are available, your Qt installation may be missing essential components. When installing Qt, you must select the appropriate component (e.g. MinGW or macOS) for your platform, as specified in our installation instructions. If you fail/forget to select this component, the observed symptom is "no kits available". To fix this, you'll need to reinstall Qt Creator. Delete your existing Qt folder and repeat the steps in our QT install instructions. When I open a new project, the "Configure Project" options are all grayed out. Error: No suitable kits found. On MacOS, be sure you have followed the XCode steps in our install instructions. After downloading XCode you must run it once in order for the necessary components to be installed and agree to the license. Opening a project I double-click a .cpp file to open it in Qt Creator and the "Build" and "Run" buttons are grayed out. Double-clicking a .cpp file opens only that single file. You instead want to open the entire project by double-clicking the .pro file. I can't tell which file is the .pro file because Windows File Explorer is not displaying filename extensions. If your File Explorer is set to hide extensions, the file Welcome.pro will display the name Welcome. You can configure for extensions to be displayed in File Explorer by choosing menu item File->Options, select the "View" tab and under "Advanced settings", uncheck "Hide extensions for known file types". Click "Apply" button. The names of my files are grayed out and I cannot build. Error: Rename project directory to remove disallowed characters. The name of your project directory contains a disallowed character. Qt Creator is confused by most punctuation and international characters. Look in the General Messages or Compiler Output tab for the longer message which reports which character is problematic. Rename your directory to remove that character. *** ERROR: The name of your project directory has disallowed characters. *** The allowed characters are letters, numbers, and simple punctuation. *** Your directory is named Assignment#1 which contains the *** disallowed characters: # *** Please rename to a simple name such as Assignment_1 that contains *** no disallowed characters. Permission problems Alerts on MacOS. Qt requesting "access to Desktop or Downloads folder". Should I allow it? Yes. Recent releases of MacOS have have tightened restrictions for programs to access to certain folders. If your project folder is stored in Desktop or Downloads folder, you must explicitly grant file privileges to the Qt Creator IDE and the debugger. Click agree when you get an alert such as this one: You can also go to "System Preferences" -> "Security & Privacy" -> "Privacy" tab -> "Files and Folders" to review and change what access has been granted to individual applications. Build failed on Windows. Error: cannot open output file ...\MyProgram.exe: Permission denied. This error means that your executable is still running from the last time you ran/tested the program a moment ago. Shut down any running instances of your program. You might need to open your operating system's Task Manager to stop them all. Cannot delete, rename, or modify my program .exe file or build folder. Error: You'll need to provide administrator permission to delete this folder. A Windows feature called "System Protection" can lock your .exe programs so that they cannot be modified. You can disable this feature in your system settings. Go to Control Panel, and choose System. Now click the System Protection tab/link, which is either on the left or top side of the window. Depending on your version of Windows, either click the "Disable system protection" radio button, or if you instead see a list of disk drives, double-click on the drive where your project is stored (likely drive C:), and change the setting to Off. Another thing that can cause the "permission denied" problem is anti-virus software. In particular, McAfee Anti-Virus places strong locks on all .exe files that prevents you from modifying or deleting them. You may need to disable or uninstall McAfee to make this behavior go away. What else? I have an error not listed in this FAQ. What else can I try? About 90% of random Qt Creator issues we've seen can be resolved by "re-initializing" your project. Follow the re-initialize steps. Help! It still doesn't work! If you had read through the list of known fixes and were not able to resolve your issue, we will try our best to help you figure it out. Drop into helper hours and show us the problem over Zoom. Or you can contact us via forum/email to get help. In your email/post, be sure to include the following information: Your operating system and version number (Windows 10, Mac OS X 10.15, Fedora Linux 17, etc.) The Qt version information from "About Qt Creator" Which step in the process has failed (be specific) Specific error message Please include the exact text via copy/paste and/or a screenshot. For a build error, be sure to grab the detailed information from the Compile Output tab. Thanks, and good luck! You can do it!
http://cs106b.stanford.edu/tutoring
You are welcome to make use of tutoring resources, both on-campus and off-campus, to help solidify conceptual content, to deepen understanding of course topics, to fill gaps in understanding, and to work through ungraded practice problems. Tutoring can be a great way to work through topics you're having trouble understanding and to get input from someone with more experience than you. Tutoring, however, is not appropriate for help with work that will be submitted for a grade. When you have questions about the assignments or exams, please direct them to the course staff - we're happy to help out! Our formal tutoring policy is as follows. The word "tutoring" has a broad meaning, and we'll interpret it to mean any assistance with the course content or topics from someone who is not currently enrolled in the course and is not a member of the course staff. For example, CTL and AARC tutors, Black LaIR, and help websites like Chegg or Stack Overflow count as tutoring. Similarly, support or advice from past students (say, someone in your dorm who has already completed a course you're taking) counts as tutoring. We consider anyone who offers you support in this context is a tutor, regardless of formal titles. Tutoring must abide by the following rules for CS106B Tutors must be familiar with the Honor Code policy for a course prior to giving help. Importantly, not knowing the Honor Code and tutoring policies for a course does not protect you or your tutors from any Honor Code infractions. A student and tutor should review the course Honor Code policy together to set appropriate expectations and establish clear boundaries. Tutors must not review, look at, offer advice, or otherwise offer assistance with any work that you will submit for a grade or which could be reasonably expected to be submitted for a grade. This means, among other things, that tutors cannot help debug or write code for or related to programming assignments, review written proofs, etc. Tutors must not refer to course materials from previous offerings of the course. For example, tutors are not allowed to refer to lecture slides or solution sets used in previous quarters. They are permitted to reference the current quarter's materials, subject to the restrictions from (2). Tutors must not share any other student's work with you, including their own. For example, tutors may not share past submitted problem sets or coding assignments as a reference, even if the tutor was the original author of that work. Tutors and students are obligated under the Honor Code to "do their share and take an active part in seeing to it that" students and tutors do not ask for or receive unpermitted aid. Course instructors may, at their discretion, place additional limits on permitted tutoring. It is the responsibility of both students and tutors to learn and abide by these rules. Failure to abide by these rules may constitute a violation of the Honor Code. If you have any questions about what is and is not permitted, either as a student or as a tutor, please contact the course instructor directly. We're happy to clarify our policies and help ensure folks get the support they need while keeping everything above board.
http://cs106b.stanford.edu/upcoming.html
Upcoming events Loading...
http://cs106b.stanford.edu/qt/using-qt.html
Opening a project Each Qt Creator project includes a file named with a .pro extension. To open a project in Qt Creator, you may either: Double-click the .pro file in the Finder/File Explorer. In the Qt Creator application, choose menu File->Open File or Project, navigate to the project folder and choose the .pro file to open. Note that opening a source file (i.e. life.cpp) opens that single file. Instead you want to open the pro file (life.pro) to get access to the entire project. The Qt Creator window Below is a screenshot of a project open in Qt Creator. View options The icons in the upper part of leftmost edge are the "View" options. A project opens in "Edit" view and the main pane of the window is used for editing your source files. Another view you will often use is the "Debug" view, which using the main pane of the window for the debugger controls. Project pane is to the right of the View options. It display a hierarchical listing of the project files. The file currently selected for editing is highlighted. Your code files for the project are listed in the Sources folder. The Other files folder contains non-code project resources such as data files, images, and sounds. Build-run controls are in the lower left. Click the hammer icon to build the program. If the project successfully builds, click the play button (plain green triangle) to run the program. To run the program under the debugger, click the debug button which is the green triangle with a bug on it. Output pane tabs are along the bottom edge. At the bottom of the window, there are named tabs for "Issues", "Application Output", and "Compiler Output". Click one of these tabs to show the corresponding information in the lower pane. Sometimes the explanations in the "Issues" pane are too terse to be helpful. In these cases, looking at the "Compile Output" or "Application Output" panes will provide more verbose and possibly helpful additional details. Qt debugger Check out the debugger tutorial from Assignment 0.
http://cs106b.stanford.edu/assignments/2-adt/warmup.html
Throughout this course, you will strengthen your programming skill by writing C++ code. But writing the code is only the first step; you also need strong skills in testing and debugging to bring a program to successful completion. Knowing your way around the debugger is key. Our assignments will feature warmup exercises that are designed to give you guided practice with the skills and tools for effective testing and debugging. This warmup exercise demonstrates use of the debugger and testing on the ADT types. You are to answer the questions posed below by writing your answers in the file short_answer.txt. This file is submitted with your assignment. 1) View ADTs in debugger (manually configure if needed) Look over the provided code in adtwarmup.cpp that operates on Stacks, Queues, and Maps. Some of this code is buggy and provided for the purpose of practicing with testing and debugging. The reverse function is implemented correctly and does not have bugs. It uses a Stack to reverse the contents of a Queue. Build and run the program. When prompted, enter the choice to run tests from adtwarmup.cpp. The reverse function should pass its single test case. (Ignore the test failures reported for the other functions, we'll get to those in a bit). Let's use the reverse function to practice with ADTs in the debugger. Set a breakpoint on the first while loop and run the program in Debug mode. When the debugger stops at your breakpoint, look to the Variables pane in the upper-right of debugger window. You should see the variables q , s and val. Expand q by clicking the triangle to the left of its name. The expanded contents of the Queue should look like this: IMPORTANT: If the Queue contents displayed in your debugger do not match the screenshot above, this likely means that your debugger is not configured to properly display variables of Stanford collection type. Stop here and follow the instructions to configure your Qt debugger. The Queue q was passed as an argument to reverse; its contents were initialized in the calling function to {1, 2, 3, 4, 5}. The Stack s and integer val were declared as local variables in reverse . Neither of these variables was assigned an initial value. In the debugger variables pane, s is displayed as a Stack containing <0 items>. The Stack class has a "default" initializer that configures a new stack that is not otherwise initialized. The default initializer for Stack makes an empty stack. In fact, all of the Stanford collection classes have a default initializer that creates an empty collection. Compare that behavior to what you see for the integer variable val. Like s, the variable val was declared without an explicit initialization. Unlike the collection types, the int type does not have a default initializer. This means the int variable is left uninitialized. The variable will have a "value" but that value is the leftover contents of the location where val is being stored. That garbage value will be unpredictable and can even vary from run to run. Using the value of a variable that has not been initialized will lead to erratic results. Using the Step Over button, single-step starting at the top of the while loop. After executing the assignment to val, the uninitialized garbage value now becomes sensible. Single-stepping the next line adds the value onto s. Expand s by clicking the triangle to the left of its name. You should now have both the stack and queue expanded. Continue single stepping through the loop. As you step, keep your eye on the Variables pane and watch elements being added and removed to the stack and queue. Q1. The display of the Stack in the debugger uses the labels top and bottom to mark the two ends of the stack. How are the contents labeled when the Stack contains only one element? You now know how to inspect and interpret ADTs in the debugger. We hope that you will find this a useful skill when working on the rest of the assignment. 2) Test duplicateNegatives Testing and debugging are closely related. After writing a piece of code, you will want to test it to verify its behavior. If you uncover a problem, you run your test case under the debugger to further diagnose the bug. The function duplicateNegatives is intended to modify a Queue<int> to duplicate each negative number, i.e. turning the queue {3, -5, 10} into {3, -5, -5, 10}. The given code is buggy and does not behave correctly on all inputs. There are some provided tests that demonstrate a few of the inputs that are problematic. Run those tests and observe which tests pass and which do not. The provided test cases include an input with no negative numbers, one with a single negative number, and another with mixed negative numbers. There is no test for input of all negative numbers, so you decide to add one. Add a STUDENT_TEST for this case. Run the tests again. When running, it seems this new case is taking a really, really long time. In fact what has happened is that the program has entered an infinite loop. A infinite loop is one that never reaches its stopping condition. Pro tip: dealing with an infinite loop When a program is stuck, your only recourse is to manually intervene to stop it. If not running in Debug mode, you can stop the program by closing the console window or choosing "Quit" from the menu bar. These actions forcibly exit the program. If running under the debugger, your better option is to interrupt the program using the interrupt button . Interrupting the program will pause its execution and return control to the debugger. The program state is preserved and can be examined in the debugger. This will allow you to gather more information to diagnose what's gone wrong. Let's take stock of what we have learned from testing the duplicateNegatives function. The function works correctly for some inputs. For other inputs, the function terminates but produces the wrong result. Your new test shows there is also a third category, where some inputs go into an infinite loop. When constructing tests and analyzing buggy code, it is important to understand what kind of inputs cause specific problems, as that can help focus the debugging process. To develop your understanding of the function, carefully read over duplicateNegatives and manually trace through it to develop a hypothesis about what might be going wrong. For example, you might predict that the infinite loop is triggered when all numbers in the queue are negative, but you aren't entirely confident about this hypothesis. You wonder if it might instead be specific to an input that starts or ends with a negative number, or specific to having an even or odd count of negative numbers. What additional test cases can you add that allow you to confirm the precise trigger for the infinite loop? Gather the results of your observations and answer the following questions in short_answer.txt: Q2. For which type of inputs does the function produce a correct result? Q3. For which type of inputs does the function go into an infinite loop? Rather than identify one specific input, we would like you to describe the general characteristics of the respective inputs. 3) Debug duplicateNegatives Now that you've observed the buggy behavior and know what kind of input triggers it, let's use the debugger to diagnose the flaw in the code. (You may have already seen the bug when reading over the code; if so, great! But the purpose of this exercise is to show you a methodology for using the debugger that will help you in later times when you cannot spot the bug just from reading the code.) Choose a failing test that goes into a infinite loop. Set a breakpoint on the call to duplicateNegatives inside the test case and then run the tests in Debug mode. When the breakpoint is hit, Step Into the call to duplicateNegatives and then use Step Over to single step through a few iterations of the for loop. Expand the variable q to see its contents and pay attention to the changing values for i and q. Can you use this information to explain why the loop never reaches its intended termination condition? Answer the following question in short_answer.txt: Q4. What is the bug within duplicateNegatives that causes it to get stuck in an infinite loop? Given the above detective work, you may have a fix in mind to apply to the duplicateNegatives code. Try out that fix and see that it resolves the problem with the infinite loop inputs. As a followup, re-test the inputs that terminated but produced incorrect results. You should find they are also working correctly now. In this case, the same underlying flaw was producing two seemingly unrelated symptoms. Debugger use for the win! 4) Recognize a common ADT error in removeMatchPair The last part of the warmup is learning how to recognize when a test case raises an error and how to follow up. The function removeMatchPair is intended to modify a Map<string, string> to remove any pair where the key is equal to the value. Run the provided test cases. It passes the first test that makes no change, but the subsequent test goes down in flames. An error is raised during the test execution. The error message tells you it is disallowed to add/remove elements in the midst of iterating over that collection. (If you think it through, you can see why this would be problematic....) Students very commonly run afoul of this restriction so we thought we'd get it on your radar before it trips you up. When an error is raised in the middle of a test, SimpleTest reports it like this: Test failed due to the program triggering an ErrorException. This means that the test did not fail because of a call to EXPECT() or EXPECT_ERROR() failing, but rather because some code explicitly called the error() function. When you see this message, it means a fatal error was raised when running the test and that the error prevented the test from completing. The error was not expected. It is due is a bug in your code that attempts an illegal operation. Sometimes there is additional commentary which further explains what made the operation is illegal, e.g. index was out of bounds, attempt to read a non-existent file, or modify a collection while iterating over it. You follow the same debugging process for an error as a failing test case: set a breakpoint in the test case and step through the test to see what has gone wrong. There is one added twist that you can step up to, but cannot step over, the actual crashing operation. If you step over an operation that crashes, a clever bit of C++ "hyperjumps" control to an error-handling routine (or perhaps program may terminate if error is more catastrophic). You must restart the program and step up to the crash again to regain the context at the point of the crash. Q5. What is the value of the variables (as reported in the debugger variable pane) right before the program crashes? What happens if you try to step over the line where the program crashes? That's it. Now that you've made it through the debugging exercise, you should be prepared with all the skills you need to attack the rest of this assignment. Go to it!
